This video is about fragmentation, application, and transparency. Transparency in distributed databases is about taking information that are not relevant for the user's perspective and keeping it hidden from them. So, for instance, you might not care how precisely the database is stored, you just care about what you want as a result of your query. And it's in the database management system's job to figure out how to get that to you. So this fragmentation and replications are two important examples of transparency. And I will cover a few different types of transparency in this video, especially those two. The first kind of transparency I want to talk about is fragmentation. So basically, the idea is that you have a table or similar, and you then cut it into small pieces and store each piece at a different place. So we have in general two kinds of it. We have horizontal fragmentation, or also called sharding, especially when we get further into the course. It's called sharding, especially in the NoSQL databases, which we'll get into in a bit. But the idea of horizontal fragmentation is that you take some rows out and then you store these rows at different sites. So you might have one point of rows stored on one side, another point stored somewhere else, and so on. In general, you don't need that these sets are disjoint, but it could be it's fine either way. The way you then get the original table back is just to take the union of all of these fragments. And that will give you the original table. And it's a database job to hide this from the end user. They don't need to know this. It's not really relevant for what they do for their queries, the end users queries. On the other hand, we have something called vertical fragmentation, and I'm fairly sure you can figure out what it is all about based on the name. So again, we have a table and we cut different columns out and store them at different sites. Now here, the fragments typically should have some overlap, because the way we're going to get the original table back is we're taking the natural join of all these parts, and that should give you the original table. So if you don't want it to be this Cartesian product where you get all combination, they should have the overlap of, say, a key attribute. This is a quite common way of using vertical fragmentation. So the key thing here, because I'm talking about transparency, is that the user don't actually see all of these fragments. They just see the full relation when they make the query. So they make a query on R and not on each fragment, either of horizontal fragment or vertical fragment. It doesn't matter. It should be hidden from you as a user. You can also do combination of these, and we will also see that in a bit. And yeah, and this idea is called fragmentation transparency. Let me come with some examples of these fragmentation styles. So we have our CSStore running example from before, and we have this transaction relation in it, as you might have seen in your assignment. So it has employee ID, custom ID, date and transaction ID. And each site stores the relation that contains a subset of the tuples. So we might have, say, that Liverpool has these two, Manchester might have these two, and London might have this one. So different sites have different tuples, and you can then get the full relation by taking the union of these things. And that full thing doesn't physically exist, but you can sort of play around with it as if it did. So you can run whatever query you did in your assignment about the transactions, and it will work the same way, even though different parts of it is stored at different locations. Even with all of that, the database management system figured out how to put them together and run the full query in a smart, efficient way, based on this code it's got into. I want to make a specific aspect of these transparency clear here before moving on to vertical fragmentation. So as I said, we keep it transparent. You don't need to know where the different tuples are stored to make a query, but still, if you for some reason would like to know, you can typically get this information. So for instance, we might store this information in a column like here, telling you which store has this precise tuple. Or we might have some easy to check condition that makes it easy to see where the precise row is stored. And this doesn't play transparency. It's just that you don't need to know this to make the query. You can ignore it to make the query, but if you for some reason would like to know, you can know typically where the different parts are stored. Let me come back to an example of vertical fragmentations as well. However, I cannot really use one from your assignment because it was quite normalized, and there wasn't anything great to put as a vertical fragmentation. So I'm giving you an example that is not present in your assignment. So here we have a database with a name, or relation with name, transactions ID, customer, here and price. So it's a customer in this transaction has bought this item for this price kind of information. And the way it's stored in database might be that the central site has a name and a price because at all stores, the items has the same price. And then each site is storing what the name of the item is, transaction's ID and the customer ID. And the way you then get the original table from these two sub tables is that you take the join of them, typically some kind of natural join, but it could be another kind if for some reason you have overlaps that should not be part of the natural join. Typically, you wouldn't do that though in this kind of vertical fragmentation. So, again, the key thing here is that the original table doesn't actually exist. But when you make queries, you can act as if it existed behind the screens that the database management system just put them together and you get this table out of it. And now we have done a vertical fragmentation, we can also mix in horizontal fragmentation afterwards or the other way. We could start with a horizontal fragmentation and mix in some vertical fragmentation and then keep going like this any number of times. I think it's most common to only use a few steps of this because whenever you do a vertical fragmentation, you have fewer columns and we don't have that many columns in the first place. So typically there will not be too many steps where you change between vertical and horizontal fragmentation, but you can do a few and in principle you can do any number. Next, I want to talk about redundancy as having multiple copies of the same item. It's also called replication transparency. So one of the things this helps with is improving resilience in case of failure. Let me come with an example here. Say we have our running example again. We have a distributed database, the central office part in Liverpool, Manchester and London. And then we run our query here in the central office about sales in Manchester. However, there was a system failure, so the server doesn't work. We cannot get answers about Manchester if we do not have any replications at all. However, what we can do is sort of store bits and pieces of Manchester system in all our sites and then to get the result of this query, we can ask these other sites for the result of the query and we're good to go. So this is in essence the idea of this redundancy, or at least part of the idea. It allows us to answer the queries involving data from systems that have failed by having this data in multiple places. Another aspect it's also helped with is improving efficiency. So say we have a query about the suppliers up here and if other sites, just the central office like before, stores information about the suppliers, we might be able to do it faster by getting part of the pieces from the central office and part from other places, or everything from other places, depending on how much it is. So you can answer queries about the suppliers here without establishing a connection to the central office, or you might be able to get part of it from the central office and part from elsewhere. Let me try to describe how this is done in this replication transparency. So basically replication is about how many copies of a fragment you have in your distributed database. So one extreme, and this is a full spectrum of options, one extreme is full application, in that case every site stores a full copy of the full database. And there are no fragments really. This allows you to answer queries very fast, because you just connect to a random server and that server will have everything you need to answer your query. On the other hand, it makes updates very slow because you need to update all the servers to make one update. It also makes things consume a lot more space and stuff like that. The other extreme is no application. Here each fragment is stored at a Unix site. Quests are a big problem. You cannot get the answer to a query if there's a quest in the involved data. On the other hand, updates are quite fast. You just need to update one place. But queries are a bit slower because, well, you need to get information from everywhere to answer a query in general. And of course, in between these two extremes, there's any kind of other options. You can store a bit of stuff, a few copies of each item, or you can store any number of them. You might only replicate some parts. You might not replicate other parts, depending on how important it is, so on. But again, your database selects one or your database administrator selects one. And then from the user perspective, it doesn't look different. I mean, of course, if the system crashes, you will notice that you might not be able to answer certain queries anymore. But still, apart from that, it will be transparent to the user how you're doing this application. Because the user just writes the query and the system then figures out where all of these different parts of the query are stored and how to get it to you. So in essence, these transparencies are about hiding certain aspects from the user that they don't need to know when they create the queries. And we have some different levels. This fragmentation transparency is the highest level. If you have this, then you have all kinds of transparencies. If you do not need to know where your pieces are coming from, well, everything else is about dividing your database into pieces, like in fragmentation. So one of them, as I mentioned, was this replication transparency, where you have some pieces coming from storing different parts of your databases repeatedly in different locations. But there are also other kinds of transparencies than the one mentioned already. There's something called location transparency, where the location of the data is transparent to the user. Notice that this is basically the same thing as replication transparency, but it is more specialized than fragmentation transparency. And there's also things like naming transparency, where you need to ensure that the name refers to the same thing everywhere. So, for instance, the name of the relation must mean the same thing everywhere. So you cannot have a certain name, means one thing in one location, but another thing in another location. And there is a bunch more. This topic is a bit hard to sort of do formally. The two first levels, this fragmentation transparency and replication transparency. These are very commonly used. If you search for them, you will find many links to them and lots of explanations. But besides that, different sources will have different kinds of transparencies. So this location and naming transparencies, you will find them in the book. You will also find them online in a number of places, but other places might have other kinds of transparencies instead of location and naming transparencies. But still, as I said, fragmentation and replication are basically the two top levels and the most common ones. So, as a summary, we have seen four kinds of transparencies here. Fragmentation, where any kind of fragments of your database should be hidden from the end user. We have a bit weaker one, replication transparency, where you don't need to know that your data is stored at multiple sites, but you might still need to know about some kinds of fragments. We have location transparency, where you don't need to know where the data is stored. So it's kind of similar to replication transparency. And finally, naming transparency is about having the same name for, say, the same relation everywhere. [BLANK_AUDIO]
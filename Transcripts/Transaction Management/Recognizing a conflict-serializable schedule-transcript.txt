The point of having this conflict serializable schedule was that we could recognize them quite easily. However, I haven't actually shown you how to recognize a conflict serializable schedule yet, so that's what I'm going to do in this video. So yeah, I'm going to show you how to figure out if a schedule is conflict serializable or not. It's not really that complicated, will you? We'll see it in a few slides. So in the last video I was talking about the schedule towards the end. I argued that this schedule was serializable, basically because it only depended on wv2y and wv3x, that they should come at the end, and there was a serial schedule that did that. I also said it's not conflict serializable, but I did not really come with any real argument for this. So let's start with a real argument for why this is not conflict serializable. So how do we show that? Well, I'm going to show the procedure first, then I'm going to sort of, as in this example, then I'm going to show it more formally, and then I'm going to show that that procedure actually works further in this video. And a few more examples of this stuff. So what we do is, you find the transactions, making up the schedule. We see we have a transaction 1, we have a transaction 2, and we have a transaction 3. So we make a state for each of them, T1, T2, T3, each for the different transactions. And then we find the conflicts in the schedule. Well, we have two items here the operations are working on. We have the ones working on item X. These are these three. We see they're all write operations, actually all operations in the schedule, so write operations, and they're all from different transactions. That means that they're all conflicting with each other. Now we also have an item Y, and we see that the two involved operations are from different transactions, and again they're write operations, and therefore they're conflicting. So the red ones gives us a set this year. The idea is that you have an edge from 2 to 1, for instance, because WV2X is before WV1X in the schedule, as in this transaction, or this conflict, is first WV2X and then WV1X, and therefore there is an edge from 2 to 1. There is an edge from 2 to 3, because WV2X is a conflict with WV3X, and WV2X is first. Similarly there's an edge from 1 to 3, because there is WV1X is in conflict with WV3X, and there's an edge between those. There's also an edge from 1 to 2, because of the item Y, that WV1Y is before WV2Y, and they're conflicting. I have two colors here on the edges. Normally we will not have it. It was just to make it clear where the edge is coming from. It has no other meaning than to provide a reference up to the figure on top. Yeah, normally you would not color the edges. So the key idea here is that the conflicts impose a constraint under order that some sections in any conflict serial schedule, which is a bit of a mouthful, but what it means is that if you have a cycle like this one, then it's not conflict serializable. Because in essence, and we will see later precisely that this is true, in essence we need in a serial schedule that T1 is before T2, and T2 is before T1, and we cannot have both of them at the same time, and therefore there are no serial schedule that fits this schedule. So let me try to explain it more formally what's going on. We are constructing something called a precedence graph. We do it as follows. We have a schedule S, it's a directed graph, and the nodes are the transactions making up S. So before we had one, two, three transactions, and therefore we had three states T1, T2, T3. And there's an edge from a transaction to another transaction. If there is a conflict in pair of operations, operation one and operation two, in S such that operation one comes before operation two in S, operation one comes from transaction I, and operation two comes from transaction J. Then there is an edge from T1 to TJ. And there's no other edges in these edges defined like this. So for instance, if you have this other schedule, you'll get this precedence graph. You can sit down and go through it to see all the conflicts, and see that we have all the edges as we should have. And again, because there's a cycle here, this schedule is not conflict serializable. If there has been no cycles, it would be conflict serializable. And we'll also see an example how to find a serial schedule corresponding to that case. We'll see that towards the end. So how do we use this precedence graph to test if our schedule is conflict serializable or not? Well, we do this two-step algorithm. First, step one, you see you construct the precedence graph for the schedule. Step two, you see if there is a cycle in it. If there is no cycle, then it's conflict serializable. If there is a cycle, then it's not conflict serializable. So let me come with an example here. Let's look at this schedule here. We have two transactions in this schedule, so we have two states. And if you look carefully, you will find that there is only an edge from one transaction one to transaction two. For instance, W1X is conflict with R2X, but there is no edge the other way. This is because for each item, first transaction one is doing everything it wants in it, afterwards transaction two is doing everything it wants in it. And that's why we do not get any cycles here, in essence, if you look at the conflicts. So again, because there's no cycle here, our algorithm tells us that then this schedule is conflict serializable. Let's look at another example, this example here. And here we have three transactions. It's actually one from the earlier slide. And we have a cycle here, and it means that it's not conflict serializable. So it's fairly straightforward to do it, but you need to spend a bit of time to construct this precision scarf specifically to find all the conflicts. But again, you just look on each item on its own, and then there's a conflict between each pair of operations set up from different transactions, and one of them is the right operations on this item. You just do it for each item, and then you are done. So why does this work? Well, let's try to combine arguments. Say we have a precision scarf looking something like this. As in, we have two transactions here, and it's from one of them to the other. What does this mean? Well, there's a conflict here between t1 and t2, so that the operation from t1 appears before the operation in t2. This is everything this adds from t1 to t2 means, and it means nothing else. And in what we then get, and this is what we will argue next, in all conflict equivalent schedules, this operation from t1 must be before the operation in t2. Okay, and we're going to use this then to show that if there is a cycle, then there is no conflict equivalent serial schedule, which means that the scarf is not, or the schedule is not conflict serializable. But we'll do that after having shown this statement here. So, let me try to argue that in all conflict equivalent schedules, the operation x that are conflicting with the operation y, and x is in t1 and y is in t2, is such that x is before y. We are going to do it by showing that the opposite is not true. That means that there cannot be any conflict equivalent schedule where this is not true. So, let's see, say we have one, and we then show that this is false. So, we are making a mistake, and therefore we must have that all conflict equivalent schedules to open operation x is before operation y. So, the way we are arguing it is by looking at the first consecutive swap between s and s', in this conflict equivalence swapping phase, where x goes from being before y to being after y. Since it's true that y is before x in s', and it's after x in s, it must go from one to the other at some point. That's why we can find the swap by this happens for the first time. So, we have some options for this swap. It can either swap x and y, but we're not allowed to do so because in conflict, and we are only allowed to make this consecutive swaps between things that are not in conflict. Or, we can swap at most one of them, but in those two cases, either we are swapping two things that are after x, because the consecutive things we are swapping, or we are swapping two things that are before y. In either case, we cannot move from having x before y to having x after y. That means that this is a contradiction. That means our assumption is wrong, and our assumption was that we had a conflict equivalent schedule, where y was after x. That means x is always before y. And this was what we wanted to show, and now we have shown it. So, now I'm going to show on the next slide how we use that to show this Dufferbach cycles. So, what does it mean that we have a cycle in our Poseidon's graph? Well, consider some serial schedule. It must put some transaction in this cycle first, because it does one transaction, then another, and then another, and then another, and so on. So, some transaction in this cycle must come first. And since there's a cycle, there must be a transaction that points to this first transaction t in the serial schedule. And that means that from the last slide, we must have an operation from s must be before transaction t. But this is a serial schedule. That means that everything in s must be before t. That means that we had not picked the first one when we picked t. But something is first, and therefore it's a contradiction that we have a serial schedule when we have a cycle in our Poseidon's graph. Yeah. So, yeah, this is an argument for why we cannot have a serial schedule that's conflict equivalent to our start schedule if we have a cycle in our Poseidon's graph. And that was what we wanted to show. And now we have seen that this algorithm I claimed earlier, that this algorithm actually worked. So, let me come with some more examples. This one was the one from before. We had a cycle here, and of course, I also said that earlier, because we had a cycle, then it's not conflict serializable. Because in all conflict equivalent schedules, some operation in t1 must be before an operation in t2, and some operation in t2 must be before an operation in t1. And there is no such serial schedule, and therefore we are done with the argument. So, let's try another example here. Here we have this schedule here, and then we need to find the Poseidon's graph, which in essence is about finding all the conflicts in this schedule. As I said earlier, the easiest way, at least from my point of view, to find them is to look at each item on its own, find the involved transactions, and see if there are some byte operations, and then make the conflicts from there. For instance, if you look at item X here, we see that transaction 1 and transaction 2 is accessed in it, and transaction 2 is actually writing to it. That means that there is a conflict between that byte operation and transaction 1. Specifically, this read1X is conflict when we write 2X. And read1X was before write2X. That means that there is an edge from 1 to 2. You just proceed like this through all other items, and get up on edges like this. And if you do it correctly for this schedule, you'll get this curve here. Now, this curve has no cycle, specifically no directed cycle, and therefore it's conflict serializable. Notice that it has an undirected cycle, but we don't care. This is a directed curve, and we care only about directed cycles. So, earlier I said we can also use this to find a conflict equivalent serial schedule. Let's see how to do that. So, the short version is "initropological ordering yields a conflict equivalent serial schedule". If that is not something you know anything about, let me try to walk you through it. But if you know what it is, well, I've already told you how to find a conflict equivalent serial schedule. So, what you do to find a serial schedule is you find a transaction with only outgoing edges. If you look at this, we see that T1 has only, or T3 has only outgoing edges right now. It has 1 to T2, and 1 to T1, but now nothing points to T3. So, you put it next in your schedule, in your serial schedule, you remove it, and all is outgoing edges from the graph, and you repeat. So, right now our serial schedule looks like this. It first consists of R3, Y, R3Z, W3Z, because these are the operations making up a transaction with R3. And then we repeat this. So, we see that T1 now has no incoming edges. That means it is only outgoing edges. And therefore, we put it next in our schedule, remove it, and all is outgoing edges from the graph, and we repeat. So, we find a transaction with only outgoing edges, which is T2, because, well, there is no outgoing edges left, so it has only outgoing edges specifically. You put it next in your schedule, remove it, and all is outgoing edges from the graph. So, now we left this situation here, there's no graph left, and we have our schedule down here, and this is a serial schedule. It's first everything to do with transaction 3, then everything to do with transaction 1, and then everything to do with transaction 2. So, 3, 1, 2 is a conflict equivalent serial schedule to the initial one here. So, that's sort of the algorithm to find that kind of thing. So, as a summary, as I said earlier, our database management system uses these conflict serializable schedules. And the way you check if the conflict serializable is then to see if there is a cycle in a precedence graph. And we call that a conflict is a situation where you have a pair operation that cannot be swapped without changing the behavior of at least one of the transactions. So, that allows you to find a precedence graph like this. You have a state for each transaction. There is an edge from one transaction to another, if and only if there's a conflict involving them with the operation from the first transaction occurring before the second one. And that's the algorithm for it. If you, this gives you a precedence graph, and then you can see if there's a cycle or not in this one. And if there is not, then it's conflict serializable, otherwise it's not conflict serializable, and that's algorithm.
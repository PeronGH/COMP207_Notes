In this video I will cover other kinds of logging. Specifically, I will cover redo logging and I will cover undo/redo logging. And also how to ensure atomicity and durability using this kind of logging system. Let's start with redo logging. It's about restoring committed transactions. And we ignore incomplete transactions. Because they're supposed to be undone. So we're basically having the same kind of log files as before, as in like an undo logging. So if you don't know what it is, go back and see the previous video. But we have a new meaning of this t,x,v. It means that transaction t has upgraded the value of database item x and the new value is v. So before it was the old value, now it's a new value. So again, it's a direct response to y and x. And we haven't changed the value of x on disk yet when we write this command in the log file. So how do we modify the previous logging procedure? And we will teach that in a bit. Insured durability and atomicity, but that was for using the undo logging. Now we would like to ensure both using redo logging, so we have another procedure to do that. So let's look at redo logging. The procedure for that one is a bit odd. It needs a new command. And we are doing all these things to ensure atomicity using just this redo logging. So the procedure is as follows. First you write all log records for log dates you don't need to commit, or you don't need to write it to disk. You can just write it in the buffer. Then you write commit t and you output everything in the buffer for the log out to the disk. So you write this plus log. And then you write committed values to the disk. You are not allowed to write uncommitted values to the disk, because otherwise you run into problems. So I am going to make a new command here. I am calling it outcome, which outputs the last committed value from the buffer to the disk. So it is a bit different. So let me come with an example and see how it works. So again it is basically the same setup as before. And I am going to go through this trial a bit fast, because if you want the details here, you can go back and watch the video on undo logging, the last one, and you will see the details. So we start with transaction t. And then the time one, time two, and time three. Basically the same thing as for undo logging. The only difference is we write t comma x comma two instead of t comma x comma one. So I didn't really see much pointing in and going through those steps again, because it is the same step as for undo logging. Similarly, the next three steps are similar to undo logging, except we write t comma y comma 20 in response to write y. Notice that before we wrote t comma y comma 10, now we write t comma y comma 20, because we are talking redo logging. At this point we are done with transactions, in this transaction. So we write commit t, we first log out to the disk, and now we have this outcome operation with output, the last committed value, which was two for x, and outcome y with output the last committed value for y, which was 20. And the output that to the disk. So it is a new command, it works like that. In essence. So let's go back and talk about the procedure for the redo logging. As I said, we need to ensure that we only output committed values, so that is why we had this outcome operation. And the fundamental property of this redo logging is that if commit t occurs in the log, then the log contains everything you need to know about t. And if commit t does not occur in the log, then we have an output anything and things are therefore also fine. So we need to have these two properties and then we have atomicity and durability using only redo logging, if we're using this weird outcome operation. So how do we do recover with redo logging? Well, it's in essence just the reverse of undo logging. So we identify all transactions for the commit in the log record. We turn towards the log from the top to the bottom before we turn the log from the bottom to the top. Here we do it from the top to the bottom. And whenever we see a t, x, v for a transaction that has committed, we change the value of x on the disk to be v. And for each incomplete on section t, we just write a port t. And we don't do anything on the hard disk for that one, because, well, it hasn't done any objects. So that we don't need to do any changes because of this. So let me go to the example here for redo logging. Basically, let's see what kind of changes we do overall. So what we're doing here for redo logging is basically the same thing as we did for undo logging. But let me go through it anyway. So in the beginning, we write start t1. Then we get into this transaction 1. We do redex, we multiply x by 2, and we do this redex. And here we write t1, x, 2, because the value of x has written into the buffer, it is 2 for the value x. Then we start on section 2. At then at time 8, after we're done with x and y in a different transaction and multiply x by 3, we write t2, x, 6, because x has been changed from being 2 to being now 6 in the buffer. And then we add x and y together into section 1. This gives you 4, and therefore on write y, we write t1, y, 4, because we have updated the value of y to be 4 in the buffer. And at this point, we commit t1 and the first lock. That means we put everything here in the lock on the disk. And we do this outcome operation x and the outcome y. That means we write the value of x on the disk should be 2, and the value of y on the disk should be 4. Notice that we don't use the value of 6, because transaction 2 has not committed yet, and therefore we are not allowed to write that value out. And at this point, we commit transaction 2, 2. We first lock, that means we write just this commit t2 out, and then we outcome x, and this point we have committed transaction 2, and therefore we can take the value of 6 and put it out to the disk. And this is how we do log-in on this example. So let's look at ondo/redo logging, which is basically taking the good things from ondo logging, compiling it with the good things from redo logging, and then doing that. So the key thing here is that we don't require too much from the procedure for ondo/redo logging. And specifically, we don't need to do this outcome x anymore, as we did in redo logging. So basically, we have the same kind of log files as before, except we replace t,x,v with t,x,v,v. So this new command is saying t, update the value of x in the buffer, it was before v, and it's now wv. So basically, we have the ondo logging things, and we have the redo logging command, and we combine these two commands into one command, telling you both what it was before and what it was afterwards. It makes sense when you need to do both ondo and redo logging at once. At least I think so. So the procedure, and it's not so strict as neither ondo logging or redo logging alone, so it's sort of quite loose in some sense. The procedure is as follows. You write all the log records for all updates to the database items first, and then add some data points to write the updates to the disk. And you can write commit t either before you write updates to the disk or after you've written the updates to the disk. In either case, we are fine with the log file. If commit t is omitted, we can undo it. If commit t is written in the log file, we can redo this transaction using the log file in another case. So it doesn't in some sense matter which order of these two things are. Typically, you will just write commit t and then do the update for the disk whenever we have time for it, because it's cheaper. So the only annoying thing is that the recovery for ondo/redo logging needs to basically combine ondo logging with redo logging. So we need to proceed upwards from the bottom to do the ondo logging, and proceed downwards from the top afterwards to do the redo logging. I suggest doing it in that order, simply because in redo logging you needed to know what was committed before you started running from the top to the bottom. And you can get that information from the first phase when you do the ondo logging. So let me come up with an example here. Again, it's a similar example to before, because I feel that this is easiest to understand if you keep on using the exam example. So this time I'm going to go over it carefully, because the database management systems are really using this thing, and therefore it makes sense to be a bit more careful about it. And also because I think it's good to see this twice at least. So we start on second T1 at time 0, and the first thing we do is we're going to read X. So what was this doing? Well, it tries to read from the buffer into the local version, but it wasn't there. Therefore we're going to get it from the disk into the buffer, and from there into the local version of T1. Then we multiply X by 2, so X goes from being 1 to being 2. Then we write it out. So we move it from the local version into the buffer, and then update the buffer by saying that T1 has changed X. It was before 1, it's now 2. So we write T1, X, 1, 2. And at this point we start on section 2, and we still need to read X. And the read X in this case can get the value of X from the buffer, it doesn't need to go to the hard disk. So we just take it from the buffer, put it into the local version for X, and then we're going to do a read Y into section 1. So it's going to take and try to get the value of Y from the buffer, but it wasn't there. Therefore it goes and grabs it from the disk, pulls it into the buffer, and from the buffer into the local version of T1. And at this point, on section 2, we start multiplying X by 3. It was before 2, so it ended up being 6. And then we write X out again from the local version in T2, out to the buffer. So it looks like this. And at this point, of course, we need to update our log about this update. So we write that T2 has updated X from 2 to 6. So we write T2, X, 2, 6, and it all fine. Then we add X and Y into section 1, and let that be Y. So X is 2 here, and Y is 2, so Y is being updated to being 4. And now we write Y from the local in T1 out to the buffer. And of course, we write in the buffer that we have changed T1, has changed Y from 2 to 4, as we write T1, Y, 2, 4 in the log file. At this point, we're done with section 1. We might commit T1. We flush the log. We put all these things out to the log file. We output X, and we output Y. So first, output X. We take the value from the buffer and put it into the disk. We don't need to do this weird outcome anymore. That was part of why we wanted to do undo/redo. And now we have the value of X on the disk being 6. Then we write output Y, and we change the value of Y on the disk from being 2 to being 4. And that was it for transaction 1. Now we commit transaction 2. So we write commit T2. We flush the log. That means we put only this commit record out on disk. Everything else has already gone on the disk. And then we output X. It doesn't do anything in this case, because the value of the disk X was already 6. So it doesn't do anything. But of course, in principle, you're doing something. So in earlier years, one of my students asked why database management software is actually using this undo/redo. And that's a fairly good question. So let me try in the next few slides to explain why we're doing that. Basically, by explaining why the other options are less efficient. So what if we just had undo/lockin itself, then it essentially ensures atomicity. And we can ensure durability using force. And what it means is that we force the writing of update the disk before commit. That was why we had this procedure for undo/lockin. That's what was ensuring this force. We can also do no force, which means we don't require this. So force is active when we make this requirement. No force means we don't require this. And force is quite expensive in disk operation, because you need, whenever you want to commit something, you need to first write things out on disk. Otherwise, if you could just wait, it much cheaper, because you don't actually need to do anything in that case. You can just commit the first things out on disk in the first lock and not actually commit anything. It's cheaper, because you can do this, move things from the buffer into the hard disk whenever you have time for it. So on the other hand, we had this redo/lockin. And in itself, it ensures durability. We can use the redo/lock to redo things and that way ensure durability. And we can assure atomicity using no_steel. No_steel was why we had this weird procedure for redo. So no_steel means that uncommitted data may not overwrite committed data on disk. And that was why we were only writing out committed values from a lock file into the disk. And steel is not requiring this. Of course, no_steel is expensive to ensure. You basically have to take the values from the lock file, which is a bit annoying to do also. Here I want to point out, because I think a number of people struggle with it, no_steel is the requirement here. And steel is not requiring anything. On a previous slide, when I talked about underlocking, force was requiring something, no force was not requiring anything. So there is not really that consistent definition of this stuff in some sense. No_steel hit doesn't mean that you don't require anything. Try to remember it. It's how it's typically defined. So it's not because I'm defining it somewhat weirdly. You would also find this in the books and stuff like that. They will define it like this. So let's talk about atomicity and durability and look at, say, underlocking and redo locking. So in principle, we could even ensure atomicity and durability without using any kind of lock by requiring no_steel and force at the same time. It's very hard and quite expensive to ensure. If you think about it, you must write every change to the disk made by the transactions while performing the commit statement. So it's really too much done at the same time, but you could in principle do that. Still, it's way too expensive. It's much smarter to just do undo/redo locking and therefore can do steel/no force. So if you want steel/no force, which is the cheapest and what is required at the tool, you just use undo/redo locking and you're done. And this is why we're doing undo/redo locking in our database management systems, because we then get to do steel and no force, which doesn't make any requirements on anything. So this is why we're doing it. So in this video, I covered redo locking, I covered undo/redo locking, as in basically the kind of locking you should do if you just want to be able to do redos or undos and redos. I also explained to you why DBMS uses undo/redo locking, even if it's sort of the more complex option, because it requires you to write a longer log file. But because it's much cheaper to do, that's why the database management systems are doing it this way.
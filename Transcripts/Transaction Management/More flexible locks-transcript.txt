In this video, I will describe a few more things about a more complicated kinds of logs, and I will show you an issue with one in two with all of the kinds of logs we see, and that issue will first be dealt with after I've discussed recovery in the next many videos. So, basic logs are very basic, it's kind of in the name, but they're not really precise. If you remember the definition of conflict civilizability or just conflicts, you saw that if you had a read on and write operations in different transactions on the same item, then you had a conflict. You also had that with two write operations, but if both operations were read operations, then there would be no conflicts, and we in some sense would be fine with allowing that kind of overlap between two transactions. But we cannot have that kind of overlap if you're just using the basic logs, because you'll have to request the full log to do this kind of even basic overlap, where you only try to read in both operations or both transactions. So, another thing I want to mention here is a problem we end up seeing. Even with any kind of logs, which is called deadlocks, it even can occur in 2PL transactions, but I will not show you how to deal with it right now. I'll come back to it later after having shown, well, a bit more on recovery, because it feels better at that point. So, what I showed in the last video was if you had multiple transactions and they were all 2PL, then you ensured conflict serializability. But we might still, even though we have a 2PL schedule or 2PL transactions, we might still run into some issues. We might want to do something called deadlocks. I will show that next, what it is, and we might run into some other issues. For instance, right now, if you think about it, we still have a problem with isolation, because we read things that are uncommitted in some cases. I will not show you how to deal with these things right now. I would rather show a bit more about logs, as the video said, and then discuss recovery for a while. And then, after we talked about recovery, put it together with this concurrency part, and there are the scores deadlocks, because they will come in in both parts, as in both here, in concurrency, and the next part of recovery. Both things will end up dealing with deadlocks, therefore it makes more sense to discuss them together. So, let me try to describe this problem I mentioned with the deadlocks, and then proceeding a bit more about other kinds of logs, and then coming into recovery, and then talking a bit about how to solve this deadlock problem afterwards. But that will first be quite many videos into the future. So, in transaction one, say we did this, and transaction two we did that, and you might think, hey, I've seen this two transactions before, and you would be totally wrong. The one we saw earlier did the things in transaction two about x first, before doing the things about y, but otherwise it's the same thing. But yeah, we just swapped transaction two around, basically. So, it shouldn't, it feels like it shouldn't matter too much, but it will risk getting into a problem that's called deadlocks. So, say we did the first part about transaction one first. So, we log item x, we read item x, we add 100 to x, and write x out. Okay, then we might do the first part about y here, and transaction two. So, we log y, we read y, we double y, and we write out y. Okay, that's fine. We haven't violated anything, everything is fine here. What should we do next? We have two options. We can do the next operation in transaction two, or we can do the next operation transaction one. Let's see what happens if we try to do the one in transaction two. The one in transaction two is to log item x, but transaction two is going to, the scheduler is going to deny that request, because transaction one has that lock. So, we cannot do the lock over in transaction two. Okay, we just move forward in transaction one then. Fine, no problem. However, what transaction one will want to do now is to log item y, and that's again going to be denied by the scheduler, because transaction two has the lock on y. And here we see both transactions cannot move forward, and therefore we are stuck here. And this kind of stock here is what we call a deadlock, where we cannot move anywhere, because people have locks on both sides, but both people have locks, and they need to otherwise lock. So, we are stuck. So, how do we solve that problem? Well, as I said, I will discuss this stuff about locks in this video, and then talk a bit more about recovery, and then come back and discuss this deadlock problem later, as on how to solve it. So, what I want to do in the rest of this video is discuss how to get more flexibility into our two-phase locking. For instance, how to get multiple transactions to read the same item at the same time. The principle here we're going to do is we're going to extend our notion of locking from the simple type of locking to more advanced types of locks. So, let's try to solve that part first about having different types of locks for reading and writing, because then we can sort of allow more to read at a time. So, we have a kind of lock called a shared lock or read lock, and you should request one of this if you're just going to read an item x. And we're going to write it in a transaction as is-dis-lock-affix. And you can get multiple of these shared or read locks in different transactions at the same time. On the other hand, we have an exclusive kind of lock called write locks, and you should request that if you're going to write on an item, but you can also use it to read the item if you want. And we're going to write them x-dis-lock-affix. And this kind of lock is only granted to one transaction at a time, similar to how the earlier lock was used. So, we have some additional rules. We have that the shared lock on x is granted only if no other transaction holds an exclusive lock on x, and an exclusive lock on x is only granted if no other transaction holds a lock of any kind on x. So, you can only have an exclusive lock on an item if no one else has a lock on that item, basically like it worked before. Shared locks are more general, if you can give it to more people. So, as always before, when we want to make an example of this kind of schedules, we need some notation for it. So, the notation for shared and exclusive locks look like this. We use SL subscript i of x for transaction i wanting a shared lock on item x, and we use XL subscript i of x for the same thing with an exclusive lock. And on locks are still handled using U subscript i of x, and now it releases all the locks we have on item x, and not just one time with our arm. So, let me come up with an example of it. Here we have transaction one is first going to request our shared lock on x, then read item x, then unlock on x. transaction two is getting a shared lock on x, reading item x, getting an exclusive lock on x, writing item x, and unlocking x. And what's going on is that we first get the shared lock on item x until transaction one in the schedule, then we are reading item x in the schedule one, then we're doing the same thing in schedule two. And at that point, the only thing we can do is move forward into transaction one. We cannot move forward into transaction two, because the next requirement in transaction two is an exclusive lock, which cannot be granted, because transaction one already has a shared lock on it. But we can still unlock in transaction one, and we can then finish transaction two by getting the exclusive lock on x, writing to x, and then releasing the locks. So, here I want to highlight that in this principle, you can hold both a shared lock and an exclusive lock on the same item at the same time. There's no problem with it. If you go back and look at the requirement, it fits with the requirement, and that's why we're allowed to do that kind of stuff. So, what we just saw is what we call basically upgrading a lock. So, we have a shared lock, and later on we are requesting an exclusive lock on the same item in one transaction. This, in some sense, is a quite friendly way of doing it, because first you might not need to write to item x, you're only doing that later. So, to be nice to other transactions, you're first requesting the shared lock and then the exclusive lock later, even though you sort of only needed to request the exclusive lock, and it could do everything. However, if you do this, you might want to enter more deadlocks, and we get a new deadlock here we haven't seen before. So, the deadlock can occur in these two transactions here, if you have these two transactions here, which are the same transaction, really just copy it twice. So, a transaction first gets a shared lock, then reads an item, then exclusive lock writes to this item, and then unlocks everything. And this can lead to a new deadlock. Let's see. So, say we first did the first two operations in transaction one, then did the first two operations in transaction two, and what can we do next? Well, we cannot do anything, because both of them want the exclusive lock on x. I should mention that this is a new kind of deadlock, because before we had deadlocks with two items, and now we had a deadlock with only one item, but because of the shared and exclusive locks. So, this is a new type of deadlock, and, well, it doesn't seem like a nice property, really. So, can we do anything to fix that? Well, let's see. So, let's see how to fix this specific kind of deadlocks, as in the one we get on the same item, if we have shared and exclusive locks. The way we do it is by stopping people from upgrading shared locks. So, we have a new kind of lock, an update lock, which is, you can upgrade later, but you are not allowed to upgrade the shared lock anymore. So, you can request an update lock if you want to read, but not write yet. The idea is that you request them if you think you're going to read right now, but maybe in the future you're going to write. And we're going to write it like this. U-log(x) or UL_i(x). The first one is for intersections, the second one is for schedules, and the second one means that the transaction i wants to update the lock on item x. And this kind of lock, as I said, they can be upgraded later to an exclusive lock, but shared lock can no longer be done, can no longer be upgraded to an exclusive lock. And this kind of update locks can at most be granted to one transaction at a time to ensure we don't run into this problem anymore. So, we have a bit more complicated upgrading policy, or granting policy here. So, this matrix here should tell you when you can get a shared or exclusive and update lock in all cases. So, the way you should read it is, if you want to request the type of lock, you find the corresponding column, and then you check that no, other transaction has a type of lock, it says no. So, for instance, if I want a shared lock, I can get it. If others have shared lock, but not if anyone else has an update lock or an exclusive lock. Similarly, for an upgrade lock, it's precisely the same, and you can get it if no one else has an update lock or an exclusive lock, but it's okay if they have shared locks. Exclusive locks, like before, they can only be granted if no one else has any lock on this item. Now, and this, I think, confuses quite a few people, until you think a bit about why it's done, this matrix is not symmetric. Specifically, it's not saying yes to allow you to get shared locks if someone else has an update lock. The reason why it's not symmetric in that sense is that otherwise people will request an upgrade lock if people keep one, because in shared lock, they will never be granted an update lock. So, if you're waiting to update your lock from an update lock to exclusive lock, you will be able to do it at some point, because at some point people are running out of getting their shared locks on this item. So, this is why that matrix is not symmetric. So, let's go back and see what happens in the example from before, and see if we cannot get that kind of deadlock anymore. The specific kind of one on the same kind of item. So, we have the example from before. Now, here you need to notice that we want to upgrade the lock from the shared lock kind of thing to an exclusive lock later on. So, therefore, we cannot do this anymore. Shared locks are no longer allowed to be operated. We must have an update lock. So, we replace the shared lock in line one in the two transactions by an update lock. Fine. Can we now get this deadlock we saw earlier? No, we cannot get that kind of deadlock, because if we start on transaction one, get the update lock, get the read item x, and try to start transaction two. Well, we cannot start transaction two at this point, because transaction two is asking for an update lock, which can only be granted to one transaction at a time, and transaction one already has that one. So, we cannot be granted to transaction two right now. Therefore, we continue on transaction one. So, therefore, we finish transaction one, and do like this, and then we do transaction two, and everything is fine. This is our serial schedule. Everything went fine here. And again, we didn't get any deadlocks, because of this use of update locks. But again, as I said earlier, it's important to notice that it's only this kind of lock, deadlocks, that are avoided by these update locks. The earlier, the first one we saw will still happen, even with update locks, because they already happened with basic kind of locks, and if we just replace the basic lock uses by exclusive lock, we will get the same problem. So, in some sense, what we do, so what a kind of negative example, we have basically turned the schedule into a serial schedule, and of course, that's fine. But it's not really an interesting kind of schedule, so let's look at a more advanced case, where we get a more advanced pattern of interaction between its schedules. So, we have three schedules here. Schedule transaction one, and transaction three is the same transaction. It starts by having a shared logon X, then read item X, then unlock item X, and transaction two is then more advanced. It gets an update logon X, it reads item X, gets an exclusive logon X, write item X, and then unlock X. So, let's see what we can do here. First, we might get a shared logon X, enter transaction one, then read item X, and then we might start transaction two, and we are allowed to do that, because you can get an update logon item, even if another transaction has a shared log on that item. You could see that on from the last slide, defining how to grant this kind of logs. So, now we're at the point where both, we finished with line two in both transaction one and transaction two, and we try to move on to line three, or line one of transaction three. Now, we cannot go to the next line of transaction two, because you are not allowed to give a exclusive log while someone else has a shared log. That was one of the requirements. And we cannot move to line one of transaction three, and this is this nine symmetric part. So, if someone has an exclusive log, you cannot get a shared log. This is because we want transaction two, basically, to be able to finish at some point, even if you had many copies of transaction three. So, we're not allowing transaction three to start here. Therefore, we can only finish transaction one, and then we can finish transaction two. And then now, after we've finished transaction two, we have unlocked everything, and therefore transaction three can be wrong. And this is sort of one of the many ways you can get a schedule for this three transactions. And yeah, as you can see here, we have a bit more advanced pattern of interaction between the different schedules, uh, transactions, sorry. So, it's not really enough just to define a new kind of log. We also need to talk about how we get that to work with two-phase logging. I mean, we need two-phase logging to get conflict stabilizability. So, how can we get this shared exclusive logs to interface with that? Well, it's kind of straightforward. You just have all log operations, like shared, exclusive, or update logs, before everyone logs. So, it's basically the same rules as before, except we have some more types of logs, and that's the only thing. So, again, it looks like this. You're allowed to request logs in the first phase, and possibly do some read-write operations. In the second phase, you're only allowed to do run logs and read and write operations. And that will give you a two-phase, uh, phase-locking scheme, and it will still guarantee conflict stabilizability using the precisely the same argument as before. The only difference is that instead of writing, um, uh, precisely which kind of logs we're using, but it doesn't matter for the argument. It only matters how the pattern looks like of the syntax, and that's not that we log an item before we can use it, and we unlock it before we can log it somewhere else. So, yeah, that's sort of the only thing. Um, yeah, so, so it's kind of straightforward to get two-phase logging still, and still straightforward to get conflict stabilizability. So, let me discuss another problem we can have with logs, uh, which is about how precise the logs are, or how kernel-like they are. So, a database management system could log, uh, put logs at different levels. In one extreme, we might have logs on, um, tables or relations. We might have logs on tuples on another extreme, and in between the two extremes, we might have logs on something called a disk block, and each disk block is made up of multiple tuples, and each relation is made up of multiple disk blocks. So, it's somewhere in between the two things. Um, let's see some example queries, uh, two example queries showing the extremes. You might make a query like "select name from student where student ID is 123456". That will be fine if you just have a log on that exact tuple. Another extreme would be we select a read salary from employee, and here we need the shared log on the entire table to do this operation. So, there's no real problem with it. The problem comes up when we look at the kind of trade-off we can do here. If we have a log in at two cores, kernel-like, as in, um, two high level, um, well, we don't spend much time on doing the logs and unlocks, because typically you will only do a few logs for doing one operation, as in, say you took a core product of, of employees and salaries or whatever, then you just need two logs. That's, that's simple. Um, but it does mean that, that, that we get less concurrency than we get if we had been more precise about it. So, it makes it slower in that sense. So, in some sense it makes it faster, because you don't need two maximum logs. On the other hand, it makes it slower, because you don't get so much concurrency, and as we have seen earlier, more concurrency means more speed also. So, that's not too great. Let's look at the other extreme. Well, if you have two fine, as in, two low level, like say we did it on, on each table, um, then we need a lot of time to update the logs, and we need a lot of space to, to store all these logs. Uh, and we, but on the other hand, we have a very high degree of concurrency, because we only log precisely what we need to log. But, but again, we have a lot of trade-offs here, and, and, and both extremes are kind of bad. No matter which level is kind of bad in many ways. Um, so we also need sort of, we cannot also just, just allow all kinds of log at the same time, because we'll say a transaction won't have a shared log for a table, and another transaction won't have an exclusive log for the entire table. We shouldn't allow the second one to do the exclusive log on the entire table, um, at the same time as, as you're holding a shared log on an item, because, well, then you can update the row containing this, this one table that the other transaction cared about, um, and that's not good. So, we want sort of to have, we have a lot of issues here. We have, we cannot just include all these levels at once. We cannot, um, and, and including just one level is a sort of bad. So, we like to do it in a bit smarter way. The way we do it is using something called intention logs or warning logs. So, here I'm not only going to talk about shared and exclusive logs, and well, you can insert update logs kind of similarly. I didn't really want to do it here, just to make it a bit simpler. So, we get two kinds of logs, two new kinds of logs, IES kind of log and IEX kind of log. IES is intention to request a shared log on a sub-item, and IEX is intention to request an exclusive log on a sub-item. So, the rules are as follows. Say we have this levels here from before. We have relation level, the block level, and the tuple level, and say I want a shared log on a tuple. So, whenever I do that, I must first put an intention log on each of the super items of the same type. Here I talk about shared log. So, for that I need a shared intention log, this IES, and that means I need an IES log on this block one, because tuple one is a sub-item of this block, and to get this IES on that block, I need an IES on an entire relation. So, notice that I first get the IES for the entire relation, then the IES for a specific block, and then a shared log on a specific tuple in that specific block. So, this is sort of the pyramid of things you can do. There are similarly for exclusive logs. There we have IEX instead. So, if I want an exclusive log on some block, for instance, then I first need to request an IEX log on the entire relation. So, this is sort of the pattern we're doing in these intention logs. So, let's look at the policy for quantizing logs, and this is why I didn't include the update logs. It will look big enough, this policy already, with only this four kinds of logs. That's a shared log, exclusive logs, IES, and IEX logs. Yeah, as if we had, yeah, here we had four, but if you had update logs also, it will be six of these times, and I will have 36 entries instead of the 16 entries, which is already a bit large number. So, again, like before, if you would like to have a specific kind of log, you find a corresponding column, and then you check that no one else has a type of log, where it says no in that column. So, for instance, if you like a shared log, then you can get it. If everybody else only has a shared log on that item, or intended to share a log on that item, you cannot get a shared log on an item if someone else has an exclusive log on it. Makes sense, as it was before. Or, if they have an intention to exclusive log a sub-item on that item. So, for instance, you cannot have a shared log on a table if someone else wants to log a table in it. It makes sense, also. Similarly, as always before, if you want an exclusive log, you can only get it if no one else has any kind of log on that kind of item you're looking at. And IES and IEX are also fairly natural, I feel, except that if you have an IES log on something, you are allowed to have any kind of other intention logs on it. So, intention logs doesn't prevent any kind of things from other intention logs. So, if you're an IES on something, you can have an IEX on it, also. You can have two IEX on an item, and so on. There's no real requirements for I with I logs. It makes sense if you think about it, but you might want to think about it for a bit. So, in this video, I've discussed what a deadlock is, where a schedule ends up getting stuck, because multiple transactions want to have a log on an item that some other transaction is wanting to have a log on at the same time. So, if you cannot handle this kind of multiple people are waiting for each other kind of situation. We want to discuss shared, exclusive, and updated logs, but you need a shared or updated log to read, but you need an exclusive log to write. Again, there is a lot of more details about it. You probably should watch it or look at the slides to figure out what's going on. Finally, I discussed these intention logs to allow you to handle different levels of position in logging. You can either maybe in general log at a level of tuples or relations, and these intention logs are then allowing you to handle both kinds of logs at the same time.
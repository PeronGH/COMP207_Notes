In this video, I will discuss a new type of schedules, so-called conflict serializable schedules. It's how database management systems recognize serializable schedules. They're just recognizing the subset of serializable schedules called conflict serialization. So, as I said in the last video, serializable schedules are too complex, and therefore we try to do something a bit simpler with these conflict serializable schedules. So, basically we're trying to answer how much concurrency can we allow, while ensuring isolation and consistency, and being able to check it fast. So, I'm not doing the check part in this video, that will come in the next video, but I will show you the basics of what kind of schedules we are talking about. So, I will talk about this conflict serializability, which as I said is a stronger notion than serializability is, and it's what is used by most commercial systems. And by the way, this was what I meant by SQL serializability in isolation level 4, if you go back and watch that video on the defining agent. This is because this is what is used by the commercial systems, therefore they're not really supporting serializability, they're supporting this conflict serializability. So, conflict serializability is not too surprisingly based on a notion of conflict. A conflict is if you have two operations in different transactions, so that if you swap them, you end up having a different behavior in at least one of the two transactions. So, let's look at an example here. We have the stream of operations, read 1x, write 1x, read 2x, write 2x, read 1y, and write 1y. I have omitted the commit and abort here. It's not really relevant when you just talk about conflict serializability. We'll get back to it later, towards the end of this part. As in, towards the end of after we discussed both recovery and this concurrency part here. Now, an example of a conflict will be these two operations here, this write 1x and read 2x. This is because transaction 2 is reading whatever transaction 1 was writing here. If we swap the two, then transaction 2 would not be reading what transaction 1 wrote anymore. And that's why this is a conflict. Of course, you can also see that if it had been the other way around, as in if it had been read 1x and write 2x, and then we swap them again, that would not have been a conflict. Because then after the swap, transaction 1 would be reading transaction 2. Now, from that we can see that operations can only be in conflict if one of them is the write operation and to access the same item. So, let me go through the rules for conflicts in a bit more easily understandable form than this big definition of it. So, let's look at how to characterize these conflicts. The characterization is basically just the same thing as I said on the last slide. We have a conflict in a pair of operations. If they are from different transactions, they access the same item, and at least one of the two operations is a write operation. If both of them is writes, it's still a conflict. But if both of them are read operations, it's not a conflict, because if you swap them, it doesn't change behavior, because, well, they are reading the same thing anyway. So, for instance, from the previous slide, we had this example here. So, maybe spend a few minutes here, see if you can find anyone else. And just as a hint, there are two more conflicts in this schedule, and see if you can find them. So, now we know what conflict is, but that was not what we wanted to know. We wanted to know what conflict serializability meant, and to do that, I need to define a notion of when two things are conflict equivalent, as an equal under conflicts. So, we are saying a schedule S is conflict equivalent to another schedule S'. If you can get from S to S' by doing some swaps, such that each swap satisfies these three conditions. They swap consecutive operations, meaning one just after the other. They are not conflicting, or non-conflicting operations. So, that means that there is not a conflict between the two operations, and the two operations are from different transactions. So, let's see if we can see an example here. Let's start with this S here on the top, and see if we can get to this S' on the bottom. So, first I would like to swap these two. Are we allowed to do so? Well, they are definitely consecutive operations, because they come just after each other. They are not conflicting, because they both read operations, and to have a conflict, you need at least one of them to be a write operation. And a different subscript, and therefore are from different transactions. So, we are allowed to make this swap. Next, we can swap these two operations here, the next two. Again, we see they are consecutive. They come just after each other. They are not conflicting, because they are accessing different elements, and therefore they cannot be conflicting. And they are from different transactions, and therefore we are good to go. Next, we are going to swap these two here. Again, they are not conflicting, because they are on different elements. They are consecutive, because they are just after each other, and they are from different transactions. So, everything is good here. Finally, we are swapping these two elements here. Again, this is fine. They are consecutive. They are not conflicting, because they are accessing different items, and they are from different transactions, because they are different subscripts. So, now we have seen how to get from the top one to the bottom one, using a number of swaps. And therefore, S is conflict equivalent to S prime. And our schedule is then conflict serializable, if it's conflict equivalent to a serial schedule. So, we see that this one down here is serial, and therefore that means that the original one, S, is conflict serializable. So, this is a notion of conflict serializability. I will not show you in this video how to recognize it. I will show that in the next video. But it's actually quite straightforward. It's in some sense easier to understand than this definition. Well, at least to some degree. It's faster, at least, than trying to apply the definition to see if two things, to see if the original one is serial, uh, conflict serializable. So, we'll see a smarter way of doing it in the next video. But in this video, we're just going to use the definition of it, and see a few more examples. So, let's see another example here. So, we're going to show that this schedule, is it conflict serializable or not? Well, let's try to do that. Let's see another example of conflict serializable schedules. So, let's try to find out if this one is conflict serializable. Well, one thing you would try to do is stop the video now, spend a bit of time to see if you can see it, and then get back to the video. I will give you five seconds to stop. So, now I assume you have tested if it's conflict serializable or not, and hopefully you found out it was conflict serializable. Let's see. So, we can make this swap here. Why can we do it? Well, the two is from different transactions. They are consecutive, and they're not conflicting, because they access different items. So, we can make that swap. We can make this swap here again. They are consecutive, they're not conflicting, because they are on different items, and they are on different transactions, because we have different subscripts. So, we're allowed to make this swap. We can also make this swap over here, because again, they are on different items, and therefore they're not conflicting. They are consecutive, just after each other, so that's fine. And they are on different transactions, so they're satisfying these three properties we wanted to make a swap. And then we swap these two operations, and again, it's on different items, and therefore we're allowed to make this swap. And in the end, we end up with this schedule down here, and we see that this is a serial schedule, therefore the arbitrary one is conflict serializable. And as I said, this is sort of how you do it from the definitions, and in the next video, we'll see a simple way to test if our schedule is conflict serializable. And that's basically the way it's done, if you want to do it. In the LRT, the database management systems are using another way of doing it, by basically just only making schedules that satisfy this property. We'll get back to that in a bit. So, let's try another example. This one, let's see, is that conflict serializable? And again, I will give you five seconds to stop this video, try for a bit, see if it's conflict serializable, and then I will tell you the answer. Okay, so the answer is no, it's not conflict serializable. It's because basically of these three operations here. So, these form a conflict, and these form the conflict. And if you think about it, and I'm not going to make it that precise yet, I'll come back to it in the next video, this causes an issue, as in you cannot move the middle one after the last one, or before the first one, no matter how many steps you use. And this will mean that you cannot have either two firsts or one first in a serial schedule that has this conflict here. So, so far we have seen, well, four different kinds of schedules. So, let's sort of try to show you how they look like in regards to inclusion and stuff like that. So, we have seen serial schedules, we have seen conflict serializable schedules, we have seen serializable schedules, and we have seen this general concurrent schedules. So, each of these areas are in general non-empty, that is, the inclusions are strict. So, that means that, for instance, that our schedule schedule are conflict serializable, but not serial. We just saw one example, for instance. So, we have the serial schedule in here, and then we have the conflict serializable schedule, and again, this area is not empty. We have this area of serializable schedules, and again, this is not empty. I haven't shown that part though yet, as in that there are schedules which are conflict serializable, but not, oh, sorry, I haven't shown that there are schedules which are serializable, but not conflict serializable. I will show that next, but I have shown all the other inclusions so far. So, this is an example of a schedule which is not conflict serializable, but it is serializable. What is it doing? Well, it's write 2x, write 1x, write 1y, write 2y, and write 3x. So, why is it serializable? Well, it's because the outcome depends only on, there's only two things here. We are writing down, really, and then we are writing down something in y, we are writing down something in x, and x has been written to by transaction 3, and y has been written to by transaction 2, and they never read anything. So, they're not going to change any behavior, no matter how we swap things around. That means that we can swap transaction 2 to be at the end, no, transaction 3 to be at the end, transaction 2 to be second to last, and transaction 1 to be first. And that will not cause any problems for serializability, because no one reads anything ever. Yeah, as I said, this schedule here is equivalent to the schedule here, in regards to what it outputs. And this is a serial schedule, and therefore the first one is serializable. So, it's not conflict serializable, though, and to show that, you ourselves need to take this definition, do a million billion swaps, and then see, well, none of the swaps help you. That will take far too long, so instead of doing that, I will in the next video show you how to check if this is serializ- conflict serializable quite easily. So, as I said, I will show you how to see if a schedule is conflict serializable, and of course, because you can see if something is something, you can also see if it's not something, by just seeing if it answers no. So, as a summary of this video, we want a schedule that allows as much concurrency as possible, while following isolation and consistency. And as we saw in the last video, the best we can do is a serializable schedule. However, we couldn't find them. As I also mentioned in the last video, we even recognized them. I didn't show that, but I keep on claiming it, and I will also do it right now. Therefore, the database management system is doing something else. They're doing this conflict serializable schedules instead, and conflicts are these kind of things. There, you have a pair of operations from different transactions that cannot be swapped without changing the behavior of at least one of the transactions, and there was a short definition of it with three properties earlier in this video. And a schedule is conflict serializable if you can in some way repeatedly swap consecutive pairs of non-conflicting operations and get a serial schedule, and the operations are from different transactions.
In this video, I will discuss something called undo locking and how we can use Z to ensure especially atomicity in our database. Then in the next one, I will cover other kinds of locking to ensure durability also. So in this video, I will describe the simple kind of lock you need to be able to handle undos like you know control Z, control Z, control Z and so on. And this will allow us to do atomicity in databases because as you saw earlier, it's about undoing things if a failure happens. So the idea of this locking in databases is to write down the important events that happens. So what's important? Well, it's things like the startup transactions, it's when transactions are over or when they are bought, and it's about modification of database items. So basically, whenever a write happens, we need to do some logging about it. And the important part here is we want it to work even if the system fails. But we assume, as I said in the last video, that we have the hard disk still, that the hard disk didn't fail, or we have a back out of the hard disk somewhere else. So we have whatever we wrote to the hard disk, but whatever might be in RAM might have been gone from now. So we'll see three techniques for it, one in this video and the other two in the next video, because well, they're all quite similar. So I'll mainly focus on one here and then go over a bit the other ones in the next video. So in this video, I will talk about undo logging. As I said, it's for maintaining atomicity, because undo, well, you needed to undo things whenever you had a failure for atomicity. For doability, we need to be able to redo things. If you had managed to delete something, that shouldn't have been deleted, because of media failures here, whatever. Again, that's what redo is for. And we can also do a combination of the two, and it will be quite obvious how to do that when we have done both undo logging and redo logging. And we'll also see techniques that we can actually do both atomicity and doability using just one of these techniques, and how to do doability even using undo logging, how to do atomicity even doing redo logging, and we don't really need to do more when we get to undo/redo. So to do this, we need to extend our syntax some more. As you have seen so far, we do extension of the syntax quite often. We extended it like four or five times already, for instance, for this log stuff in the last videos, and now we're going to do it again by talking more specifically about when things get put out to the hardest and stuff. So we have this set up like earlier. Now we have added in the log manager also on the side. As before, we only had the left part of it not including the log manager. Now we also have the log manager that should write down this log. And whenever we do a read, we send things out from the hardest into the buffer, and from the buffer into the transaction. If it was already in the buffer, we don't need to send it from the hard disk. So whenever we do a write, and this is the new change we're going to do in our system here, writes are only going to write from the transactions into the buffer. So only this part of the updates, of the writes, are done now by the write command. Earlier, part of it was also putting it out on a hard disk at some data point. Didn't need to do it immediately before, and this imposition about when we do things were at least part of why we are now extending the syntax here. So we have another command, which is about output x, and what it does is copy the database item x from the buffer to the database. So on an output, you take it from the buffer and put it into the database. So basically, what was before write is now write followed by an output. So what do we do with this log thingy? Let's look at it. We have a command for that also. It's about taking the log file from the buffer and putting it out to a file in the hard disk. So basically, we store the log file in a buffer, and whenever we write flustlog, we take it from there and put it into the hard disk. Yeah, so we just take whatever is in the current buffer, put it out to the hard disk like this. Now I want to point out something important, at least very important. You shouldn't always expect that whatever updates you have made to the log is currently in the log file in the buffer. It might already have been moved previously out to the hard disk because of other transactions having to run flustlogs, or for other reasons. So you should write the log file such that even if it gets written out instantly after you write it, then everything should be fine. So what do we do in this ondo logging? Well, it's quite simple. It's, I think, reasonably obvious if you think about what you need to be able to do to undo things. So what we write is, we write whenever we start a transaction, we write whenever we commit a transaction or board a transaction, and we write what the old value of the item was before we made a change to it. So if you have a transaction T that wrote to an item X, and the value before we wrote to it was V, then we write T comma X comma V. And this is the kind of thing we have in the log file as in start T, commit T, abort T, or this T comma X comma V. So one thing here though, if this entry as in this T, X, V, it is not necessarily true that we have updated the hard disk yet. It just means that we intended to update the hard disk, and we will probably, or we should probably undo this. Later video, I'm also going to show you how to do the redo and undo logging, but it's going to use similar kind of setup, but slightly different. So to do this ondo logging, we need to follow two principles to get all the properties we want for it, specifically so we can do both atomicity and durability using it. We will next video see how precisely this functions, and so on. But let me give you the principles here. If a transaction T updates an item X, then we must have written this change in the value log as in this T comma X comma V to the log file on the disk before we output X to disk. So basically, before writing output X, you must have ensured that T comma X comma V has been written on the, in the log file on the disk. And similarly, you must first write commit T in the log file on the disk after having written all the output X stuff, output Y and so on, done by the transaction. So first you have output X, then you might have output Y and some other outputs, and when you turn all the outputs as made by the procedure, then you should write commit T in the log file, but first afterwards. And again, you should write it on the log file on the disk. So let's see what kind of commands we need to do in the transaction to get this to work. So basically, it looks something like this. You do some operations, and then when you want to finish up your first fluster log, then you output each of the items from the buffer to the hard disk, you have written in your transaction and in your fluster log again. And in between these fluster logs, you should have made sure to update the transaction correctly, or the log file correctly. So before writing this fluster log, you should have written all the log entries for bytes already in your log file, and then you should write all the updates to the disk, and then you should write the commit T command to the disk. So let me go through precisely what happens when. So let me try to describe a bit the setup here before showing you precisely what happens in undo logging, because we're going to be with the same setup when we get to redo logging and we get to undo/redo logging. So we have the rightmost column is for what is in the log file in the buffer right now, or what we write into the log file in the buffer right now. Then we have some columns for the database as in what is the value of each item in the database at a given point in time. Then we have what is the value of the entries in the buffer in this given point in time, and then the local variables version of the variables. And then we have the transaction, and then finally to the leftmost column is the different times we're doing things at. So let's say we start our transaction here at time 0. In the database we have x being 1 and y being 10, and we write in a log file because we're starting the transaction start t, for starting transaction t. Then the first thing we do we read x, and when we read things, as you saw, we're reading it, well, we're trying to read it from the buffer into the local storage, but if it's not in local storage, which was in this case, we're first getting it from the database and into the buffer, and then from the buffer into the local storage for this transaction. Then at this point we are going to double x, so now x in the local variable is 2, and x both in the buffer and in the database is both 1. And then we're going to write x, and this looks like this, so we two get put into the buffer, and we should remember to write in the log file that we have changed x from being 1 to being 2 in the buffer. So we should write t comma x comma 1 in the log file, in the buffer. Then we do similarly for y, we read the 10 from the database into the buffer, and from the buffer into the local version of the variable y, and then we multiply y by 2, so now y in the local one, and not neither in the buffer or in the database, but only the local one is changed to 20. And then we write y out again, as in here we're writing it from the local storage into the buffer. And now we should remember to write in our log file that we have changed the value of y from being 10, as it was before, to now being 20. The way we do it is write t comma y comma 10. And the next command is flush log. It doesn't really change the database, it just puts everything out to the hard disk of the log file, as in all the street logs we have. Afterwards we are going to output x, so now we move this 2 from the buffer into the hard disk. Then we're going to output y afterwards, so we're moving this 20 from the buffer into the hard disk, and at this point we are done committing. So we are writing commit t in the log file, and finally we are flushing the log file out to the hard disk again. So at time 7 we are putting the first three records out to the hard disk log file, and at time 11 we are putting the last entry, this commit t, out to the hard disk. And this is how undo log in should look. So what do we do if we have one of the system failures? I mean, now I've described how we make the log file, how do we then use this log file to safely undo failures. Basically what are we, what is this recovery manager doing? So we have some scenarios, I'm going to go through a few of them. We might have commit t, of course, in the log on the disk, and then we have the commit t, of course, in the log on the disk. In that case, well, it's kind of easy if you think about it what you should do. Well, everything has been done. There is nothing to undo, we are fine, we don't need to do anything. So if commit t is there, things are fine. Yeah, no recovery is needed in this case. Let's look at the next case. We do not see a commit t in the log file on the disk, so the error might have occurred somewhere here. So what should we do? Well, we should undo things, because when the request happened in the middle of a transaction, basically, or we don't know better than that, and as we discussed when I discussed atomicity, we should undo in this case. So we must undo all the updates to items that are written to disk. So basically what we do is we move up in this transaction, and for each time we see t x v, we replace the value of x on a disk by v. This, by the way, can lead into trouble if you do not satisfy a high enough level of isolation, but we will deal with isolation later. So what do you do if commit t didn't occur on disk, and you haven't gotten to this point yet, where we haven't gotten all of the log file out on the disk yet, then we might not be able to undo things. But do we need to do so? No. Why do we not need to do so? Well, because if we haven't gotten this log file, all of the log file out on the disk yet, well, we haven't done the output yet either, so we haven't actually done the changes yet, so it doesn't matter that we don't know everything we need to do to undo things. We know enough that the database is still fine. So let's see how we do the recovery with undo logs. If an error occurs, we need the recovery manner to restore the database to the last consistent state. This was what was required for atomicity, basically, and also, of course, consistency, really. So what we do is we start from the bottom of the undo log and move up. So if we see an entry of commit t, then we remember that t was committed successfully. If we see an abort t, we remember that t was aborted, and we see our t,x,v, and if t has not finished successfully, there are no commits and no aborts, then we change on this to v. So we just move up like this. And when we're done all of this, we write abort t for its uncommitted transaction t that was not previously aborted and call flush log. What it does then is, well, now we have basically aborted all the transactions that was not finished before our failure. So this is why we're doing it like this. So let me try to walk through what you need to use or write in an undo logging with multiple transactions. So say we have this set up here. We have the schedule, as you can see. Initially the database was containing x equal to one and y equal to two. And let's see what kind of things the undo logging should write in this logs and so on on this schedule. So specifically with log entry should be done, and with other operations must be executed and when. So it takes up a bit more space than before, and we have a few columns here. We have the log on the disk, we have the log on the buffer, we have the transaction two stuff, transaction one stuff, and the time when looking from write to lift. And initially the database contained x equal to one and y equal to two. We need it because otherwise we don't know what to write in the first few write commands. So the first thing we do is seemingly start transaction one. So we write start start t1 in the log in a buffer. And then as some data point we're going to do a write x and we write t1 comma x comma one, because whenever we do a write x we should write that we are having done this update in the buffer. And again notice that x before this change here was one, because that was what its original value was. And at this point we start transaction two, and some data point transaction two is going to update x, is going to change x from being two, which we can see it was done from transaction one to being two. And so we should write t2 comma x comma two in the log file in the buffer. And then we finish up with transaction one. It's going to write t to y. So y was before transaction one did the read operation, it was before it did the write operation it was two. So t1 comma y comma two is what we write in the log file in the buffer. And at this point we want to finish up transaction one. I think we will try to commit transaction one here. So first we do the first log. It takes the log file from the buffer, the entire log file, also including the stuff about transaction two, and write it out to the log file in the disk. Whenever you do first log you write the entire log file to the disk, even if it's about other transactions as well. You can basically always write every log entry to the disk, it's fine. There will not be any problems from that. And then after having done the first log, we allow to do the output x and output y. So we do that. That's going to transfer the value from the buffer into the hard disk. So we do that at this point. And then we can write commit t1 in the log file in the buffer. And finally we're going to first log it out. So we're going to take it from the buffer and put it out on the hard disk. And this is how the basically the commit overturn section works when you do undo logging. It's going to be a bit different when we do the other kinds of logging, because we want to have both atomicity and durability at once. So for transaction two we're doing the same kind of pattern. So first first log, well it doesn't do anything, because we have already flushed the entire buffer previously out to the disk in transaction one. Then we're going to output x. And then we're going to commit transaction two. Actually the output x is not doing anything either, because we haven't changed the value of the buffer since output x was last done. But still in principle we need to do it. In principle we needed to do the first log. And finally after having done this commit t2 in the log file, we should flush it out. So we pull it out in the log file on the disk. So this is precisely how undo logging works on this example. And again I want to stress here that you should write the entire log file out whenever you see a flush log, not just a part about your transaction. So what do we do if you have a summer portion? For some reason I mean we saw in the previous videos something about why we might have an abortion. What do we do then? Well we just use the undo log to undo all the changes made by the transaction, basically similar to recovery with underlogs. Here we just focus in on one transaction, although we don't need to make sure that all the other transactions are done properly. We are still running, so there's no need to look at other transactions. So let me be precise about it. Assume that the transaction that it supports is called t. So we start from the bottom of the log file, move up, and whenever we see a t x comma v, we change the value of item x on the disk back to v. This has some issues though if you think about isolation, but again if we assume that we have dealt with isolation and this will do later, things are fine here. But yeah, it will cause issues if isolation is not satisfied. And I will also mention it more explicitly in a bit, in a bit later video. So a summary of this video is that, well, we have seen how we can abort transactions. We just saw it, and we see what to do in case of system failures. We just need to keep track of what's going on carefully and then use this ondo log. And basically ondo log is primarily used to deal with atomicity. The exact way we did it here will also deal with durability. I will get into a bit more details about what I mean by that in the next video. So the key thing in ondo logging is that you log the old value before you did the update in a database and the recovery manager then uses that to restore the database to the last consistent database state. So that we can satisfy atomicity especially.
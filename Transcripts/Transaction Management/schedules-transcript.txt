This video introduces schedules, a low-level view of both schedules and transactions, and a bunch of notations for these things. So more precisely, I will talk about a simplified and low-level view of transactions, sort of talking about the read and write operations making up these transactions. I'm also going to talk about schedules and a whole bunch of notations for all of the things that will be used as we go through this part of the course. The best place to start this discussion on schedules and so on is to talk about this low-level perspective will be taken on the database and a bit more about the notations afterwards. So we have our running example, we have our employees table with employee ID, first name, last name, birthday, and salary, and we might do this to SQL statements. We might select salary from the employees table where the employee ID is 1234 and update the salary afterwards by setting the salary with 10 percent higher by update employees, set salary to salary times 1.1, where the employee ID is 1234. Now when we're going to look at it from a low level, we are going to produce this a number of low-level operations. We have read operations, it returns the salary from employee ID 1234. We're multiplying the salary by 1.1, and then we're going to write it out again afterwards out in the database where the employee ID is 1234. In practice, all of these three operations are really caused by the update one, but if you're going to think of the salary as being saved between the two, then this is the right way of it. So notice here we have a fairly low-level abstraction here. We are talking about what read and what write operations we're making, and it's just about what happens on this one primary key tuple. This one tuple will primary key 1234. We have two database operations. We have the read operations, and we have the write operation, and we have one non-database operation. This is multiplied salary by 1.1. So this is really still way too much information. We're going to get in here. So we have this read in the employee IDs 1234, salary multiplied by 1.1, and then write it out again. We don't need all that information, not from this point of view at least. So we're just going to write it like this instead. We're going to read something in. We're going to multiply it by 1.1. Actually, we're not even going to write this multiplied by 1.1. Most of the time we don't really care what we're doing to the variables we're writing in and out. We just care that we're reading them in and writing them out afterwards. Here, of course, the x is the employee IDs 1234 salary, but it's not really that important. So most of the time I'm just going to use this writing on the right-hand side instead of using the one on the left-hand side, because, well, it's too much information really. Let me try to be more precise about what I'm doing. So we have this read_ex operations. What it's doing is it's reading something into the program variable called x from the database item with the same name. I'm using the same name for both just because there's no real reason to have different names. So what you're doing is you're finding the address for this disk block that contains this program variable. Disk blocks or pages are like this, because you don't just have single bits or bytes on your hard disk. You have bigger quantities, because the hard disk is slow, so you're reading a bunch of things from your hard disk into your RAM at the same time. Some of it is what you walk after, and some of it is just irrelevant really. But the point is here that you're reading a bunch of things, and you might already have written in whatever you are looking for. So you might be able to just find it in the buffer after you know which page you're looking for. If the block is not there, already you go and get it from the hard disk, but if it's already in main memory, you're already good to go. At that point, you just copy the program variable you're after from the buffer into the program variable. So the buffer is the RAM on your computer here. Similarly, we have a write operation. It's roughly similar. It takes whatever you have in your program variable and writes it out to the hard disk, out into the database item with the same name. So what you're doing is you're finding the address for this disk block again, containing the variable x. It's the same as in read, and then you're going to copy it into the buffer in main memory, if it's not already there. And then you're copying in from the program variable into the buffer, and then you're moving the block from main memory into the hard disk on your physical hard disk. And you might do that either immediately or some data point in time. Later on, we'll be more explicit about this times and what we're doing, and we might even sort of split the operations into multiple operations to be more precise about them. But it's not necessary for this first part of this, well, the first half of this part on schedules, on transactions. So with that, let's go back and look at the transactions. So they have five kinds of things. They have a begin statement, they have an end statement, and between those two things, we have things like read operations, which is where we're going to get things in from the database. We have write operations, where we're going to move things out and then get a database. The read, for instance, coming from the select statements. But it can also be when we update relative chains in, for instance, the salary here, where we first read the salary in, and then we read it out again immediately. Again, that's the write operation. And we also have a bunch of other non-database operations involved in our transactions. And most of the time, I'm going to ignore those non-database operations, but still, they are there in the transactions. And typically, just for simplicity, we're going to omit the begin and end operations, if it's clear where they are. I mean, we begin at the beginning, we end at the end. There's no real reason to say that. So now we get to the schedule. Schedules are basically, well, the same way a transaction consists of multiple queries, a schedule consists of multiple transactions. Here, though, we don't have an order on them, and the schedule's job is then to execute this transaction in some way, or more precisely, execute the operations making up the transaction in some way. The only thing we must ensure that we preserve is that for each fixed transaction, we're doing that one in the right order. So if a transaction starts by reading something, then writing something out, we must first read this in, and then write it out afterwards to have a schedule. We have two basic kinds of schedules. We have a serial schedule, where we first do everything to do with one transaction, then the next transaction, then the next transaction, and so on. And we have a more general concurrent schedule, where we might do one operation from one transaction, then one operation from another transaction, then one more operation from the first transaction, then operation from the first transaction, and so on. The only thing this concurrent scheduler must satisfy is that if you first do one operation, then another operation in a transaction, then you must ensure that you're doing them in the right order. So as I said, if the transaction started by read and then write, you must first do the read and then do the write afterwards. So I want to commit some notation for the schedule, so it can be more precise about what we're doing here. It's also making it much more easy to talk about concurrent schedules. So let's talk about a serial schedule first, and then use notation from the serial schedules to present concurrent schedules a bit better. So as I said, a serial schedule does everything in one transaction first, then everything in the next transaction, next, and so on, and so forth. So let's say we have a serial scheduler over two transactions, transaction T1 and transaction T2. And the two schedules might look like this. We read in, we add 100 to this thing we wrote in, we write it out again, we read something else in, we add 50, we write it out, and then we have done, we commit. Another transaction might read something in, read something else in, add them together, and write it out, and then commit. So this gives rise to this shorthand notation for schedules. We're going to use it to introduce concurrent schedules a bit better, because they're hard to follow without this shorthand notation for it. So the shorthand notation works like this. First, you have a symbol denoting which schedule you're talking about. It's a capital S with a subscript of which server ID you have for the schedule. So we're going to use letters for them, so not to confuse them with the transactions where we're using numbers as the ID. So here the first one has the ID of A, so it's scheduler A. And then we have a colon, and then we have a bunch of read operations, write operations, commit statements, and abort statements. Most of the time we don't use aborts, but in general we have them also as a symbol. So, for instance, the read operations in a transaction I on item X is written R subscript I on X. Similarly, a write operations in a transaction I on item X is written double v subscript I of X. And commit of transaction I is written CI with the I as a subscript again, and abort is written AI again with the I as a subscript. So in general, all of the subrations has the subscript of where the error transactions came from, and if it's written write operations, they are of the function of whatever item we are doing it on. So let me come with another example so you get a bit more feeling for what this kind of notation is doing. Here we have one transaction reading in X, subtracting 10 from X, writing out X, committing it. In another transaction we are reading in X, multiplying X by 10, writing out X, and committing it again. And this is done in a schedule, all of the sub-ations in the order I mentioned. So this is a serial schedule. So what is the shorthand for this? Well, so what is the shorthand? Well, it's S underscore B, because this is schedule B, then a colon, then the first operation we're doing in the schedule is read X in, in, over in transaction one. So it's R subscript one of X, and then we do a non-dentative base operation. It's not written down in the shorthand. Next one is a write operation in transaction one that's writing X out, so writing W subscript one of X, and then we're committing transaction one with C1 in the shorthand notation. Then we are going to, going to the transaction two, where the first one is a read operation of X, so we are writing that as R2X in the shorthand notation. Then we have a non-dentative base operation, again not included in the shorthand notation for the schedule. The next operation after the non-dentative base operation is writing X out again. We're doing that with write W2X, because it's in transaction two, and finally we're committing transaction two with C2. So I want to highlight here that the order can matter for what outcome you have of transactions or schedules. So if you start with one and subtract 10, and then do a one and multiply by 10, it's different from if we start by multiplying by 10 and then subtract 10. It's kind of clear, right? I mean, say we start here with 100 for the value of the variable, then we subtract 10, we get 90, multiply by 10 afterwards, get 900. It's different from starting with 100, multiplying, getting 1000, and subtracting 10, getting 990. Well, 900 and 990 are not the same number, therefore we have a different outcome. And therefore we can see that the order matters even for transactions in several schedules. So now I want to present a bit better this concurrent schedule. So we have seen several schedules now, where we're doing transactions, everything in one transaction first, and everything in the next transaction afterwards. We might, on transaction T1 and T2 over here, might have the serial schedules, where it refers to T1, and then do T2 afterwards. We can also have the other serial scheduler refers to T2, and then do T1 afterwards. Again, this is the serial schedules, and as we just saw, we saw these two choices we had picked can matter for what outcome we get in our database. So we have the more general concurrent scheduler, and they are strictly more general. Every serial scheduler is also a concurrent scheduler, at least if you talk formally speaking, but typically you will probably think of concurrent as being the ones that are not serial. So let me try to come with some examples of serial schedulers, or concurrent schedulers, which are not serial. So for instance, we might do this one here. Here we have first two operations from transaction one, then an operation from transaction T2, then two more from T1, and then committing T1, and then the rest of T2. And as you can see, this is another way of doing this schedule that just requires us to do all the operations while preserving that each individual transactions is done in the right order. We can also do it like this. Here we have sort of interleaved every second. We have first T1 operation, then operation from T2, then operation from T1, and so on. And again, this is a nice concurrent schedule. As an example of something which is not a schedule, concurrent otherwise, this will be an example. Here we are first reading in 1x in transaction one, then we are writing reading in y in transaction T2, and this is what makes it another schedule, because the first operation in T2 should be a read x and not this read y. So yeah, you need to ensure that that the schedule has the same order as the underlying transactions. So in summary, we want to focus on low-level details, the reads and the writes, and the interactions. Instead of talking about this higher level, we're talking about earlier about the queries, when we talk about transactions. So transaction versus sequence of queries, and we also have schedulers, which is a set of transactions that should be executed, so that each operation in each individual transactions come in a wide order. We have a notation for this kind of schedulers. We have, uh, we start with a symbol for the schedule, which this capital is, with some subscript, and then a colon, and then the operations making up a schedule are read and write operations from the schedule, from the transactions, and some commit statements, and some abort statements, maybe. So the read operation for reading in x in transaction i is R under subscript i of x. Similarly for the write operation in transaction i, it's w subscript i of x. Commit of transaction i is C underscore C subscript i, and abort is A subscript i. Abort is also this rollback operation that we have seen before.
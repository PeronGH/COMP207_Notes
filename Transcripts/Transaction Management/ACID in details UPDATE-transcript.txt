In this video I will discuss acid in more details as in it's not a drug or it's not the kind of liquid you can get on yourself. I'm talking about the four database properties, specifically atomicity, consistency, isolation and durability. So here we will give a precise definition of what each of them are and show you some examples and stuff like that. Basically the same examples as from before. So the A in acid is for atomicity. It's saying that a transaction is an atomic unit of processing, meaning that either you do everything or you do nothing. And it deals with things like failure. So if you have an abort, for instance, because a user pressed a cancel button or because there was a deadlock from the system side or the transaction could abort itself because you come into some unexpected database state, you broke some constraint or whatever. Or you might have a system quest, your computer failed, the network failed, stuff like this can also happen to cause an abort. And at that point atomicity comes in and says you either need to do everything or nothing. Nothing in between. You cannot do part of it. You must do everything or nothing. There are basically two kinds of outcomes for atomicity. Either an error occurred that prevented full execution, for instance, one of the ones I mentioned just before, or we committed everything and there was no error. In the first case, we have to undo everything and the system should recreate the database as it was before we started this transaction. In the other case, if everything went well, well, everything went well and we don't need to do anymore. So early on, we saw this part-till execution problem where an error occurred in the middle of our transaction as in between. We were taking money into an account and subtracting it from another account. A failure could have occurred and if we just let it be like this, that would be unacceptable for the banks that they moved money into an account but not moved it out of another account. Another example where atomicity comes in was this concurrency and part-till execution problem we saw in good schedules and transactions video where we added money into one account, checked if that account had enough money, put it into a third account and removed it from the first account and then removed money from another account. And again, basically we get the same problem. We haven't added money in but haven't taken them out somewhere else if we have a failure just before we took money out of the second account. Again, this would be unacceptable for the banks and it's basically the same problem as on the previous slide. So in a nutshell, you can see if atomicity is broken if you have this kind of setup where you have a user and he has made one change, we have a failure and he wants to make more changes afterwards. If this occurs, then atomicity is broken. The second letter in ACD is C and C is for consistency and a transaction is consistent if it takes the database from a consistent state to another consistent state. So there are various definitions of this as there is not one fixed definition of what it means to be consistent. The typical ones is one based on saying that transactions may not violate constraints, like primary key constraints and foreign key constraints, and there's also a bunch of other constraints you can define directly in your database. And that makes fairly much sense on how you do it, it should also make sense. Or there is a much stronger version by the ESO standard saying that a transaction is consistent if it transforms the database state to reflect the effect of a real world event. This is much more complicated to check and we cannot do it in practice. There's also a bunch of other definitions I will not go into in this course, which I don't really feel reflect what I think of as consistency at all. Let's see some examples where consistency is broken. So here we had this problem one concurrency from the introduction we do two transactions. So here we had two people looking at the same flight and ended up booking the same seat. And of course this cannot occur, at least if you have the strong definition of what consistency means, where you say that it's only consistent if it reflects a real world event, and it doesn't reflect a real world event if you end up booking two people in the same seat. Another example that consistency could be broken was this example of problem three about concurrency and particle execution, where, at least in some cases, if you end up deleting the first transaction here, but not the second, you will have an inconsistent database state because you might have not enough money on the account, even though you decided to go ahead and add in 100 and then remove it from the account. Again, it depends on how exactly you're going to delete things and so on, whether this will lead to an inconsistent database data node. So consistency is a bit tricky here. It depends on exactly what definition of consistency you're following, whether a transaction has satisfied it or not. Also, some of them are easy to check and some of them are hard to check. Like, it's fairly straightforward to check whether a transaction has satisfied all the constraints. I mean, you just go through all the foreign key constraints, all the primary key constraints and so on, and check, does my database still satisfy all conditions? If they do, then things are fine. Otherwise, you have a problem and consistency is broken. There's also some other constraints, like general check constraints, that can do more than what we have seen before. But again, they're all very straightforward to check whether or not they're satisfied. So it is fairly straightforward to check if a transaction satisfies this big notion of consistency. However, it is very, very hard to do the strong version where you have to check if the database state reflects the effect of a real-world event. We have no chance as a database developer to check this. I mean, it will require us to understand the real-world perfectly, model everything to be able to do any kind of database, which is clearly unreasonable. So how do we deal with this in this course? Well, to deal with consistency, we are going to make an assumption, namely that a transaction, if it's run on its own, with no influence from any other transactions, is always going to transform a consistent database state into another consistent database state. We are also going to assume that initially the database is in a consistent state. So whenever you run a transaction, you have two possible outcomes. You can either commit, in that case you end up in a consistent state, because well, your transaction does this. It takes a consistent state and changes it into another consistent state. Or it aborted, and we have to undo everything. But in that case, we end up in the previous state, which was consistent. So again, everything was fine, if we abort everything. So especially, and this is a bit important, this implies that serial schedules are consistent, or a bit stronger, and this will sound a bit weird right now, but this will actually be quite helpful in a bit. If you have a schedule that changes the database in the same way as a serial schedule, then it's consistent. And such schedules are called serializable. It will come up again in just a minute. So the third letter in ACID is I, and I is for isolation. So here we get this serializability again from the last slide. So a schedule satisfies isolation if and only if it's serializable. That is, the effect of a serializable schedule is the same as some serial schedule. We know what serial schedules are, it's just the ones that does the transactions, all of one transaction, then all of a second transaction, all of a third transaction, and so on. All of them are just running on their own with no direct interference from other transactions. And that's the serial schedule. And a schedule is then serializable if it has the effect of some of this. So I want to stress this here. Consistency is not really defined by serializability, but at least for the purpose of this course, we will consider a serializable schedule to be consistent. We will also say that a schedule is serializable if and only if it is satisfying isolation. So isolation and serializability is the same thing. Consistency can be more than just serializability. However, in general, I think you should just think of consistency as being serializable, at least for the purpose of this course. So if instead of using the book or looking at the last slide, you try to go to the definition as to the SQL standard to figure out what isolation means, well, you're not going to see what was on the last slide. So I feel it's better that I cover it here, then that you look it up and say, hey, he doesn't know what he's talking about. It's not the same as the standard. Well, let me talk about what the standard is saying. So in the standard, we have four levels of isolation. The first level is called read uncommitted. I view it as basically not having isolation at all. Different sources have some requirement on what you're required to do if you're at isolation level read uncommitted. I personally view it as having no requirements, and some sources also do that. So it depends a bit on how you define it. Here, I'm going to say it means that anything is fine. You're allowed to read any kind of data, even if it has not been committed yet. Second level of isolation is called read committed. And here we are requiring that everything you read must have been committed before you can see it. So again, that has some options here, and I will get later into precisely what these possibilities are here for how to implement this stuff. Third level of isolation is called repeatable read. And it's saying that if you read the same thing twice in a transaction, you must get the same return value. This might sound sort of okay. That doesn't make any sense. Let me try to come an example where you will see the difference. Say we have a database over students grades, and I go into this database and make a query to figure out a specific student's average grade. And then a bit later, I do it again and say this was the same transaction I was doing it in. However, between the first time and the second time, the student might have gotten one more grade confirmed, so his average grade might have changed. However, if my transaction is using repeatable read, I'm supposed to see the same number both times, even though his grade has a substance in the meantime. So this is what repeatable read means. Finally, the last level is serializable. So in the standard, for some reason, this seemed to imply that by following this serializable definition we have on the previous slides, we also get the earlier levels of isolation. But I think it's fairly clear that you don't actually do that if you just follow the simple definition of serializable we have seen on earlier slides. You do not necessarily get things like repeatable read. You just necessarily need that it follows whatever would be done by a serial schedule. So some implementations can have more levels than this. Specifically, I believe MySQL might have one more level, specifically in between repeatable read and serializable, which is a default one. So you just need to specify that you want to use serializable if you want to use this. And I also want to stress here that isolation level four is what we will be calling isolation if I do not specify a specific isolation level. So by default, isolation is not really about all these levels. It's just about the last level, the serializable level, precisely as it was defined on the last slide. Unless, of course, I go in and want to be specific about things. In that case, I might talk about a specific isolation level. You can decide on your own exactly which isolation level you want by using this kind of commands in SQL, including in MySQL. So you can write set transaction read/write isolation level read uncommitted. That will mean that your transactions are allowed to both read and write, and you have set the isolation level to read uncommitted. It's reasonably clear, I think. So you can also write read uncommitted or read committed or repeatable read or serializable. And that just picks your isolation level instead of this read uncommitted at the end. Also, instead of read/write, you can say read only. So I think the last part, what this change in isolation level does, well, it follows from the earlier slide, what is setting a transaction to read only means that you are only allowed to do queries as in select queries. You are not allowed to do update queries or insert queries or delete queries if you set your transaction to read only. So let's see an example where we break isolation. Well, this is one of them. Here we are booking the same sheet twice in the two transactions, and that's not going to satisfy a higher level of isolation. So this does satisfy read committed because, well, the two reads are only going to read something that comes before, and it has been committed because, well, it was whatever it was in the beginning. But it's not serializable because if we change one to be before the other one, we will get a different behavior. Also, whether it follows a repeatable read depends on exactly how you've implemented it. In some systems, this will not follow repeatable read. In some systems it would. By definition, it would. But again, as I said, it's implementation dependent whether or not it's actually doing it. So let's look at this other example here, concurrency and partial execution from the earlier video. Again, this one is going to satisfy one level of isolation, specifically the one that isn't satisfying isolation at all, namely read uncommitted, but it's not going to satisfy read committed. So the only reason why we might have 100 pounds in this account might be that we put it in initially as user one. And therefore, the only reason why the first query works for user two is because you can see a user once adding 100 pounds. Therefore, you're breaking read committed if you can see that stuff. So durability was a bit hard to come up with an example of. However, it's not that hard to understand as a property. What durability requires is that once a transaction commits and changes the database, these changes cannot be lost because of a subsequent failure. So in other words, the effect of a transaction on database should not be lost after the commit point. Of course, except if you go in and directly change it. I mean, if I put 100 pounds into your bank account, durability is not requiring that to always be 100 pounds in your bank account. I mean, you are allowed to take money out of it afterwards. So what durability requires is that if something happens afterwards that erases this transaction for some reason, we must redo the transaction because otherwise we're not satisfying durability. And specifically, when we get to it, durability is for things like media failure. We might have a computer burnt down or whatever. This kind of thing is supposed to deal with to satisfy durability. So as we saw earlier, I only had this kind of complicated example, but durability is broken, dependent exactly on how you deal with this situation here. Again, as I said, I don't feel it's that complicated to understand what durability is doing. It's just saying that if you have already committed a transaction and we have done that, if you have done it here, then it's not allowed to later on undo it. So if you go back and rewatch this video on the content of the course, you will see that in this part of the course I'm going to talk about transaction manager, login and recovery and concurrency control. So how does this fit with me talking about ACID? So we had these two components, the concurrency control, which is about concurrency and login and recovery, which is about handling failures. So how does this components relate to ACID? Atomicity was about failures and surprise, surprise, it has something to do with login and recovery. Consistency is about serializability and it's about how multiple transactions interact and therefore it has to do with concurrency control. Isolation has also to do with concurrency control because again, we're defining it basically the same way as consistency. Finally, durability is also dealt with by the recovery control. Again, it was about what we did in case of failures. So in summary, here we were talking about ACID. So our databases are supposed to handle at least these four properties, these ACID properties. A is for atomicity, meaning everything or nothing is done. Consistency was a bit complicated, but it means that somewhere between constraints are satisfied up to matches or real world events. And exactly what it meant was a bit tricky to understand. But at least if you just think of it as serializability, then it should be straightforward enough. Isolation, it just means that a schedule is serializable, meaning that effects matches each execution of a transaction happening alone in some model. Finally, durability means that transactions that are done cannot later become undone because of some failure. failure.
Hi, welcome to the second part on COM 207. This is about transactions. Transactions, as I mentioned earlier, is a sequence of SQL statements, one after each other. So before talking about that, I want to thank Andrew for letting me borrow some of the slides here. I'm stealing the examples I'm using in many of the following slides from him. So yeah, thank you to him for that. Besides that, as you can see, I've been using a camera nowadays, because some of you suggested I do, so that's why I'm doing it. If you have other suggestions, please come with them, so that I can incorporate them into my teachings. The earlier I do it, the earlier I'll get to incorporate them. I'm not going to go back and incorporate many of them in the earlier ones, because doing the slides takes quite a few hours, like five to ten hours for just like half an hour maybe. So it will seem a bit excessive to go back and change the old ones, but if you come with a new suggestion, I will try to incorporate them in a future set of videos. So this whole part is about transactions in SQL. So a transaction is just a sequence of queries that happens one after each other. It sounds terribly easy, really, right? The complication comes from the fact that many of these transactions might happen at the same time, and sometimes computers may fail. Both are going to lead us into problems, and we're going to spend quite a bit of time dealing with these two issues, especially the first one. But again, there will be quite a bit of overlap also. So far, we've been talking about SQL queries in isolation. That means that we have one computer spitting out queries to the database, with an answering back again. And then we want a new query based on that, and so on and so forth. Fairly straightforward. In practice, we don't have the situation typically. We have a whole bunch of computers, they're all sending at the same time to our database, and the database is then sending back again. And then these people are making new queries based on it, and sending to the database, who send it back again, and so on. And these queries can overlap in time, and it makes things that sort of seem reasonable to do not work as you would expect them to. This is one problem we might have. Another problem we might have is that, well, computers can fail. Say you wanted to do five transactions, but after having done the first three, the computer failed, and the last two are not going to run. So that's another problem. Again, we're going to use these transactions to deal with both of these problems. Let's see how to do it. Let me first discuss this problem with concurrency. Let's look at a flight's database. We have a flight number, a date, a seat number, and a seat status. And we might make the query of what seats are available on flight one, two, three. So we do it like this. We select a seat number from flights, where the flight number is one, two, three, and the date is Halloween this year. And we set the seat status to available. Okay, let's try this straightforward. We might say, hey, I love seat 14b. Let me book that seat. We might do it with this query. We update the flight's database. We set the seat status to occupied when the flight number is one, two, three, and the date is Halloween this year. And it's seat number 14b. Excellent. It's straightforward. We understand what we did here and why we did it, and so on. But what happens if we have a second user? He might also search for seats available on flight one, two, three. He might also say, hey, I love seat 14b. Let me take that one. But obviously, if you do this, then we have two people sitting in seat 14b, which is not really that reasonable, especially with all this coronavirus stuff. I mean, that's clearly breaking social distancing. Honestly, also, we're not going to do it in reality. It will be inconsistent with reality. And we don't like that. So how would we like it to be done? Well, in essence, what we would like to have done instead was everything user one did happen first, and then everything user two did happened afterwards. Because now we cannot have this issue anymore. Because seat 14b on flight one, two, three was occupied, he will not select that one, and therefore the problem didn't happen. So this is sort of in essence what we would like to do. How do we do that? Well, in essence, the way we do it is using these transactions. Intuitively speaking, we must ensure that these transactions are executed so that certain problems doesn't arise. This is one of them. I'll later go into more details about what I mean precisely with this issue and such, and how it's enforced, and so on. So we have these two queries. How we do it in practice is just write them down like this, maybe with some other non-database operations in between. We say start transaction first. We say commit afterwards, and then the database ensures that nothing will go wrong here. Well, in reality, you don't write 14b in the second one. You write one of the seats that are available, but apart from that. And this works well. This ensures that only one of these two transactions will work, because the other one will have seat number 14b as occupied the second time. Typically, in many database management systems, we don't need to write start transaction though first. You can assume it's done automatically, and if it's not done automatically in the one you're using, you can typically set it up to be done automatically. And here, this one is important though. If you don't write commit, it doesn't update the database whatsoever. So before you write commit, any change to the database has not really been depend on. You can also write something else called rollback. That means that every change you made in this one section are going to be discussed. I will mention it later also. So this is basically the pattern here. So let me see a bit more about this transaction. As I said, a transaction is just a sequence of a SQL statement. And we have a special case of one SQL statement being its own transactions. This is also what you saw earlier. By default, my SQL is set up to treat each individual SQL statement as a transaction on its own, and then committed automatically just afterwards. Which was why something happened when you wrote all these SQL queries earlier. So by telling the database management system that a sequence of SQL statements from a transaction, we ensure something called serializable behavior. This is a bit problematic to pronounce for me, but the idea is that, intuitively speaking, each transaction has been done on its own without being interfered by with other transactions. So basically, you run one transaction first, then the next one, then the next one, then the next one. Or at least that's how it looks like from the point of view of each transaction. Using this syntax here. We'll see later how we do this. And that is not quite done as if we had done it one other time. There is, there can be some overlap, and we will try to allow as much overlap as possible because it makes our queries faster. Again, we'll come back to that. Also, we can set how strict we want this isolation to be, as in how much isolated the different transactions should be. I'll get back to that in the next video. Or maybe two videos, I cannot remember quite. It also ensures a bunch of other properties, and again, that will come back to it. Actually, I'm sure now it's two videos. So the other problem I wanted to mention was this partial execution problem. So let's look at another example. Let's look at a bank account this time, like the one you did for the first tutorial, if you did the exercise in the first tutorial. So we have an account number, we have an account holder, we have a balance in this bank account. And we want to move 100 pounds from one account to another account. That doesn't sound that complicated. So how do we do it in the squirrel? Well, we add 100 pounds into one of them, say with 4, 5, 6. We do it using this query. We update the accounts, we set the balance to be 100 and higher, where the account number is 4, 5, 6, straight forward. Then we subtract the 100 pounds out of the other account, say account 1, 2, 3. Of course, we do it dually, we update the accounts, we decrease the balance with 100, the account number is 1, 2, 3. The file is straight forward again. So unfortunately, power got lost in the middle. There was a failure. That was not great. What this failure does, then, is that we'll not be able to do the second one because, well, the computer is not there anymore. So it just gets lost. Hmm. The bank will be kind of unhappy about this one. So this is an unacceptable state, if you are banking, especially. If you're the customer, with account number 4, 5, 6, you're happy. If you're the customer, with account number 1, 2, 3, you're ultra-happy. But the bank is not happy. And how can we deal with this problem? As in, how can we ensure that either both of them happens or neither of them happens? I doubt this one isn't a surprise by now, but the way we do it is we use a transaction. So SQL ensures that transactions are done, what we call atomically. That means that either all of it is done or none of it is done. Atom means indivisible, so that's where it's coming from. So we do the same thing as before. We write the two queries down. We wrap them in start transaction, a commit, and it ensures that if power fails in the middle, nothing gets done because, as I said, before you write commit, every change is tentatively as in it might not happen if you don't write commit. Another change, this was not suggested by any of you, though, is I'm going to introduce some summaries after each video just to make it easier to see what's going on. Also, that if you're reading the slides, you can just go to the last one and see a summary of what went on. So in this video, I discussed what a transaction was, which is just a sequence of SQL statements, and in general, it looks like this. You have start transactions, once of SQL statements, and then this commit command. And you can omit the first part, and before you write the second one, nothing gets done except if it makes the commit automatically with my SQL DOS by default. Again, you could write something else here. You could write rollback. This means that you aborted transactions, and none of what you did gets to change the database whatsoever. So this is sort of the two options here, and that's the form of transaction. [BLANK_AUDIO]
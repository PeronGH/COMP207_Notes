So, as I said in the last video, in this video I would like to show that this two-phase locking transactions ensures conflict serializability of inner schedules. So, in this video I'm going to show you that these 2PL schedulers are conflict serializable. It is, as you can see on the video length, not a long video, but I still follow us best to have a new video for it, instead of having a very long video about the previous one. In the beginning, I claimed that wouldn't do too much reminders in these videos, but I still feel I was right to remind you what this two-phase locking is, because we are trying to show that they guarantee conflict serializability in this video. So, it makes sense to be much earlier than that. So, a transaction is two-phase locking. If the first phase contains locks, possible read and write operations, and the last phase contained unlocks and possible read and write operations. And again, here you need to ensure that we have this basic principle of locks working. So, before an operation on an item, you need to have the lock for that item, and you should unlock it afterwards. And that's only one lock, so only one transaction can have the lock at a time. And in this video, we're going to show that this alone, this two-phase locking alone, is enough to guarantee conflict serializability. And this is in essence how it's done in database management systems. So, in essence, we're trying to show that if a schedule only has two PL transactions, then it's conflict serializable. So, let's say we have our schedule here. At some point, we're going to do the first unlock, because we promise to always unlock whenever we do a lock. Of course, if there are no locks at all, that means we don't read or write items. So, in that case, it's trivial. So, we can assume that there is an unlock somewhere, because otherwise we're not doing anything. So, let's say it's on item X in transaction I. It doesn't matter what I is, it doesn't matter what X is. So, these are sort of three variables, they're just associated with this first unlock. And now I want to argue that using this swaps from conflict serializability, we can move everything about transaction I to the beginning, and then we can repeat this argument, basically. So, we need to argue that we can do swaps of consecutive non-conflictable operations, moving everything about I to the beginning. So, let's say we have, um, we read something in operation I on some other variable Y. It could also be the same as X, it doesn't really matter. But we're doing some operations at some point in transaction I. And forced to have a conflict, that means that some, uh, as in forced to not be able to move everything to the beginning, means that there is an earlier one, an operation where we write something on this Y in another transaction I, J. Of course, if the read had been on write, this one, then the operation in transaction J could have been write also. It doesn't really matter for the argument, though. But the key thing is just that we have this conflict here. Now, what does it mean that we have this conflict here? That means that we must have unlocked, we must have unlocked Y in between and locked it for transaction I afterwards. Because right now, for transaction J to access item Y, it needs a lock, and we need to lock in item, on Y in transaction I afterwards, to be able to access it. So, we need this pattern here. Now, we cannot have that pattern here on the left hand side of the first unlock, because, well, the first unlock is the first one in schedule, we cannot have an earlier unlock, then that will contradict our claim that this unlock on item X is the first one in the schedule of any unlocks. So, we must have this part on the right hand side. Fine, it could still be a conflict here, and that has nothing really preventing it from what I said so far. But, and this is sort of the key, we know that this transaction I is 2PL, and now it has an unlock in transaction I, so we cannot have a later lock in transaction I. And therefore, this pattern could not be on the left hand side, because then it will break the first unlock, the definition of the first unlock, and it cannot be on the right hand side, because then that will break 2PL. So, there's no way we can have it on left side or right hand side, and therefore this conflict cannot exist at all. Therefore, we can keep on moving every operation in operation I towards the left, because we cannot have any conflicts with any operation on the left. And therefore, we can move this operation all the way to the left hand side, and we can move the next one and next one and next one in operation in transaction I to the left hand side. And at the end, we have all our transaction Y in the beginning, and then we afterwards have some schedule, and it's still over something which is 2PL, because when we had just removed one of the transactions over 2PL, the remaining transactions, the ones the rest of the schedule is defined over, are all to 2PL. So, we just made a smaller problem, and therefore we can repeat this argument and move a new transaction all the way to the left, and then a new one, and a new one, and a new one, and in the end, we only have a serial transaction set of all the way contained after each other. Basically, we only have a serial transaction left, and therefore we are done with our argument. So, as a summary of this video, we saw that if we have only 2PL transactions, then our schedules are also conflict civilizable, and therefore we have a simple way to create conflict civilizable schedules. We just ensure that each transaction satisfies this 2PL requirement, and this is easy to verify, and you can do everything online here. So, that's what we want from our scheduler.
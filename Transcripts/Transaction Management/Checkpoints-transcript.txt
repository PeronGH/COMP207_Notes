In this video I will discuss checkpoints. So why are we looking at these checkpoints? Well, it all basically boils down to that the log files end up being bigger than your database if you don't do anything like this. So if you think about it, whenever we make a change in our database we need to insert a line into our log file and therefore of course the log file becomes bigger than our database. And this is quite unsatisfactory because, well, in some sense the main thing should be the database. These log files are just something we use to help produce a database and ensure these ACID properties. So the point of these checkpoints is that we can cut off at least part of the part before the checkpoint so we can erase much of our log files using these checkpoints and therefore they will be faster to do recovery and it will take up this space and in particular this space in our entire database. So we will see two kinds of checkpointing. We will see one here, the simple one, for ondo logging and we'll later see one called non-consistent checkpointing which is useful for ondo/wedo logging or it can only be used for that. So the idea of these checkpoints is that every once in a while, like every m minutes after you have done a number of transactions or like the log file takes up too much space or whatever, at that point you make a checkpoint and the idea is then that you don't need to go beyond this checkpoint when you do recovery. So yeah, we can discard the part before the checkpoint in our log file. The procedure for doing it looks like this. You stop accepting new transactions and you wait until all the active transactions have committed or aborted and then you flush the log to disk, write a record saying checkpoint and then you flush the log to disk again and resume accepting transactions. Now basically you can remove, after I've done this, remove everything before the checkpoint and the database will keep on working, well, as long as your hard disk doesn't go bad but again, as we saw earlier, we assume that someone else takes care of the hard disk and on the other hand, if the hard disk goes bad, well, you also lost your log file so it won't really matter that much. But yeah, this is the procedure and we will later see a variant that avoids some of these issues we are having here, like we stop accepting new transactions and wait until they're done. That's kind of an annoying property and the non-contestant will see later will avoid that. So how do we do recovery via this simple checkpointing? Well, you have a log file. At some point in the log file it says checkpoint and you just process the ondo log backwards exactly like before but whenever you reach a checkpoint, you just stop and are done with it. So yeah, you stop at the first one, you don't need to see if there are more. And everything that are behind the checkpoint or the transaction and so on, they've already made all your changes to the disk so you don't need to look at them. And therefore again you can delete that part of the log file because the recovery never uses it and you would not abort any of them either because again they have been either committed or aborted already so there's no need to do more with them, with the transactions behind the checkpoint. So let's see how it works on our example from earlier. We had two transactions here, transaction one and transaction two. And let's say that here in the middle we want to start doing one of these checkpoints. So what happens if transaction three is submitted here at data point? Well, it will just be told to wait. We are doing a checkpoint right now. And then here at the end of time, after time 19, we're going to write checkpoint in the log file and we are going to flush it. And then after having done so, we allow transaction three to proceed and we're done with the checkpoint. So after having seen the assembled checkpoints, we saw two annoying properties of them. One, we cannot start new transactions while we are trying to make a checkpoint. And two, we need to wait until all the current transactions are done before we are finished with the checkpoint. So both means that we have to delay quite a few operations in our operations when we do this kind of simple checkpoint. Here I will talk a bit about a more advanced form of checkpoints called a rise that allows you to avoid these problems. However, to do them, you have to do some more advanced properties. Specifically, you have to use ondo/redo logging and transactions are not allowed to write to the buffer before they want to commit. I should probably say that I'm simplifying them a bit here for this presentation. There are more properties, but you don't really need to know all the details about them. So what you do is you write a checkpoint and then you write the currently running transactions in a log file and then you force it out to the disk into the log file. So the running transactions are the ones that are currently not committed and not aborted and these are the ones we call running right now. And then you write the content of the buffer to the disk and this is where we need this property that transactions do not write to the buffer before they surely want to commit, because now we're going to restore the buffer afterwards. So we write the content of the buffer to the disk using this output command we have seen earlier. And then finally after we've done all that, we write in checkpoint and flush it out to the disk. We write that in log file. Notice here that these can be forcefully ended as in you just need to do a number of steps and when you're done it you are done with the checkpoint and the checkpointed over and there's no requirements that we stop accepting new transactions and we don't need to wait until transactions have finished to finish one of those checkpoints. Let's see how to do recovery with these more advanced arise checkpoints. So abstractly we end up with log files looking something like this. Here we have some end checkpoints, some checkpoints, some start transactions, and a bunch of chain separations also inside the log file. And in essence we end up doing the undo/ redo log as before, with some exceptions specifically that we're not doing it on the entire file anymore. But we will get back to that in a bit. Let me first describe the part of the file we actually talked in. So we can in a log file stop after having found a checkpoint, T1, T2, and so on, that has a corresponding end checkpoint, and start transaction I for all the mentioned transaction that I get uncommitted. So if only one transaction is uncommitted, say transaction 1, then we stop moving up in a log file at the start of transaction 1. If multiple transactions like T1, T2, and T3 are all uncommitted at this point, we stop moving upward at the earliest start point of these three transactions. And if all transactions are already committed, we start moving up at this begin checkpoint. So what we need to do when we process the undo/ redo log is basically only do the part afterwards. This means we'll never touch anything behind this point up here, never do any changes up there, so we can just erase that part of the log file, and this is sort of the part we can omit similarly to anything before the checkpoint in normal checkpoint or simple checkpoint. So more precisely, we only need to redo the part of the committed transactions after the checkpoint, because we have the log buffer file as it was at the checkpoint, so we can just restore that buffer, and then redo from there. And then after we've redone all of that, we undo the uncommitted transactions, including the part before the checkpoint. So you only need to restore redo from the checkpoint, and you only need to undo the things that are actually uncommitted before the checkpoint, which makes it much simpler. And we can omit a part of the log file after having done this. And this is the point of these arise checkpoints. So in summary, we have seen checkpoints, and they can be used to speed up recovery, and they also allow you to use less space for log files. These two things go hand in hand, as and because the log file uses less space, then less work to do on them, and therefore you can do it faster. We have seen simple checkpoints, which simply prevented new transactions from starting until all current transactions are finished. Well, that has a kind of annoying property that, one, you need to wait until they're finished, and two, you cannot accept new transactions, which are both bad. And therefore we saw a more advanced technique that avoided that, called arise checkpoints, but these required undo/redo logging, and that you couldn't write to the buffer even before you are sure you wanted to commit.
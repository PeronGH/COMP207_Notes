So in this video I will try to characterize when a transaction or a schedule is good. I'm actually not talking about when they're good, but I'm talking about when they're not bad. So a schedule or transaction will then be good whenever they're not bad. This can sound quite philosophically and it is quite a far way of it. But it's sort of the standard things we'll end up seeing here in databases, as you will see in many other places, even though this might be a bit more philosophical way of looking at it than many others. So today the exercises will be based on trying to see if there's other things than the ones discussed that could characterize a schedule as being good or bad. So the first one I want to look at comes from this problem with concurrency we saw in the video on transactions. So we had these two users and we had a flight database and one user was booking a seat on flight 123, specifically one of the free ones, which was seat 14B. And at the same time, user 2 was also booking the same seat on the same flight, which of course cannot really happen. And I see an issue with the concurrency that these two things should not overlap in time like they're doing here. They should see each other or one of them should see the other and it should avoid doing this move here. So let's try to characterize what the issue is here. So it has to do with how these two transactions interact with each other. So the problem is in essence that they're not isolated from each other, they interfere with each other. And ultimately, you can also view it as not consistency with regards to the real world here. You can only have one person sitting in one seat and this is not a consistent outcome we have here. You can look at it from all of these two directions. So what did we do to solve it? We've already seen it from earlier. The idea was we just undid the second transaction when it tried to do the second operation. That way only the first transaction would end up sitting in seat 14B and transaction 2 didn't really happen. And that was sort of how we will solve this. That's more or less fine. So let's look at the other one we saw earlier, also from this introduction to transactions video. Here the problem was about partial execution. So we had a bank account and we were in the process of moving money from one bank account to another bank account. And then we had a power failure or similar thing happening in the middle. So half of the move didn't happen, so we only added money in one place, but didn't take it out to another place. And the bank was a bit unhappy about this stuff. Again, that's an issue. So here we have the issue that only parts of the transactions get executed. A transaction, as I've been saying earlier, I believe should be atomic. That is, it should be indivisible. Either nothing happens or everything happened. And it might not also not be consistent with what you had in the real world, depending on precisely how you define that. Typically we will say that it was consistent, but you could define the situation so that it wasn't consistent. Only to add money in one place, but not take it out to another place. So what did we do to solve it? Well, we just undo the transaction when the computers come back online and then nothing has been done. So nothing wrong has been done. We're more or less happy with the situation. Of course, it would have been nice to do it, but we might be missing some parts of this inserting money into the second place. So we don't really know if you have everything there and therefore we cannot really do all of it. So therefore we just remove everything instead. So the other two examples we have already seen. So let's see a new example I would like to highlight. We have seen three issues here. We have seen this isolation issue that things should be isolated from each other. We have seen the issue that things should be consistent to some degree. We have seen the issue that things should either execute all of it or none of it. And now I want to highlight this last issue that's typically talked about in databases, but it's a bit more complicated to see in an example. So I'm using a bit more involved example here and it will come up when we get to cleaning up this example afterwards. So what happens here is, say both of us have a number of bank accounts here. Say there are 100 pounds in account 123 and user 1 is then moving 100 pounds from this 123 into 456. User 2 is then testing that there are 100 pounds on account 456. If so, he's moving them to account 789, subtracting them from 456. And then finally user 1 is subtracting them from 123. There's not really any problem here. It's sort of fine to do it this way. It's not so nice in some sense that we haven't done the first part before we do the second part, but there's no conceptual problem with doing it. Let's look at some queries for doing it, though, just because I did it before. So a query for doing this at 100 pounds could be like this. We update the accounts, set balance to 100 higher. The account number is 456. Next query could be about finding if there's 100 pounds on account 456. We just find the balance on account 456. And then we should add 100 pounds into 789. We do it like we did it in 456. We just change 456 to 789 in the first query and then subtract from two accounts first from the account 456. Subtract 100 pounds and then subtract 100 pounds from 123. It's fairly straightforward. There's nothing real problematic going on here so far. The key would be if we are unlucky and we had a failure here so that the last transaction, the one about subtracting the money from 123 didn't happen. Yeah, this is going to lead into problems of a specific kind if we try to clean this up. Let's look at it. So first of all, there is an issue here with how only parts of one transaction, the one for user one, might get executed. So this was this issue with atomicity that transactions should be indivisible. We also had some issues with how the two transactions interact. There is the problem that it might not be consistent the way it works right now. User two makes a check, but user one has not committed yet. It's not super consistent depending on what we mean by this statement. Also, the two transactions are not really that well isolated from each other. Again, this is an issue. So what can we do to solve these problems? Well, there isn't really any good way of doing it. I'm going to go to a long version of this answer on the next slide. This was just a short version, but a long version sort of carries us to all the different options and see why each of the different options for this problem here is quite bad. Let me try to walk through this long version of this answer that there is no good solution to this problem with your saw. If we get into this issue, there's no good way of getting out of it again. So let's look at the options. The first option would be not to do anything. It's the most simple one, I guess. But then the bank lost money and we have this atomicity issue that the first transaction is stopping in the middle, which is not really what we mean when we say a transaction. So that's a problem. Another option would be to undo the first transaction, but not the second. But then the second one might not be valid anymore because as I have done this check, that is a 100 pounds in the account. And then based on that, it has made some choices afterwards. So that's directly this consistency issue that we have made a check and we should really have failed the check, but we didn't fail the check because the reason why we didn't fail the check was that something before something happened that really didn't happen. The other issue was this isolation issue that the two things, as in where the second user's transaction depended on the first user and if the first user didn't happen, well, that's a problem with this isolation. Now the final option, well, okay, there's one more option, but the last option of deleting just number two transaction, we'll see a bit weird because it hasn't really done anything bad. And it would likely lead to multiple issues. But the final sort of reason is to undo both transactions. But here, think about it, the second user has already committed, he has already finished everything he wanted to do. And he might just have gone away from the computer or whatever after having done so. And at the point he went away, he thought, hey, everything looks good for me. I'm happy, I don't need to look at this again in the future. So it would be really bad if we go in afterwards and say, hey, we have undone everything you have done here because there was an issue somewhere else. So this is a new issue, as I said. We would expect whenever you made a commit statement and the database said, hey, yes, I've committed, that this is not going to disappear again in the future. We expect this transaction then after the commit statement has been acknowledged by the database to be doable. So now we have seen sort of four issues here. We have seen the satomicity issue, we have seen this consistency issue, isolation and doable issue. And together, if you take the first letter, it spells ACID. And this is what these four properties together are called in relational databases. And typically all relational databases should satisfy these four properties, so no transaction or schedule can suffer from many of these things. So now we have seen four ways our schedules can be patterned. The first one, atomicity, is about either we do everything or nothing. The second one, consistency, is about checks, that things are consistent with the real world or whatever checks we are making in our database. The third one is about isolation, that the different transactions are well isolated from each other. And the fourth one was this weird one, the one that required a bit of explanation to do, where we say that we expect that if a transaction has already finished, then it's not getting undone afterwards, that it will stay around in the database. Of course, a data transaction can then come on onto whatever it did specifically, but it's not because the first one didn't happen, it's that something else did the opposite of whatever the previous transaction did. So after you're committed, you should stay around and this is the ability property. That's basically these four properties, that makes up these eight properties, and the next many videos will be about this. The next video specifically is about defining them properly, as in here we just sort of explain them intuitively what they're about. And next one will come with some precise definition of what each of these four properties is. And afterwards, we'll spend the rest of this part on transaction management, on discussing how we can achieve these four properties. And that's sort of the hard part of it, this transaction management. How to ensure atomicity, consistency, isolation and durability, while you have a database that might suddenly fail, or that might suddenly have multiple transactions at the same time.
In this video, I will discuss how to do logging for conflict serializable schedules. More precisely, this video is about how we actually do these conflict serializable schedules in real-life database systems. So you might be asking yourself, why ain't we done yet? Well, the answer is that we haven't really answered the right questions yet. So in the last video, we saw how we could recognize whether or not a given schedule was conflict serializable or not. But that's not really the question that the database management systems are facing. They're trying to make one of the schedules and they're trying to make it what we call online in computer science. So let me try to show you what we're sort of missing and then start to try to tell you how we're actually solving that problem. So how do the database management systems go around making a schedule? Well, to answer that question, we need first to look at what exactly they're doing. So what they get as input is a sequence of operations from the same sections. And depending on what we do with this or what the answer to these operations are, the different transactions might do different things. So, for instance, we saw earlier an example where you search for which seat were free on a flight and in your book, one of the free seats. And of course, which seat you book is going to be depending on which seat were free. So we cannot in general assume that we can know the full transactions. We might only know the current operation. And then depending on what we do with this current operation, if we allow it to move forward or not, we might know what happens next. So we cannot know the full future of the transaction. We can only know what's happening right now. So we get as input right now a bunch of operations, one from the different transactions running right now. Or it might not be done right now. It might also first come in a little bit of time. So we might not really have that much information to go on. And that's sort of our input to our generate a schedule module, which is called a scheduler. And, well, what can we do then? Well, we can either right now say that this transaction allowed to move forward, that transactions should wait and so on. We can do that for each transaction. You can say you should wait or you should move forward or you are allowed to move forward. And, well, from all of this, we need to generate conflict serializable schedule. And as you can see, this is very much not a problem we've been talking about earlier. This is a new problem and therefore we need new tools to handle it. So also I want here to stress again, it's not enough just to know how to generate a conflict serializable schedule offline. You need to do it while you get this as input, because, well, what the transactions are doing in the future depend on what you do right now. And if you first did it at the end, you will need to wait a lot longer to get anything done. So even if you could do it at the end, it had been much more to do it online in the sense because you can do it much faster than because you can do it while things are running instead of waiting until the end. We will see one way right now how to solve that problem and then we come back and see another approach to it a bit later in this part of the course. So the first way we will see right now is using something we call locks for it. So what is that? So let's look at how a simple version of it is first and then in a later video I'll come back and tell you a bit more about more advanced versions of lock. But the simple version works as follows. Each item is associated, each database item like X and Y are associated with a lock. And you need this lock before you're allowed to do anything whatsoever with that database item. You can only read from the database item or write to the database item if you have the lock for that database item. You're not allowed to do anything with the database item otherwise without a lock. So the way you get a lock from a database item is you as the transaction are going to ask the scheduler for a lock. And the scheduler might then either give you the lock or might say well you'll have to wait, someone else is having the lock right now. Because there's only one lock for each item and well when one transaction has it the scheduler doesn't and it needs a lock back before it can give it to someone else. So it sort of works in a quite physical way this locking system, the basic one at least. And after you have used the lock for a time as a transaction you're supposed to give it back to the scheduler because otherwise no one else will ever be able to access this item. So let's try to see how it works on a small example here. So we have two transactions, we have our scheduler and both transactions are looking at item X. Transaction one just want to read it, transaction two want to both read and write it. It doesn't really matter precisely what they want to use the item for right now, it just matters that they want to use the item. So as I said they need to lock the item before they use it, so it looks something like this. And then we start off from the top. Transaction one goes down, take the lock for item X, the scheduler gave it to them and we move forward in transaction one. Now we might move over in transaction two, go down, ask hey scheduler can I get the lock for this? Well no you cannot because transaction one has the lock right now. We only have one lock and it can only be one place at a time, either in our scheduler or in a transaction. And therefore right now transaction two cannot move because it's waiting for the lock, but transaction one can at least move. So we might also later unlock it like down here and transaction one is moving forward here, so it's going to read from it, doing some other things and then it's going to unlock. And at all times before transaction one is unlocking, transaction two cannot get a lock because it is at transaction one's place and therefore the scheduler doesn't have it and therefore cannot give it to transaction two. But when transaction one has unlocked it, the scheduler can give the lock to transaction two. At that point transaction two can move forward, it can start reading and later writing and then at the end unlocking. But it's sort of very much straightforward, only one person can have the lock at a time. And this is, well, how you just use Fingr for it. So Fingr for it is the physical item, this lock thing, and either the scheduler has it or a transaction has it, and the scheduler will try to give it to a transaction if it has the lock currently. And it's asked for it. So that's how it works with a simple locking mechanism. Let's try to see some examples. As we saw before, when we want to give an example of this stuff, we need to have a notation for it because otherwise it gets too messy. So what is the notation? Well, we're going to extend it, our previous syntax, with two more operations. We have lock of item X on transaction Y, I. We're writing that as L on the subscript I of X. Similarly, we're writing the on lock in transaction I of X as U subscript I of X. So an example could look something like this. I schedule, get a request of locking on X from transaction one. Then transaction one might want to read something from X. Then on lock X, this is by the way the example from earlier, just written in shorthand. And then locking on X on transaction two, reading of item X in transaction two, writing to item X in transaction two, and on locking of X in transaction two. So the notation is file is tried forward. And let's try to describe the rule from earlier. Well, whenever you have an either read or write operation, you need to have a lock operation without having it unlocked afterwards. And that's basically the requirement. That way, if you have done this, you have the lock currently when you're doing the read or write operations, otherwise you do not. Also, because as I said, we need to unlock at some data point whenever we lock, we have the requirement for each lock operation that comes a later unlock operation in the same transaction. And finally, if you have two lock operations, because only one person can have the lock at a time, you must have an unlock operation from the first one before the second one. So there's only one lock in the fact that at any time, so think of it as sort of a physical item, this lock here associated with element X, and you need this physical item before you can use read or write operations on this item. And you need to give it back the lock whenever you used it. Let me show you first that just because we're using this locking thing doesn't mean we get conflict civilizable or even civilizable out of it automatically. And then in a bit, I'm going to show you a simple modification that will ensure that a simple requirement, more precisely on the transactions, that will ensure that we get conflict civilizable out of it. So let's say we have these two transactions and as I said, I want to show that not all schedules that follows, all requirements are going to be civilizable. Let's say we have these two transactions. First on section one does something on X, that means it needs to lock first and then unlock it, then does something on Y, that means first it locks it and then it unlocks it. And similarly in transaction two. First something on X, then on Y. And let's say that we look at the schedule that refers to the first half of transaction one as in the part about X, then do all of transaction two, and then go back and do the last half of transaction one. So in short notation, it looks like this. And I claim this is not civilizable. So let's see if we can see this. Well, what does civilizable mean? Well, it means that there should be some serial schedule doing the same thing. So let's look at these two things here and see what will happen on some input. Let's say we start with both X and Y being zero because then the math becomes easy. Say we look at first the two serial schedules. So either we do transaction one first and then transaction two or transaction two first and then transaction one. Let's look at the one where we do transaction one first and then transaction two. In that case, first we add 100 to X, letting it become 100. We add 100 to Y, letting that become 100. And then we double both of them to 200. So at the end of that, we have to admit we'll have both X and Y being 200. What happens if we do it the other way? Well, first we multiply zero by two, getting zero, that's X, then we multiply zero by two again, and that's Y. So still after transaction two is done, if we do transaction two first and then transaction one, you will have X and Y being still zero, then we add 100 to both of them, and they're both 100 at the end. So in both cases we see they're either 100 or 200, and both cases they're equal, no matter which one we run first. What happens in this schedule? Well, first we add 100 to X, then we do all of transaction two. That means we double X to 200, we double Y to zero, and then we add 100 to Y afterwards. So at the end of this, we have to admit we'll have X being 200 and Y being 100, and that's not the same thing as either X and Y being 100 or X and Y being 200. So this schedule is not serializable, because this effect is not the same as a serial schedule. So let's try to modify this schedule a little bit and then get a conflict serializable schedule out of it. So we have this two transaction from before, and what we do is kind of simple. We just flip the on lock and the lock here in the middle on both sides, and then we look at what kind of schedule we can get out of it. Well, we should start on one side. Let's say we start on side one, transaction one, we can also start on transaction two, it will give the same kind of behavior, but I'll have to write two before one then. But otherwise, no real difference. So notice here that when we have given a lock to transaction one, we cannot do anything in transaction two before we get to the on lock over here. Because, well, currently transaction two wants a lock on item X, and I can only get it when we have one lock on it. And notice here that transaction one has a lock on item Y, which will become important. So now we can start here in the middle of half the transaction one, we can start on transaction two, we can get it down from lock X, read X, write X, and then we try to lock item Y. But this is going to be denied, because transaction one already has a lock. Therefore, at this point, we can move in transaction one, we cannot move in transaction two anymore. And we finish transaction one, it reads Y, it writes to Y, it unlocks Y, and then transaction two can finish. Now we have a schedule here. It's not trivial, but it's fairly easy to see, I feel, that it's conflict serializable, because, well, all these operations in the middle is only about X, and the last operation, or all operations from transaction two in the middle are only from about X, and all the last operations in transaction one is only about Y. Therefore, we can swap them around using this conflict serializable stuff. And that's why this scheduler is conflict serializable. Here I should probably point out that when we talk about conflict serializability, we're only talking about swapping the read and write operations, and we're sort of not really swapping the unlock operations, they're sort of just moving along with everything else. Or you can also think of it as swapping them as well, it doesn't really matter. But yeah, in the end, you can see that this schedule is conflict serializable, and we will later see that this is always the case when we follow this kind of pattern, and I'm going to describe this kind of pattern next. So this kind of pattern is called, or is an example of something called two-phase locking. So it's a simple modification of this early simple locking mechanism that guarantees conflict serializability. So what it does is as follows, it needs transactions, all lock operations must proceed all unlock operations. So notice here, I'm not talking about schedules, I'm talking about transactions. So in each transaction, all locks must become before every unlock. So if you have a transaction here, in the first half, you can request locks and do some other operations. And in the last half, you can do unlocks and other operations, but you cannot do any unlocks in the first half, and you cannot do any locks in the second half. Well, it doesn't necessarily need to be equally big, but that's sort of the idea. And if you have this property, we're going to call it a two-phase locking transaction. So let's look at the example from before and see that the first one is not conflict serializable, because it's not 2PL, and the second one is 2PL, and therefore become conflict serializable. So our example one here is not 2PL, why is it not? Well, it's because if you look in the middle, you see that we have an unlock followed by a lock, and that you cannot fit into this two-phase locking mechanism, because you need all locks before every unlock. And that's not the case here. It's also not the case for transaction two, but it's not really relevant for this being a two-phase locking or not. Another example, this one was our example two one before. Here we have all the locks before every unlock, and therefore transaction one is 2PL, and similar for transaction two, all locks are before every unlock, and therefore transaction two is 2PL as well. So while I think it's fairly easy to see, I will give you a simple recipe for how to test it, because some people have been asking me in earlier years how they can see it in a simple way. So let me be direct about it. You start from the beginning of a transaction, you find the first unlock, and phase one is an up to this unlock, and phase two is from that unlock until the end. And our schedule is two-phase locking if phase two does not contain any locks, and that's it. That's how you can test it easily. And our schedule is two-phase locking if it's all these transactions are. So let's see in an example here if these two transactions are two-phase locking or not. So we start from the beginning of transaction one, we scroll down, we get down here to the first unlock in transaction one. So the first part of transaction one is phase one, the last part is phase two, and we scroll down here and see if we can find our lock, and we couldn't, in this case it's here. And then transaction one is not a two-phase locking. That's already going to show us that the scheduler is not two-phase locking, because one of the eight transactions is not two-phase locking. But let's also see it for the other one, just to go into details here. So we start from the beginning, we scroll down until we hit an unlock, then the first part is phase one, the last part is phase two, and we scroll down, see if we can find a lock, we couldn't in this case, and therefore this one is not two-phase locking. And that's the argument for this example here. Let's see it on the other example. So for the other example, again, let's see if it's two-phase locking, and this one turns out to be two-phase locking, so let's see it. We start from the beginning, we scroll down, find the first unlock, then the first part is phase one, the last part is phase two, and we scroll down and see that there are no locks in phase two, and therefore this one is two-pl. Then we do the same thing for the other transaction. We start from the beginning, we scroll down, and the top part is phase one, the bottom part is phase two, and we scroll down in the second part and see that there are no locks, and therefore this one is also two-pl, and that means that the scheduler is two-pl as well. So it's fairly straightforward to figure out if transactions and schedulers are two-phase locking or not. And if they are, as I said, two-phase locking, all of them, then the scheduler is going to be conflict serializable if it follows the rules for locks. So, as a summary, this was a simple way to implement conflict serializable schedulers using these locks, and here we saw it for this online problem, which as I said is the right question to ask, because this is the one that the database management systems actually have to do. So the key thing with this lock was you must have the lock before you can access an item, and you should give the lock back afterwards, and only one person can have a lock at a time. So here we saw a basic binary of locks, and we saw this two-pl, and I claimed that this ensured conflict serializability. Yeah, here it was just a claim, but next I'm going to show you an argument for why this is so.
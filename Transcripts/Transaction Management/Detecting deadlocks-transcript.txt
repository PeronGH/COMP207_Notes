We are finally getting to how to deal with deadlocks, so in this video we will see how to detect them. So, basically speaking, we have these deadlocks we have seen earlier, where you can end up in situations and schedules where you cannot proceed any further. And we will in this video see how to find them, which will automatically let you deal with them. Because if you know which transactions there are between, you just abort one of them, and then hopefully one or the other ones can proceed. And you just keep on doing that until someone can do something. Let me go back a bit and talk about the strict two-phase locking we had seen in the last video. They had this nice conflict solitability property, because they were two-phase locking, and they had this nice strict schedules property, because, well, they are strict also. However, they still had the problems of deadlocks. For instance, if you had these two transactions started like this, then you could lead to a deadlock, as we saw in the last video. For instance, if you started with the first three operations from transaction one, then the first three from transaction two, then you wouldn't be able to get any further. And the only thing you can really do there is roll back and restart one of the two transactions. So, you see two techniques in this course for how to deal with this deadlock, and this being the first one is about detecting deadlocks and using that to fix them. And the other one is sort of a more general approach, where we'll enforce deadlock-free schedules directly. However, that later one is not going to be based on strict two-phase locking. So, in essence, we're going to see in the next video, which is going to be this enforce deadlock-free schedules, an entirely different approach to schedules than the strict two-phase locking that we have otherwise used a lot of videos on. There are three main techniques for detecting deadlocks, and we'll see each of them. The first two not so much. It will just be on this slide, but the last one we'll spend the rest of this video on. The first one is probably the simplest one. It's just to say that, well, if a transaction takes too long, it's properly deadlocked, so we should abort it and restart the save with twice as much time or something more time, so that you ensure you cannot just keep on restarting it, because it simply takes a long time to do whatever transaction it's trying to do. So, that's one option for detecting deadlocks. You just restart them if they take too long. It's very simple. Another one, which is also quite simple to understand at least, but is somewhat expensive in terms of how much computing power you need for it. Well, you need linear time to do it, is this one. The nodes correspond to transactions in our wait-for graph, and you have an edge from one state or node to another, if transaction one waits for transaction two. So, then you have an edge from transaction one to transaction two. And a deadlock is then a cycle in this graph. So, for instance, here we have transaction one waiting for transaction two, who waits for transaction three, who waits in turn for transaction one. And this cycle is then the deadlock. The way you then ensure that the deadlock stops is you just pick out one member of the cycle, say transaction three, and restart it, because then transaction two, the one that points to transaction three, can move forward, and hopefully this will resolve the deadlock. The last one, and the one we'll spend the most time on in this video, is something called timestamp-based approaches to detecting deadlocks. So, let's see how this timestamp for deadlock detection works. We will in the next video see some other kinds of timestamps. They work slightly differently. I will try to highlight the differences both here and in the next video, because it's a bit subtle otherwise. So, each transaction is assigned a unique integer, TS(T) for the transaction T, upon arrival, and we're going to call that the timestamp of transaction T. So, if you have time running here, and transaction one arrives here, then it gets a timestamp. Let's say it gets timestamp one. It doesn't need to be one. It can be any integer. However, it must satisfy that if it arrives before some other transaction, transaction two, then we require that the timestamp of transaction one is strictly smaller than the timestamp of transaction two. So, just to have some way of saying it, if transaction one arrives earlier than transaction two, we say that transaction two is younger than transaction one, because it has lived for shorter time, and transaction one is older than transaction two, because transaction one has lived for a longer time than transaction two. So, we might have, say, T2 comes in after transaction one, and therefore, because of this requirement, the timestamp should be higher. Let's say it has timestamp two. Then we might have a timestamp for transaction three, which arrives at the same time as transaction two, and it might also be the obvious one, namely three. It's fine if they arrive at the same time that they don't necessarily, if one is older than the other one. We're still viewing them as one is being older than the other one, based on their timestamp number, though. So, later on, we might have transaction four arriving, and let's just give it a number four, because four is bigger than three, and transaction three started before four. And then some data points we might have that transaction two aborts, and then finally restarts. But because transactions get assigned their timestamp number, and upon arrival, when transaction two restarts, it keeps on having its timestamp as two, as it had earlier. So, here I want to highlight that timestamps do not change, even if you restart. And this was what I meant earlier, that I wanted to highlight. Here, in timestamp-based approaches for deadlock detection, it does not change after restart, but in the next video, it will change after restart. I will highlight it again, because people generally end up forgetting it, if I don't highlight it enough, I guess. So, yeah, this is the principle of timestamp for deadlock detection. You just get a number when you arrive, and if you arrive earlier than someone else, you have a smaller number than he does. So, how do we use these timestamps to prevent deadlocks? Well, we saw earlier that a deadlock corresponded to one of these cycles in a wait-for graph. So, for instance, transaction one might hold a logon item X1, and wait for logon X2. transaction two might hold a logon X2, and wait for logon X3, and so on. And transaction n might hold a logon Xn, and wait for logon X1. And that will give you the cycle here. And that cycle is bad, we need to stop it somehow. The way we do it is we use timestamp to decide which transaction can wait more, and which must be aborted to prevent a deadlock. So, basically, if you want a simple rule for it, in some sense, we'll allow the young ones to die and old ones to live on. Which sounds a bit harsh, but that's how it goes. So, we have two schemes based on this timestamp-based approaches for detecting deadlocks. The first one is called wait-die, the other one is called wound-wait. And in common for both of them is that the old transaction survives, and the young one dies, in some cases at least. So, in the wait-die scheme, which I want to talk about first, older transactions always wait for unlocks. So, the pattern is like this. If you have a transaction T1 that waits for a transaction T2, that means that T1 requests an item that is locked by T2, then they have two cases. Either T1 is older than T2, as in has a smaller number than T2. In that case, T1 is allowed to wait further for T2 to unlock. We can also have the other case that T1 is younger than T2. In that case, T1 is called be-rolled-back, and it dies if we use the naming convention from the scheme. So, this means that we cannot have a cycle in our wait for-cuffs, because at some point in the cycle, we must go from being, we must have the smallest, or the smallest number for a transaction, for its timestamp, and therefore the next one must end up dying, because it points to one with a smaller number. So, therefore we cannot have a cycle, and therefore we cannot have any deadlocks, and that was what we wanted. And this was the wait-die scheme. So, let's look at the other scheme for preventing deadlocks that's based on timestamp-based approaches. It looks like this. Intuitively, older transactions never wait for unlocks. So, again, we have the same setup. T1 is waiting for T2's item, and if T1 is older than T2, T2 is going to be rolled-back, unless this is already finished, is wounded in that case. Notice here that in this case, T2 might die, and in the other case, T1 might die. In wait-die schemes, T1 might die. In wound-wait schemes, T2 might die, and this is the key difference between the two. And if you want to remember it, and you probably should for the exam, that's what you should remember. In case 2, if T1 is younger than T2, then T1 is allowed to wait further for the T2 unlock. So, basically, in case 1, T1 ends up shooting T2, and in case 2, T1 is just a young one, so he's allowed to wait more. And again, only younger transactions are allowed to wait here. So, again, we cannot have any cycle dependencies, because the oldest transaction is always allowed to move on. You can never be forced to wait, because of this deadlock prevention scheme. Let's try to formalize what I just said about the wound-wait scheme. Let's formalize that eventually any finite number of transactions are going to finish under wound-wait. So, the principle is simply that the oldest transaction can always move forward, no matter what happens in the wound-wait scheme. Hence, at some point it must finish, because each of them only takes finite time. And at that point you have one less transaction, and we are still doing wound-wait, and therefore the next one will finish, the second oldest one, and so on. Eventually, all the transactions finish, and we are done. So, you can do similarly an argument for wait_die, but there you're going to look at the oldest transactions, all the transactions it recursively waits for. That transaction can always move forward, and therefore it's going to eventually finish the oldest transaction, and therefore we are done. So, let me summarize this video. We have seen three approaches to finding deadlocks, and how to solve deadlocks. We can use timeouts. There's the file assembly. If you have spent sufficiently long in a transaction, it's probably deadlocked. You should restart it. You can use this wait_forecast, where you plug in precisely who is waiting for whom, and then cycles corresponds to deadlocks. However, they are quite slow to update them, because it takes linear time to find such cycles, which is too long for this kind of low-level operations as transactions are. So, we are not doing that typically. Well, some are really, some database management system, but I will talk about that later. Finally, we especially focused on timestamp-based approaches, where basically the young always end up dying. So, if you have transaction 1 waiting for transaction 2's item, then in the wait_die scheme, if T1 is a younger one, it should be aborted in this situation. And in the wound_wait scheme, if T2 is younger, then it should be aborted. So, in all cases, one of them is going to die, and is always a young one dying. In the next video, I will talk about another way to use timestamps, but where we basically implement all of these many things we have seen with strict two-phase locking, just in one short video. So, it's sort of a simpler approach to two schedules. And these schedules will ensure automatically that there exist no deadlocks.
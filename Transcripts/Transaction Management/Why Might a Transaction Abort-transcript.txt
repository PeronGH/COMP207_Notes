I want to describe in this video why a transaction may abort. So there can be a bunch of reasons why it might do so and we will see a few different types of reasons why it might do so and then we will focus on one specific type of a reason why a transaction may abort and this is the one we're going to show in depth how we can get a database management system to cover. The others are in either in some sense not our problem or quite a bit easier. We will see what I mean by both of these things towards the end of this video. So before doing that I want to point out that we just talked a bit about concurrency control in the last many videos and now we are going to focus a bit on lock-in and recovery and therefore it makes sense to explain why it might be abort because well this is a kind of problem. Lock-in and recovery is made to deal with. So as I said we're done with this concurrency part for now but we'll be back later. As I mentioned in the last video there's a few issues we haven't cleaned up yet like deadlocks and something about isolation and the next many videos or next few videos is going to be about this lock-in and recovery and then we'll get back to the combination afterwards. So we'll cover some different ways a transaction may abort. Let's look at the first one. We could have an error while executing our transaction. So for instance we could violate some integrity constraint like this text we've seen earlier in the basic SQL part or a variety of other one-time errors. Let me come up with an example of this kind of problem. So let me take an example of what we've seen. This is problem one concurrency from the video on the cool_scheduler/transactions. So we have this flight database with the flight number, date, seat number and seat status and we search for which seats are available on flight 1, 2, 3. And we do it with this query. So we select the seat number from the flights where the flight number is 1, 2, 3, the date is Halloween and I made a mistake and I'm going to change it. This should, this third issue of course, 31st, to make self Halloween and then set the seat status to available. I'm not going to go back and change it, that's why I'm not going to change it here. And we should then book a seat, say 14B. And we could book that seat using this query here where we update the flight, set the seat status occupied on the flight, on that date and well seat number is 14B. And then we could have another user coming in basically at the same time and making the same query. So he finds the seats on flight 1, 2, 3 and books the same seats. Now if you have a constraint saying, or a check saying, there can only be one person sitting in the seat, that check will then be violated if you make this query. That would therefore be an example where we'll get error methods back and should abort this transaction. Our example we saw in the first tutorial, we had constructed this bank example in the exercises. And now we had a bank account where we put a requirement that there should be at least some amount of money on a bank account. And again if you violated that constraint, that will come an error and we should abort a transaction and go back. So that would be one type of reason why a transaction may abort. Yeah, so this is a problem here was that it laid an inconsistent database and therefore we undid it. So let's try to find other reasons why we may abort a transaction. For instance, in the last video we discussed state-locked, like in two-phase locking. And there the concurrency control goes in and says, well there is a problem here. We need to abort one of those transactions so we can basically clean up this state-lock. This is how we're going to solve it later. As I said, this is something we'll get back to later. But again this is a reason why you might get a transaction abort. Here is the concurrency control doing it before it was, well, in some sense a transaction or depending on how you viewed. So we already seen an example of that lock. We had these two transactions here. And if you started with doing the first part of transaction one, then did the first part of transaction two, then there wouldn't be any way you could move on from here. This was this basic example of a deadlock. And as I mentioned earlier, it's still present in all of this volume of locking we have been seeing here. Even though this update locks in parts will solve some deadlocks, but not this deadlock here. So here we cannot go any further. We see both transaction two will not be able to do the next line, because transaction one has a lock on X, and transaction one cannot go further, because transaction two has a lock on Y. So we are deadlocked, and there was another reason why we might be able to, and might be required to abort, so we can get out of this situation here. Then we'll abort one of them, and then the other one can continue, and we can finish it. So as I said before, we will come back and deal with deadlocks in a bit, but not yet. Another reason why we might have an abort is because we get an explicit request about aborting a transaction. The others will have an error and some bad interaction between concurrent threat, but a transaction can also say directly "I want to abort, something bad happened, I didn't want this to happen". So for instance, you could start a transaction. We could do this concurrency one problem again, where we insert into seed reservation some custom IDs, some seed number, this 14B on flight 1, 2, 3 here, and Halloween, when again I missed the one here, and again I'm not going to update it, because I wanted to be consistent. And then we have some additional code, and when we say "Okay, something bad happened, I didn't want this to happen", then we can make an explicit request about undoing all the changes by saying "go back". Again, this will cause us to abort the transaction, undo everything, and then start over on a new transaction, maybe. So again, this is a reason why a transaction may abort, and again we should be able to undo changes here, and this is sort of the key thing. So if you look at all of these three reasons, there's basically the same type of abortion. It's things that are in the control of the database management system. Now, nothing has been lost here. It's not a problem in the computer. The database management system in some way gets a request to abort it, but the computer is still running fine and so on. That's sort of the opposite of the kind of reason why we see next. So, we've just seen three reasons why our system might fail, while the database management system might still continue running. Like, if you get a request of aborting a transaction, I mean, the database management system is still running, you just undo whatever you're doing there in the transaction, and things are fine. But there can be worse kind of failure that are beyond the control of the database management system, and it might destroy your database management system's state in some way. Let's look at some reasons. You might have a media failure. Your hard disk might get destroyed in various ways, while running the system. Like, some reasons some chains of bits might have occurred. This can be detected in various ways, and if you detect that, you should probably get a new hard disk, or get a backup, and stuff like that. The hard disk hit might have crashed in some way. Again, it makes it hard to read the data on the hard disk. In that case, if you have a head crash, you can get it back, but it's quite expensive, and you might, again, you need to get a new hard disk, and get everything back out also. Another more extreme version of it would be, well, not just the hard disk broke down, but for some reason the entire computer got destroyed in some event, like, there might be an explosion, there might be a fire, things like that might happen, and that might cause your computer to get lost. Yeah, again, it can happen. It's not especially likely, I guess, but in some sense it's an event, and it's the reason why your transactions might get aborted, at least in general. Not that likely, but again, it didn't. A bit more normal event would perhaps be that you had a power failure, say, or there was a software, or stuff like that, and your database management system crashed, and you have to restart it, and get it up and running again, with all these changes, and stuff like that, to get it up and running in a reasonable state. So, how do we get back from a media failure? Well, if you had this crashed in some way, we need to have a backup. It makes sense. There's different ways we can have a backup. We can, for instance, have stored an archive of all your systems. For instance, people are often using tape recording still for this kind of thing, or CDs or DVDs, whatever. So, you can have basically two kinds. You can have full backup, or kind of incremental, or typical, you have some combination of them. So, what a full backup means is that you store everything on the hard disk in your backup, and as said, incremental means that you store sort of the changes over time, and that allows you sort of to restore the last version by just redoing all the changes. So, typically, what you do is, you do a combination of the two, you store a full archive of, at some point, and then you store the changes on that point up until the next point, where you store a full version, and then starting with small changes again. And this way, you can have sort of everything backed up without having to do too much work to restore the database afterwards, because incremental is more expensive to restore than a full backup. There's also other kinds of backups you can have. You can have just the same hard disk stored on different computers, and everything was done on one computer, is also done on another computer, somewhere else. It should be fairly safe if one computer got, a hard disk got destroyed, it's unlikely that the other one is destroyed at the same time. Another thing could be something like wait control. This is basically having multiple copies of the same hard disk stored in the same computer, maybe spread over some number of hard disks. Just think of it like saying you have two hard disks, and one hard disk is storing a copy of the other hard disk. This is sort of one level of the thread control, the other level of thread control, where you're doing a more complicated fashion, but if you want to know more, I suggest you just read up on it on your own. So, that's how to deal with media failure. Let's move on to more catastrophic events. So, I mean, if you have an explosion, your computer is physically gone, what do you do? Well, the only thing you can hope for is that you had a backup somewhere else, or have stored it in some safe way in the location. I mean, if you had a physical safe, you might be able to handle an explosion or a fire, or you might have two physical locations, say here in Liverpool, you might have a server in London, you have another server, and if the catastrophic events like an explosion happen here, it's unlikely that at the same time there was an explosion in London. Or, if you're afraid it happens two places, maybe you want three or more places. And again, the more places you have, the harder it gets, or the more unlikely it gets that you get an explosion or similar catastrophic events at the same time at the different locations. So, basically, after you have done this kind of thing, you have some version of your database hard disk up and running again. And at that point, we are basically left with the last kind of errors, the system failure. So, here we have the hard disk, but the active state as in whatever was in the RAM on the computer has been lost, and we need to get from the physical hard disk back up and running again. So, the main thing we'll deal with in this course is the situation where you have a quest, the system in some way, and we need to get from there to up and running again, as in getting everything up from the hard disk and up and running. So, as a summary, we have seen six things here that can cause errors in various ways. We have three, three, which are under the database management systems control. We have seen errors while executing it on sections like "A check that failed". We have seen deadlocks, especially last time, for instance, because of this two-phase locking and making a mistake. And at that point, the concurrency control is going to request an abortion of one of them and undoing that one, and we'll later see how to do that. You might have an explicit request about undoing whatever we're doing by using this rollback command, and of course, again, we are dealing with that one. If the file is tried forward, when we get one, we just undo whatever we're doing in this transaction. There's also things that are beyond the control of the database management system. Here, well, there are two types, basically. There's the first two I mentioned here, and the last one. In all of them, we're going to lose the state of the computer's RAM. So, a lot of the information we otherwise would expect to have are lost, and we need to rebuild the things. The two first ones, "Made your failure", where your hard disk failed, or whatever, in some way, and the catastrophic events where you had an explosion of fire. Well, we're not going to discuss how to get the hard disk up and running again. It's someone else's problem from the point of view of this course. But when you have the hard disk up and running again, with the same information as on the previous hard disk, we'll deal with it, and it basically ends up looking like this system failure, where the computer quest, and in some way, say, power failure, and we want to get it up and running again in a reasonable state, as in, we want to undo some things that are quest, and we want to redo other things that were already finished. So, we satisfy afterwards atomicity and durability. And that's sort of the goal of this call report.
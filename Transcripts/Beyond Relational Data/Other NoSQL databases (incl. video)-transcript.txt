In this video, I will discuss other kinds of NoSQL databases. So we have seen already one type of NoSQL databases, namely these key value stores. In this video, the lens sort of briefly skits the other three types, document stores, column stores, and graph databases. Mainly I will be talking about the document stores. Let me start by talking about document stores. They are, well as the name suggests, a database that stores a collection of documents, which is typically some kind of semi-structured data associated with some object ID. So you have an object ID and a corresponding semi-structured data set, looking something like this. So the object ID is typically automatically generated in some way. It could just be incremental or whatever, but typically automatically generated. And then you have a document which is typically represented in something called JSON, but you can just think of it as XML. We will later see briefly how to convert from XML to JSON. Before going more into this document stores, I want to show you basically what the difference between JSON and XML is, and for the purpose of this course, it's just a syntax thing. So for instance, you might have a database looking like this. We have students and student and name Anna, number, well her number, and program G412, end of student, and then the same thing for John. And this might be an XML database over students. So to write the same database in JSON, it would look like this. The main difference is just that the notation is somewhat shorter. So you don't exactly write this begin and end elements, you just write the begin part, and then when you end the corresponding thing, well that's the end of that element. So there's also one more difference I want to highlight. In JSON we have objects, which are the ones that are using the curly brackets. So this one is a student's object, and the one inside, as in the one with Anna, is the Anna student object, and the one named John is a John student object, and so on. And we also have the square brackets, which are used for arrays. So if you want to have an array of things inside your object, you write it like that. It mainly matters for how you access things, as in, if you want to change some element in this list of students, you need to specify which student you are using a number, and if you want to change, say, the number, the program of Anna, then you will need to specify program as basically the parameter. It doesn't really make too much difference, though. I also don't really expect you to remember this as an exam, but I just wanted you to see what JSON was, and basically just, for the purpose of this course, acknowledge that there is basically no real difference between JSON and XML, except that the notation looks a bit different. But let us get back to document stores. Let me show you a typical use case of one of these document stores. You might want to use it, for instance, for information about restaurants online, like, say, Google's third site for it, where you can filter the collection of restaurants by location and the ratings, and so on, and the amount of information you have about the different restaurants might differ between, well, different restaurants, as in, the kind of information you have and how much you have, and so on. And typically, you filter them first, you return the list to the user, and then the user selects one of them, and you then get all the information about that specific restaurant back to the user. So the first part up here ensures that you cannot just do key value stores, because you want to filter also in the value part, as in, in the part you have about this restaurant. And the fact that it varies also makes it a bit hard to do with using a relational database, and you might also be able to build to it faster by using this kind of NoSQL database techniques. Also, you probably don't want to use too much transactions anyway, so it kind of also makes sense from that perspective. So let us look at a specific example of these document stores, namely MongoDB. They are used for storing a variant of JSON, and you create and manage collections using this db.create collection students. It's basically similar to creating a database in SQL. Then you can insert and update/delete documents using this notation here, db.students.insert, and then insert some string of JSON, and you can find documents using this counter format. So for instance, the first of these two things finds the students that are in year two, the second one finds the ones that are at least in year three, and then sorted by year, and this one here means ascending. So yeah, notice here that this allows you to search more in-depth than what you can do in this key value store. And you can also do things like aggregation, as in summing things up or taking the average of things and stuff like that, or maximum, or things like that, using similar kind of notation. So one of the key things here is in MongoDB you can have index on one or more fields of your document, which is in contrast to a key value store, where you can only have the index on the key part. So here we have an object ID and some kind of documents inside, and then you can create an index, for instance, on the name. Here again, as I said, this one means it's ascending index. You can also create, well, it's not really that relevant that it's ascending when it's only one part, but it becomes more relevant when you have multiple parts, as we have seen earlier. So we can write tb.students.createIndex in program ascending and here descending. And again you can extend that as however much you want to create more complex indices. So how are MongoDB doing all of these things we saw earlier about, for instance, sharding or horizontal fragmentation? The idea is that you split your collections, as in say students, into horizontal fragments, as in this bunch of students here, this bunch of students there, and then based on the shard key, which is an indexed field that exists in all documents, you split them out. Like say you might have the student ID, might be your shard key, and then based on the student ID you split them out over your different, different nodes. And then you can have application, and the way you do that is that you replicate entire fragments of collections, as in the ones you split out in the first part, using a master-slave approach, where you have one primary copy, the master, and a bunch of secondary copies, replicas, and on updates you just tell the master to do the updates, and then that one will tell the replicas about this update. And again on reads you are asking the master version of it, at least by default, but you can also set it up to be able to ask any replica of the system for whatever they'd have about this or that update. So, and this is a relatively new thing, well at least to a degree, ACID is supported nowadays in MongoDB, in, from the last version onward, which was 4.2, from this late last year. That said, isolation is not quite fully supported, in that we only sort of do what is called snapshots, which is basically what you can do with this kind of multi-version concurrency control. So it's pretty similar to other systems like MySQL in the level of support for ACID. So let's try to move on to column stores. For instance, there are one by Google called Bigtable, which is a written one. Then Apache has an implementation also which is freely available called HBase. It's basically similar to what happened with MapReduce. So how it looks like is, well, it looks pretty much like a relational database, at least from an abstract point of view. So you have a table name, here a student, you have some row here, the first row is about Anna, and you have some columns. For instance, here we have an email column. But the sort of the difference here is that we have something called a column family. For instance, this would be a column family. And each column family has some qualifiers inside. So for instance, a qualifier on the contact would be an address, a qualifier on a name would be a first or last name, and similar for other things. And then we also have cells in here, and again that's of course similar to normal relational databases. Now the fixed part here and why is not just a relational database, is that the table names are fixed, and the column names, another column families are fixed, but the column qualifiers can vary from row to row. And the columns are referenced as follows. You reference a column family, colon, then one qualifier. So for instance, to reference the email column, you will say contact, colon, email. So let's look at a specific one. Let's look at HSpace, which is the one by Apache. You can get it freely from the website there. It uses a Hadoop distributed file system, which was also mentioned earlier in the MapReduce video, for those of you who watch that one. And you can create tables using create student, name, grade, and program. And here name, grade, and program is then these column families, which as I said are fixed from the beginning. And you can insert rows like this, put student and then row one, name, colon, fname, comma, Anna. That will insert a row in row one with the name of the fname of Anna, and then you can next insert into this row one the grade in COM 207 of 100. For instance, something like this. And that's how the format looks like for this kind of insertion of rows. And you can find information in this database by writing get student comma row one, for instance, to get all the information you have about row one in your database. Or you can write this scan and then student if you just want the full table. So it's fairly straightforward, but again different rows can have different attributes, like some might not have a first name, then you just don't write this, then you just write name colon l name for the last name, but don't write the first name, and so on. So you can have various number of columns for each row. What kind of techniques are then used in this age space, for instance? Well, we have two levels of fragmentation. First we have a horizontal fragmentation, where we have spread out the rows, they're divided into regions, say some based on veins of the rows, and then we have a second level of fragmentation, where we do a vertical fragmentation, where we split out the different column families in different nodes. So you have one node, if responsible for some region of the rows, together with some subset of the column families. And we don't have any transaction support, but each item has a time step, and one can access past version of the database, if you set up for it. So for instance, you can, if you get the student one, then you will get something like this returned, where you get column and cell, and we have a first name for the student, which was Anna, we have a last name, which was Anna's last name, and so on. The final one I want to mention, and I'm also going to do it brief, even more briefly than the one for column stores, is this graph databases, and here each node in the graph corresponds to some entity, for instance, it could be Anna, or it could be a module like COM 207 in year two, and then each node has some information associated with it, as well as some errors going out pointing to other nodes in your system, or other states in your system, I guess, it would be better to say. And yeah, you can then make searches using SQL path-like query language, for instance in this Neo4j, if you're using that for your graph database. There's also points of indices and stuff like that. I don't really want to go too much into detail with graph databases, so I think this will suffice for it. It's about storing things in graphs. So in this video we briefly saw a bunch of other kinds of NoSQL databases, namely those implemented in MongoDB, these document stores, 8-space column stores, and very briefly, CAF databases like Neo4j.
In this video I want to talk about DTD. So DTD is a way of defining the format of an XML file as in the schema of an XML file. And we'll see here how to do DTD. In the next video we'll see to use another technique for it called XML schema. But basically the similar XML schema is just a bit more precise and a bit, well, everything takes up more space. So the simplest one of them is DTD or document type definitions. And it provides information about the structure of your XML documents, like what elements may occur in the document, what sub elements may occur inside that element, and attributes an element may have, and so on. So basically it's very much the schema of your XML document. So you included at the beginning of your XML document, and as I said earlier, this standalone in the first line of the XML documents is about whether you have a schema or not. So now we have a schema, so we set it to "no". Before it was "yes", when we did not have a schema. And then you write it like this. Yeah, smaller than bang, dog type, lectures, and then square bracket, and then square bracket the end, and then greater than. And this part here, lectures, is under root tag name, as in the name of the outmost tag you have in your document. And we then have our definition inside these two brackets. We will see in the next few slides how to write that kind of definitions. And it provides a fairly good trade-off between having a full schema and still being able to add in things fairly easily. You just need to fit the schema, or you need to change the schema somehow, so it fits whatever you're trying to do. So an example here for our lecture database from the last few times. Here we have lectures, and when we write "lecturer" in a parenthesis and then a plus afterwards, this "lecturers" is a root name, and this plus means that there must be one or more lectures inside this "lecturers" element. Next we have that a lecturer should have a name, a phone number, and a question mark, email, question mark, and teachers, and a star. And what it means is that name is required, phone is optional, email is optional, and you can have any number of teachers elements as either zero or any other integer number. And then we have definition of all each of these things, like teachers is something that consists of code and a title, and the next many things is just saying that the remaining things are leaf elements and have a text string inside. So this simple inside here means text data. Let me be explicit about it, as in let me define precisely what these different things you can write inside a parenthesis mean. Well, you write name of an element, and then you write either nothing, a question mark, or a star, or we also saw a plus on the last slide. So if you write nothing afterwards, the default means that it must occur exactly one time. You're not allowed to have zero of it, you're not allowed to have two or more of it. There must be precisely one of this element in your element. And then we have some options for how many repetitions we want. We have a star indicating either zero or any number of times, so if you have a star, you can omit the element, you can insert it once, twice, or any other number you may think of. A plus means that it must be there at least once, but otherwise you don't care how many times it's there, so it means one or more times. And a question mark then means zero or once, so you are not allowed to do, say, two of them if you have a question mark. It's either zero or one. We have also seen that we can define attributes as part of our elements, so how do we define that, that our element must have an attribute? Well, first you defined the element without the attribute, so if you want to define this module element, we write smaller than, a bang element, module empty, and then larger than. And of course this empty means that this module must be empty, as in we basically can just write the shorthand for it or write no content for it. And now we, in this case, in the example I'm showing here, want to have two attributes. We want code equal to comp 105 and title equal to programming patterns. So what you do is you just define the attributes and you do that as follows. After you've written this element, you can write a smaller than bang @att list for attribute list and module code, because we want to define an attribute for module. It's called code and then cdata means that it's the text data and then this colon implied means that it's optional. So this cdata set is a data type. I will show a few more on the next slide of data types, but this one was for strings and this implied was optional and the other options there was required, meaning you must write one. You can also write some value here. That means that you define a default value if the person did not write this attribute in. And you can also write fixed and some value, meaning that it must always be that value. As in, it's a constant. Let's look at what attributes we can put in. I'm not going to show you all of them, but just a few. So the first one is the one from the last slide. It's the cdata, meaning it's a point of text you can write in this attribute. The next one is an id and it's used to identify individual elements, so you can later reference them. And the way to reference is to use id ref or id refs. With an s on, the first one references one element, the second one references a list of elements. I will show in more details how it looks like on the next slide, but I just want to highlight here that in this id ref you cannot specify a specific kind of IDs. You're only able to say, well, it's some kind of ID we have here or a list of IDs that should be here. So yeah, it's not really the perfect tool for this kind of thing, but it's okay, I guess. Finally, the last type I wanted to highlight is the enumerate type. If you want to have sort of a list of things and then the user selects one of them, the type is written like apprentices begin, then the first type, then our vertical bar, then the second type vertical bar, and then the third type vertical bar, and so on, until the end where you're finished, you write an end parenthesis, and then this item can be either the first in the list, the second in the list, or so on. It's quite straightforward to do, but it seems like a reasonable thing to mention, because it's quite important data type. Let me go a bit more into details with these IDs and id refs and the ones with epsilon also. So, id alone allows you to define a unique key to be associated with an element that you can then use to point to this element later using this id ref. Id ref then allows you to point to one element with a designated key, and the id ref type allows you to point to multiple elements. So, the only difference is that the first one can point to one, and the second one can point to any number. So, for instance, if you want to specify that a department has a bunch of lectures and a department has a head with a lecturer, we can write it as follows. First, we specify that a lecturer has a staff number, and this should be this ID, and it's required, and then we write things like lecture staff number equal to two. That will define that this lecture element has the staff number two, and this is his ID, or her ID, I guess. Then next, we can define this relationship that the department has lectures by writing that the attribute list for the department has a staff, and that should be id refs, because there can be many lectures, and in this case I'm going to use implied, as you don't need to write it. On the other hand, you did need to write the staff member's ID when you defined that, in this case, because I wrote required there. So, the way it works is that you can, if you have staff with ID 2, 3, 5, and 7, for instance, then you can write the department staff equal to 2 space 3 space 5 space 7. That would be fine, but you could not, for instance, write 1 space 3 space 5 space 7, unless there is a staff with ID number 1. It's not really super complicated. Again, it's mainly similar with the ref version, that we just have only one of them, so you might write department head equal to 2 is valid, but department head equal to 2 space 3 is not valid, because id ref only allows you to write one ID. And again, department head equal to 1 would not be valid, if there was no staff number 1. So, how do we apply one of these DDDs? Well, there are two levels of validating our XML document. They are well formed and valid. Well formed is just sort of the basics. Any processor of XML documents should ensure it's well formed before starting to work on it, but valid is sort of the one where we check that follows the DDD specification. So, for us to work on a document, it should follow sort of certain rotational rules of XML to be well formed. All elements must be within one root element. Elements must be nested in a proper tree structure without any overlap, meaning that if you start inside an element, you must also end inside this element. And you need to escape certain characters, like smaller than, if you, if you want to use this kind of thing in a string. So, a validating processor is kind of what we want for DDD. It will not only check that the XML document is well formed, but it will also check that it conforms to the specified DDD, or we will also later see XML schema, in which case the XML document is considered valid. We can make XML files more structured by defining, well, a schema kind of thing for them, and we can do that in either DDD or XML schema. In this video, we saw how to do it in DDD, and how to validate, and so on.
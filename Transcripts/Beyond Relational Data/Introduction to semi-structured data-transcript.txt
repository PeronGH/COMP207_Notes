In this part, I will be talking about NoSQL databases, and they are commonly built on these semi-structured data, and therefore I will start by giving you an introduction to that. Semi-structured data lies between relational databases and entirely unstructured systems. So they try to take good parts from each of them and build a whole that's not quite a convex combination of the two. So let me try to explain what it is. So on one end, we had this fully structured data we have seen so far as relational databases, and that data has to fit a very strong schema, so you know precisely what kind of value you see in a given spot. And this allows you to make highly optimized queries and so on, like we saw in this query processing part of this course. In the other end, we have unstructured data that can be arbitrary files like images or music files or stuff like that, and they're characterized by not having this kind of schema. You don't precisely have a description of the structure of this data, and that means that programs that work with that kind of files will have to know precisely what they're looking at to get any kind of thing out of it. It doesn't work like our databases so far, where you can have these schemas and stuff like that. In unstructured files, you have no description of how things are structured and so on. In between those two extremes, we have this semi-structured data. So one extreme was this fully structured files, where we have a very complete description of the structure of the data. We know precisely what the meaning of each field is. We know precisely the data types and so on. On the other extreme, we have this unstructured data, and then we have a lot of flexibility in how to organize things, but we don't really know precisely what the data means, and it can be tricky to process this kind of files, because you need some kind of structure to do it. In between those two things, we have this semi-structured data. It tries to pick the best of both worlds. So, for instance, it has some kind of self-describing version of it, where you can figure out what it means, but basically what is written down. We will see some examples of it later. But it still has a lot of flexibility. If you want to add in new things, you just basically add it in, and then it's there. Again, we will see some examples of this. So basically, a semi-structured database can be thought of as a collection of nodes that are linked by edges. So basically, it's a graph kind of thing. And typically, it forms some kind of tree-like shape. So let me try to describe it. So it can look something like this, for instance. And the data is then found in the leaves, similarly to our B+ trees, but it's not as good as Sertzinger, and it doesn't have this strong balancing properties like B+ tree had. But again, the leaves has the data, and it can be things like strings, integers, or whatever you want. For instance, we might have John Fernley over here for that leaf. We might have Comp 105 for that leaf, and programming paradigms for that leaf. And other leaves might have other associated data. Inner nodes, so the ones that are not leaves, have edges going to other nodes. That's basically the definition of what it means to be an inner node. And each of these edges has a label, and the label tells you what kind of relationship these two nodes have. So for instance, the labels might look like this. So here we have from the root, there's two outgoing edges, same lecture, so they point to lecture objects. And from all other nodes, basically, the properties of what we were looking for. So this node on the left here, left lecture node, has two outgoing edges, name and teachers. So the name of this lecture object is John Fernley, and he teaches this course here, which is taught by John Fernley, which is not surprising. So the code for that course was Comp 105, and the title was programming paradigms. And again, this kind of thing, you can just make it up a bit like you want, and the structures are coming from these edges. We know what it means, because the edges are telling us about the relationship between objects. So finally, we have the root object. I mentioned it earlier, it's the one here on top. It has no incoming edges, it's the lone node with that property, and each node is reachable from the root. That means that you can go from the root, going to some number of edges, and end up any other node. Like we can end up in this programming paradigms node by going from the root down to the left and going to the lecture edge, then going right to the teacher edge, and then going right into this title edge. And that's all to the case for all other nodes, you can get in them somewhere by working from the root. Let me come with a bit more concrete example So here we have a database for each university, and we have a bunch of things pointed to from the root, and each of those objects might be thought of being whatever type the label was saying. So the top level children of the root are lecturers in this case, and they then point to things, and these things have the property of being in relationship with the lecture nodes. So the name is the name of the lecture, and so on. I want to highlight some details here. So for instance, John Fernle here has a phone number, but no email in our database. Similarly, Martin Geiring has an email, no phone number, and this is all fine. We can just make things like this however we want. We don't need to have that each node have the same kind of properties as every other node, even of the same type. We can just make it however we want. And if you find out that we want to say that Martin's course was taught in year two, well, we just add in an @, called year, on this teacher's node, that corresponds to his course, and write that it's year two. And you don't need to do anything else, and now you have a description that Martin's course is in year two. It's fairly straightforward, really. What kind of applications do we have of this? Well, it's often used for sharing things between companies, say, over the internet. So it's basically often text-based. You don't need to spend so much time talking about what the data means, since the data is self-describing, as in we have this kind of tree-like structure we just saw typically, and that will describe the data for you. It's often easy to process and manipulate. You can also do it by humans, but you should probably take that one with a bit of grain of salt, because, well, if it was very easy to do, then there wouldn't be much point in talking about it in this course. It's also highly flexible. As I saw earlier, you can just add in new things whenever you see the need for it, like this year two for Martin's module. It's also often used for things like word processing documents, like I believe this OpenOffice document file format is basically this kind of thing. It's used for spreadsheets, vector graphics, and stuff like that, because it's fairly self-explanatory what's going on. And more importantly, at least for this course, some number of database systems popular in data analytics and big data uses this kind of semi-structured data. We'll see some explicit examples of this later. So, yeah, this is basically the point of talking about it here, that the database systems build up around the semi-structured data. There are many forms of this kind of document, as in precisely how it writes down this kind of trees. We have XML, for instance, which will be a main focus here, extensible markup language, which is only for tree-structured data. Then we have something called JSON. I will also briefly show you a bit later in this part how that works. It's for JavaScript object notation. It's very similar, really, to XML. That's why it's not really talked about in what's here in this course, because, well, when you have described XML, you have basically also described JSON. It's often used heavily in conjunction with JavaScript. There's also simpler kind of systems like key-value relationships. This corresponds to very simple XML JSON documents, or very simple, really, also schemas in our relational databases. But, yeah, we'll get back to those also. The most general form of it is general graphs, and there's also databases for this. I will not talk too much about the graph one. I will talk a bit about the other things, though. So, yeah, I'll spend a bit of time on this XML, as I said, a bit on time on JSON, and a little bit on this key-value store, but not really much about this graph database. I will introduce them briefly, but not really spend so much time on it. Now, XML, JSON, and graphs are slower and more complicated in relational databases, but on the other hand, these key-value relationships are faster, but cannot do as many things as you can with a relational database. Again, we'll see that in this part of the course. So, in a nutshell, these semi-structured data is very self-describing. We don't need any kind of schema for them. The files will describe what they're all about to themselves. You don't need to write another kind of header files, like in C or stuff like that. They're quite flexible. You can just add or remove properties on the fly whenever you feel the need for it, and they're much less structured than these relational databases, where, well, what you have from the beginning is typically what you have at all times. Typically, semi-structured data forms trees or tree-like shapes, and that's basically pretty much it about the general framework. I'll focus in the next quite a few videos on XML, where I'll be only talking about trees in that case. case. [BLANK_AUDIO]
Here we will start looking at XQuery. So intuitively speaking XQuery is basically SQL for XML files. The simplest kind of XQuery expressions are XPaths. So any XPath is also an XQuery expression. So we also have more general forms of X queries, and we will see later even more general forms in this, but typically the format is what we call flower expressions, if L, W, V, R. So L is for let clauses. They are just sort of defined variables like let this doc be the content of the student's doc. So let's make a document over here. We have a doc up here, and then the for clause iterates over whatever element you're looking at. So if there are multiples of them, it assigns it first to the first one, then to the second one, then to the third one, and so on, just like for loops normally does in programming languages. So for instance we might have a student down here, and if you have more students it will sort of loop over each of them in turn. And these two things together are intuitively sent close to the form part of SQL. Then we have the where clause. Here we are setting the where the module is COMP 207. So say this one had a module with COMP 207, and unsurprisingly the where clause in flower expressions in XQuery are sort of the same as where clauses in SQL. Finally we have the return clause, where we say what we will want to return each time we look at some element in our for loops, or just once if there's no for loops. In this case we want to return our element name. So in this case it might be Anna, for instance. And this basically corresponds to the select clause in SQL. Again this is just a short overview on this slide. I will go into more depth next, and each of the different expressions, part of the expressions, in if a flower expression. So one thing though, as opposite to SQL, this is case sensitive, and you must write everything in lower case letters. If you write let in capital letters, for instance, on the first line, it will not work. That will come an error out of it. And it then after I run this query, it returns things in document order. Let us try to do it in Sorbet, just to see that it really works like that. So first we should write let doc colon equal to doc my doc dot XML for is in is/doc/university/student and where is/module is equal to comp 2 7 and then we should return is/name. And if we want that, we got Anna returned as the name of the student. Well in this case, one in the slide was because she was the only student. And here we also have John, but he didn't have comp 2 0 7 as a module. I want to highlight also this stuff about case sensitivity. If you write this in capital letters, you get error messages. It's also the case if you just write one capital letter, still error message. So please try to remember to write it in lower case letters, so that you get the right output. More generally, flower expressions look like this. We have a structure, we have the first four and let clauses. Any number of them, you can interleave them in any order. And then we have a where clause, and that's optional, similar to an SQL. And then we have a return clause, which is mandatory. You must return something at the end of your flower expressions. Now the most extreme example of this is of course just then to have a return clause. However, some interpreters, for instance the sawbar one, require us to have at least one let clause, and in that case it will end up looking something like this. And again, I mean both are just going to return greeting "Hello world!" no matter what document you're running around with, it doesn't really care about init documents. So let us see how it looks like in sawbar. Let's start by running this simple example here, this extreme case. As I said, this does not actually work, because sawbar requires you to have at least one let expression. So let's use the other one, which looks like this. And again, when we execute that one, we get what we expect. We get a document containing just greeting "Hello world!" and then enter the greeting tag. Let us go through the different clauses in flower expressions. Let me start with let, even though it's not the first letter in the flower expressions, that would be F for "for". But let is typically the one to use first, because typically you want to assign, well, your document to a variable. So what you write is let variable colon equal to, some X query expression, and that's basically the format for them. What it does, it is that it assigns the X query expression to the variable, exactly like in the examples we have already seen. So for instance, you can write let doc colon equal to doc mydoc, which is an X path that returns the document node of the mydoc.xml file. Or you can write let student names colon equal to doc university student name. So for the second one, of course, you need to define the doc variable first, like we did in the first one. Here in X query, variable names start with a dollar sign, so it looks like a dollar doc or dollar X, dollar student, or whatever, and that's just how they should look like. Next comes the "for" clause, the first letter in the flower expressions, and well, it's very similar to "for" loops in any kind of program languages. So you have four variable in X query expression, and it looks at each item in the result of the X query expression in turn, and assigns that to the variable, and executes whatever comes after the "for" clause. This could be, for instance, be more "for" clauses, it could be "let" or it could be "where" clauses, and finally there will be a return clause, and then you output whatever you have done up to the return clause. So some examples could be like we have seen earlier, for dollar sign S in dollar sign doc slash university slash student, that will iterate over all the students in our university database. Or for a dollar sign name in dollar sign doc slash student box module equal to comp 207 box N slash name, that will iterate over all students' names that has the module comp 207. Next we have the "where" clause, there you just have some condition inside the "where" clause, pretty much like you would expect, and evaluates the condition, and if it's true, then it executes the corresponding return clause. So it can, for instance, be a comparison between X path and a constant, like we have seen, but it can also be other things, we'll see of some other things on the next slide. So for instance, it could be things like "where dollar sign S slash module equal to comp 207", like we have seen, or it could be dollar sign S slash year above 2, again it's not really that complicated. It's basically the same kind of thing as you can write in X path inside these square brackets. So one thing you have to be careful about is that, similar to X path, we again use existential semantics here, meaning that we return "yes" if you can somehow make the answer "yes". We have some more general conditions than what we have been typically been seeing so far. Some of this did show up in one of the exercises in one of the tutorials so far. So, typically we've been seeing conditions on the following form. We have some expression, we have some kind of comparison about or on a constant, and for instance we have seen examples like dollar sign S slash module is equal to comp 207 on the last slide, or the same thing with year, equal to, strictly greater than 2, and here we use an existential semantic, meaning that if there is some module with the name of comp 207, then we return "true". If there is no such module, then we return "false". If there is one that are comp 207 and one which is not, again we return "true". And we remove the text around the element before comparisons. So, what happens if you use expression 1 and compare it to another expression 2? For instance, if you use dollar sign S1 slash name equal to dollar sign S2 slash name. Well, it's still going to be existential, so you just check if there is a way to get the same name on both sides, and if yes, you return it. If no, you do not return it. That said, some interpreters do not remove the text around name elements when you do this, so you have to be a bit careful about this in general. However, Zorba does it and I'm also going to assume it it's a case in the exam in case it comes up. You should just assume that this kind of expression removes all the elements text around elements. Let us try to do something like that in Zorba. So, here we have written "let doc be this my doc from before", and then we do over the students and we check where the module is different from the module. If you've seen the tutorial from earlier, you would have seen that in XPath this kind of thing would in essence end up checking that there are two different modules with different names, and if that's the case, you return name. So, here we see that Anna has two different modules. Here COMT 105 and COMT 207. If we change this to COMT 207 also, it will disappear because the two things are not different from each other at that point. You cannot find a path that has another value than another path. Similarly, if we took this one and put it down here by John, it will return him also. We also have some other kinds of conditions, again roughly similar to XPath. You can write an XPath or XQuery expression as a condition, and it's going to be interpreted as being a true expression if the result is non-empty. This is exactly how it's done also in XPath. So, for instance, you could write "where $is/module return $is/name", and it will return all the names of students who have at least one module associated with them. So, it would not return any that didn't have any modules. We can also write things like "some $is/value in an XQuery expression satisfies a condition", or "every $is/value in XQuery expression satisfies a condition", and these basically functions like "any" or "all" in SQL. So, for instance, we could write "let unidoc be doc mydoc XML", and for $l in unidoc, "university/lecture", so that will loop over the lectures, where every $m in lectures/teaches satisfies $m/year smaller than equal to 2. What it does is it takes each lecture, and it discards any lecture who has a module that is not taking place in year 2, and then it returns those lectures that are remaining, as in only the ones that have modules that here are smaller than or equal to 2. Let us try to do that in Sorber. Let us try to do that in Sorber also. So, here we have this first query where we are doing an XPath expression here in the where clause, and it should return the students who have some module. In this case, both Anna and John have modules, so let's see what happens if we removed Anna's modules, and then it only outputs John, so as you can see, this is how it works. Let us try to do the other one where we said we looped over lecture, and we were testing that every module in /l/teaches satisfies that the year of the module was smaller than or equal to 2, and in that case, we returned the lecture's name. In this case, it returns Martin Geiring because he has a module he teaches come 2011, and it has a year smaller than or equal to 2. It doesn't return John firmly, even though his module was in the first year, because teachers didn't have a year here. So, if we had written year on also that it's a first year module, then it would also return John, and of course, if we had changed year down here and Martin Geiring to 3, it will stop returning him. So, in summary, the basics of XQuery are this kind of flower expressions, where you have four let clauses, which are basically similar to the fun clauses in SQL. You have where clauses, which is similar to where clauses in SQL, and you have return clauses, which are similar to slicked clauses in SQL, and of these, only, if you follow the standard, only the return clause is mandatory for some interpreters. For instance, Sober requires at least one let clause.
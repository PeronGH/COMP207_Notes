In this video, I want to show you some more advanced XPath. So basically, we will see some more advanced format for XPath in this video, with a few examples, and then in the next video, I will have a few more examples again, and a bit more advanced conditions, that we'll also see in this video. So a bit more general form of an XPath expression can look like this. We have "slash", "still", and then we write an axis, and then double colon, and then name of an tag, and name of an attribute, or a star, and then we do it again, and again, and again. So on the next slide, I will cover what this axis is, the attribute, so it can only be at the end. So what are these axes? Well, it's everything on this list here. I don't exactly expect you to remember them all, but I'm going to go through the definition carefully of what it means on the next few slides. So here, I'm just sort of giving you, well, one or two words summary of how to do it. Well, I guess up to five words, but otherwise, there will be a definition of it on the next slide, except for attribute, because that's not in these three versions of XML. So we've already seen two of them. We have seen the first two, we have seen attributes. Here you can just shorten it down to an "at", instead of writing this attribute, colon, colon. There's also a shorthand for child. It's because it's a default, you can just omit child, colon, colon. And then as a descendant, you can also, or descendant of self to be precise, you can, well, omit the descendant of self, colon, colon part by just writing as less. So that's how you do that. There's two more, there's parent. It's similar to how to do it in a file path. You just write two dots instead of parent. That's just fine. And you can also just go to yourself by writing a dot instead of self, colon, colon, and a star. So yeah, this is the shorthand for it. And as I said over the next few slides, I'll go through how the definitions really work, as in what they mean, like what does a child mean, what does a descendant mean, and so on. So the right way of thinking of these concepts is to look at a tree view of XML. So we have one of these three here. We look at this designated node. In this case, I picked the root, the one with the green cycle around it. And then the descendants, for instance, are everything you can reach by going at least one step away from you. And descendant of self is everything you can reach by going zero or more steps away from you. So on this drawing, this illustration, these are your descendants. So we can define some of the other notions similar to descendant. We can define child as being the ones that are one arrow away. So these are the green nodes, children. And we can define parent and ancestor in a similar way. Also, it's the same kind of thing, but moving in the opposite direction. So more precisely, if you are someone's parent, they are your child. Or if you are someone's ancestor, they are your descendant. So for the green node, it only has one parent and one ancestor. It's the top node here in the illustration. Let me come to the last tree. We have preceding siblings, which are the ones you get to by going to your parent and then looking at the sibling before you in document order. For the green node, it's these two here. So they have the same parent and come before the green node in document order. Following sibling is kind of the same thing, except it's in the other direction. So in this case, it's this one. I also want to point out that it's not the next node after that, because that next node doesn't have the same parent. So you really need the same parent to be a following sibling. It makes a lot of sense. This also means that you can never have any number of preceding and following siblings. It just requires your parent to have many children. Finally, self is yourself. In this case, it's the green node. And in general, wherever we put our self, that's the node that is our self. So this is a node. It might not seem that useful right now, but we will see in a few videos where... no, not in a few videos, next video, we'll see that it can be used in some examples when we talk about something called conditions, which will come later in this video also. Let us look at a few examples about it, and there will be more in the next video. So the first example is this /child::students/child::student/child::name. And here you should remember that you can omit child::, because it's a default value for the access. So therefore we get this path we have seen before of /students/student/name. Its file is tried forward, really. Now let's see something we haven't seen before. So we can write /student/* or equivalently, if you don't use this shorthand, /student/descendant or self::* and that will then output everything in the whole document, in some sense many times, except for the root node. So it won't output the students, text around anything, but otherwise everything will have a lot of text. We will see it on the next slide. We have /email. It will select all the emails in the document, no matter where they are. And we have /module/add* that will select all the attributes of all modules. Let's do it in Sofa again. We passed in our document down here. We write doc mydoc.xml, and then we write our command like child::student/child::student/child::name, press execute, and we don't get anything because name is an attribute of students. So we should have written attribute here. It won't work because we need still data. And then it will produce the white output here. Another command we could write was this student and then /* it will give us anything inside the student element. That means all of this here. And as you can see, that's all to what we get. Next one, /email. So we're a bit lazy. We don't really care where it is. We just want all the emails. There was only one here. It's ben@lib.ac.uk. And the last one we want to see was /module/add* Again, that wouldn't work, so we write the /data beginning and end parentheses. And it produces COM 207, COM 219. Notice we didn't have to specify how to get down to the module. It figured it out on its own because we wrote this /slash/. Now finally we get to the most general form of X-web paths. It looks like this. We have /slash/, axis, colon, colon. Then again, like before, it's a name of an attribute, a name of an element, or a star. And now we have this box bracket and then a condition inside. And we have the next /slash/, axis 2, colon, colon, element 2. And then again, boxes with conditions inside, and so on and so forth. And the idea is that this condition is true if we're then going to follow the paths further. So the basic form is, we can do comparisons. For instance, with equality is smaller than, greater than, smaller than equal to, greater than equal to, or not equal to. And again, you can also have the value can be a relative path expression or any constant. We will see some examples of all of this, because I'm sure it's not really that clear when I just say it. And we can use combinations of these things using AND and OR. So let's see how to do it. Let's try to figure out how it works. So an example of it could be /slash/book, square brackets, category equal to CS, end of square bracket, /title, that will find you all the books, titles, but only for books that had a category equal to CS. So if you have a category that's equal to something else, it will not return that. So let's see what it will return. We start here, we find a book element that was only one, then we check, does this book element have a category equal to CS? There was one path that will say yes, so it's true right now. This path to be precise, and therefore we're going to output the title as in this number one. So the output is going to be this one. It's nothing else, because I know all the books, so that's why it will give us this output. So let's do it in Zorba again. I have written the file down here. I've written the style of this doc, mydoc.xml, and now we should find all the book elements that has a category equal to CS, and this is case sensitive by the way. So if I wrote in small letters, it wouldn't find it. I will show it next, and then find the title of those books. So that will give you the right output. As I said, it's case sensitive. If I had searched for CS with small letters, it wouldn't find anything. So yeah, this is how it works. Let me come with one more example. In this case, I want to find all the products in category CS or sci-fi with a price of at most 30 pounds. So I write "++*", and then basically the entire command is in this bracket. So the bracket is saying category equal to CS or category equal to sci-fi, and price less than or equal to 30. Now what does it do? We start up at the beginning. We find everything with a category that CS or sci-fi and a price of most 30. So we see a CS here, we see a sci-fi here, and we see that both prices in this case match this price number. So it outputs the node from the left and outputs the middle node, and that's it. Let's do it in a swab again. Again, I've already set it up. So with the document down here and this doc, my doc up here, so I write "++*", and then begin square bracket, begin parenthesis, a category equal to CS or category equal to sci-fi. And again, remember it's case-sensitive, and then you write "and pi is smaller than or equal to 30", and then square bracket end. You press execute, and it gives you this output as in this part here. I will also give you the book element, because it's actually outputting the book element, and it's outputting the DVD element, this DVD element. So that's why you get that output. So that was it for this video. We saw some more and most advanced XPath expression, allowing us to move in many different directions up and down in the tree, and we saw some path conditions, how to specify them. In the next video I'm going to show you a few more path conditions, as well as a bunch of examples of all of this.
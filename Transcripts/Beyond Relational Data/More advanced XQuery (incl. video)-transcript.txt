In this video I will discuss more advanced X-queries. So we will see some more advanced X-queries. In particular we will see Group By, Order By, and Distinct. So Order By, we'll start with that one, it works exactly like in the SQL. It's not really that tricky. So we have the previous clauses and flower, like forward, let, where, and return clauses. And we insert the Order By here just before the return clause. So this could be for instance a query you could do with Order By here. We took the query we saw in the earlier video on examples and just ordered by author ascending, er, descending, sorry. And it has the desired effect. We're going to get first title and bin and then title and Anna, even though in document order Anna came before bin. Let us try to do it in Sorbet. So we write doc colon equal to doc my doc XML and then we loop through all the books. So for bin doc slash books slash book and then we loop over all the authors. And well, before we were returning the pair of B slash title and then comma author and and if we do that we'll get Anna first because Anna is before bin in document order. Or if we add an Order By, author descending and execute that, we get bin to be first in order of the output. Next, similar to how we had Group By in SQL, we also have it here in XQuery. So it's placed in between here, in between the Where clause and the Order By clause and I get the Group By clause. Now, similar to having in SQL, we can also have a Where clause after Group By. Here it's just called Where again. Let's see an example of it. So here let's try to count the number of students in each course. So we loop over this document of our university database from earlier and we loop through the students and here we group by the modules and we return the pair of mod and count the number of students. This seems fairly reasonable way of doing it. However, it does not work because we are not allowed to count things that are not a function of our Group By. Here at least. So the way we should do it, the way we should really do it looks like this. Here we are counting the number of module elements inside our student. So yeah, it looks like this. Now of course it does not do precisely the same thing as what we really wanted because if we have multiple of the same course we will end up in one student will end up counting that multiple times. But yeah, this is how to do it here. And we get what we wanted here. In this case we might have that Comp 105 is a twice and Comp 211 is a once in our example from earlier. So instead of doing count we can also do things like mean, max, array, and so on. Similarly again to SQL. Let us try to do it here in Sober. So we write let doc colon equal to doc mydoc.xml and we run over the module. So for mn doc/university /student/module we group by mod colon equal to him and we're going to return pair of mod and count him and if we do that and there was a final query from before we get the right output which was that Comp 105 had two students or had two or it was a twice and Comp 207 was a once. Now as I said, well I said two things I said there would be a bit of a problem if a student has the same element multiple times because here we count Comp 207 as being there twice because one student has it twice in their modules. Also let's see the earlier problem where we had /student and module and as I said, oh that's because this one wasn't declared. If we do it as on the slide we end up having atomization of grouping by atomize produce more than one item which is a problem of why we could not do it. So let's look at the next thing here which is about distinct values. So in SQL we had a keyword called distinct if you wanted to have just each element there once. Here in XQuery it's a function is called distinct value and before doing so it converts elements into just being the text inside the elements. So let's try an example here. We want to find the different courses that have been intended by some students. So we might try to write it like this as in just plug in these distinct values at the end and well it produces this output. So Comp 105, Comp 207 and Comp 105. This is not quite what we wanted. The problem is that what this really is doing is taking each time we want to return something and only applying distinct at that point. That's not really what we wanted. What we wanted was distinct of everything. So the way to do that is to wrap distinct values around everything instead of just around the return. And if you do that then you get a desired output of Comp 105 and Comp 207. Let us do it in Sober. So we write let doc colon equal to doc mydoc.xml and run over the modules for in doc/university/student/module and we return distinct values of M. And as I mentioned this doesn't quite produce what we wanted. We end up having Comp 105 twice and the reason is that it's just taking the distinct values of each time to return something. Of course here that's basically the same as taking, well not taking the distinct value if beyond like on the style that moved on up here. It worked properly. But let's see a bit more interesting example. Let's use loop over the students and take the modules down here. Again we get the same but if we had and I had Comp 207 twice it will still show up only once even though it will have shown up twice if we took just this query. So here we see Comp 207 was a twice. Now what has been in these videos is not everything about XQuery. There are other aspects that was not covered like branching like ifs and else for instance or similar. You will see some more in the tutorials but if you want to have all the details you can look in the specification in wv3-org/tr/xquery-31. There is a bunch of tool support for this. There are various XPath and XQuery processors available. There are online tools for it. There are command line tools, libraries. It's in various programming languages as well as built into a variety of database management systems in different ways. We will see some later why it's built in. It's also built in in typical SQL databases nowadays because one of the field types and we will see that in the next video is XML. And we have seen this live demo, this SOPR, which is fairly good for experiments but as we also have seen in one of the examples sometimes it makes mistakes so you have to be a bit careful about that one. And again as I said SQL supports XML natively. It's part of the standard. You can write fields for the data type nowadays and there are functions for creating XML from query results as well as for extracting data from XML stored in a database. So yeah in this video we saw a bit more advanced formats for XQueries.
This video is about the basics of XML. So XML is Extensible Markup Language, and in this video I will try to give you some informal as well as formal definitions of what it is. It's basically one of these semi-structured databases that are always trees. Okay, let me start by showing you how these XML files look like. Basically they are similar to HTML files. So for instance, this is the one representing the example graph I showed in the last lecture, the last video. The first line is basically saying that it is an XML file. So XML version 1.0 encoding UTF-8 and standalone. Yes, so yeah, the first part means that is version 1.0 of XML. Next, that we encode in UTF-8, and the standalone "yes" means that we don't have a schema for the file. So inside that we have a bunch of lectures here, a bunch of text really, and some text in between the text. So the text looks like this. They have this smaller one and bigger than surrounding some text, and specifically these are the opening text, the ones with nothing, windows less inside, and the closing text have a less in the beginning. And then in between these things we have an element. Of course this is also present then inside that. So for instance, this is another example of an opening and closing track, and the element. The earlier one was a lecture element representing John Fernley, and this is specifically the name of this lecture element as in John Fernley. So the boot element is a bit special. It's basically just the entire document like this. So let me talk a bit about it intuitively speaking, and then give you a more formal definition of it afterwards. So an XML file basically looks like one of these trees. Notice here, this is not quite the same example as last time. Here the node to the right, the one corresponding to Martin Goering, is a member of a new node which is called economics and computation, similar to John Fernley being a member of this economics and computation group. And they're not the same group anymore, or the same node anymore, because XML files are just trees. So if you want an intuitive explanation of what they are, think of them as a file system where the inner node are the folders, and the root is corresponding to the entire drive, and the leaves corresponds to the files. So the leaves are the ones containing data, that's the same thing as the files in a file system. So this metaphor works quite well I think, but there is one problem with it, namely that a child, or multiple children of node can have the same name. So for instance here, we have two lecture elements of the root element, and this is fine in XML, but it would be a problem in a normal file system. We'll come back later to, well, how to deal with this kind of thing. Or in some sense it's not really a problem, but still it will lead to some intuitive problems with how to search around the trees. Let me be entirely clear about it. In XML files we do not actually have nodes with multiple parents. XML files are always trees, but in more general versions of semi-structured data types, we do have these kind of multiple parents for the same node kind of trees. Well, it's not trees anymore, but tree-like structures. That said, we have a notion of references. We'll see it in the next video I believe, where you can basically say that this node should point to that node. It's basically similar to how shortcodes are done in a file system. It's still a bit of a problem though, even though it's not present in XML. It's a problem though, because it is present in many file systems. So for instance in Windows you can write mklink backslash j and then two folders. This backslash j is for folders and backslash h is for files. To say that these two folders or these two files refer to the same thing. Similarly you can do it in Linux or Mac OS. There you use ln and then source file and link file. And you must add a /s for folders, because otherwise you get something called a hard link directory loop. These are quite taboo and I've been told I will not allow to show you comics about that one. So you would have to look that up on your own. So let me be a bit more precise about what XML files look like. So basically they're made up of a bunch of elements like this one here, where we have an opening tag and a closing tag, and in between we have some arbitrary text. The opening tag is smaller than than a keyword, then bigger than, and the closing tag is smaller than, slash, the same keyword as in the opening tag, and then bigger than sign or don't. And in between you can then either have text or you can have more of these elements inside. So as I said, yeah, you can have elements inside each other. The nesting here must be proper, so you cannot sort of take, have one closing tag. If you start an element inside, you must also end the element inside. That's what this nesting must be proper means. The root element is an element that's not contained in other elements, but therefore also contains all the other elements. A well-formed XML document must have exactly one root element. So yeah, this is, this is a definition of what it means to be a real XML file. And this is basically the only requirement, except for this first line, as you saw on the slide, the first slide in this presentation. Elements, however, can also be empty, as in you might not have any text inside, in which case you can combine the opening and closing tags into one tag, which is smaller than the keyword, and then less, and then bigger than, and that just corresponds to having an opening tag and a closing tag just after each other, which is in keyword. And I also want to highlight here that keywords, or the elements, are case- sensitive, meaning that the keywords defining them are case-sensitive. So if you write "car" with capital C as the first tag, then you must also write "car" as the, with capital C in the closing tag. We can do one more thing in an XML file, namely we can write attributes. So each element can have attributes, which is basically just a name and a value, and you just put them into the opening tag of the element. So for instance here, this lecture element represents John Fernley, so we have said that the name attribute of this lecture tag is John Fernley. Inside we have a module element, and it's just one that just have no content. So we write smaller than module, and then we have two attributes in here, code equal to comp 105, the first attribute, and title equal to programming paradigms as the second attribute, and then class, and then greater than. And this is what then one of these, yeah, elements. Now each element can only have one attribute of a given name. So you can have any number of attributes, but only one attribute can be, say, code here. So you cannot have code equal to comp 105 and then code equal to comp 207 or something like that. That's not legal in an attribute for one module object or any element in your database. These are quite useful for this shortcut, as I mentioned earlier. We'll see it in a bit, more precisely in the next video I believe, when we get to data structures, how to define schemas for this kind of thing. So we cannot even typically use either an attribute or a sub-element for many things. So I'll come with some examples here of what to use for sub-elements and what to use for attributes or what can be used as both. So let me talk first about, say we have a staff ID of a lecture. This can be either of these two things. This can be either, because, well, there will always only be one of them, so it doesn't matter if you put it in as an element or as an attribute. You can do either, it would be fine. However, you typically shouldn't use email addresses as attributes, because each person can have many email addresses and you're not allowed to write more than one email address as an attribute. So yeah, this is sort of the difference between attributes and elements. So this topic is not so important right now, but it will be important later and it is part of the XML files, so I figured I better define it now. There is something called document order, and this sort of defines how elements in an XML files are ordered. So, well, it's fairly simple really, they're just ordered as their core in the document, so it's part of the data representation. So as you look at the physical file, and whatever element comes first is the one that's first, or smallest, or whatever you like to call it. So let me try to show it here on example. So basically you just start from the top, move down, or if you look at the tree representation, you can sort of more in depth look at it. So you start in lectures, then you move into the lecture element, then you take the first element inside, which in this case was name of John Fernley, and then you move back up to lecture, because there was no other thing inside this name tag, a name element. Then you move down to phone, because phone is the second child of lecture, or the second line in the inside of the lecture element. Then from phone you move back up again, and then you move down to teachers, and move down to code, which is comp 105 here, move over again to teachers, because there was nothing else inside this tag, move down to title and programming paradigms, and move back up to teachers, and from them back up to lecturer, and finally back up to lecturers. So this is how you define the traversal of this XML file. Its file is trial-forward, it's basically just adept-first search, where you start with the child that occurred first in document owner. There's a few more features I wanted to highlight. The first one here is probably the most important for the course, because there will be a few videos on it. There's something called document type definition and XML schema, which can be used to define a schema for your XML files. We'll see how to do it in in the next few videos. And you have to do that at the start of your XML document. You have something called entity references, which was basically these short quotes I talked about. So for instance, if you wanted to say that Martin Geiring and John Fernle were members of the same economics and computation group, you need to point to one of them instead of just like now writing economics and computation on both of them, because right now it could have been two different economics and computation groups they are members of, if you just read it as a file. Now you can also do comments in XML. You enclose them in smaller than, bang, dash, dash, and dash, dash, bigger than text. So basically if you want to write a comment, you insert that thingy there and replace and with whatever comment you had. You can also pass information on to the processor or the application you're using your XML file for. For instance, if you want to use smaller than or bigger than inside your text, then it can be a good thing to define that the XML processor shouldn't really look too much at it and just pass it along. You can do that using something called C data sections. I don't really want to spend too much time on it, but yeah, it's an issue that comes up and that can be quite annoying if you don't take care of it. So as a summary, XML or Extensible Markov Language is an HTML-like file format that's conceptually similar to file systems, with some exceptions, and they look something like this. And as you can see here, the texts are not sort of defined beforehand, but they're just written down as whatever you want. And it's made up of bunch of elements looking like this.
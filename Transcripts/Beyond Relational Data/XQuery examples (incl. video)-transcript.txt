In this video I will show a few examples of XQuery and how it works and so on. The main point of this video is to see a number of idiosyncrasies of XQuery and how it affects how you're going to write a query in XQuery. Let me start with a very basic example which is something we have seen already in the earlier videos and then we'll make it a bit more advanced in the next few examples. So say we want to find the name of each student, well what we will write is let $doc, colon, equal to doc mydoc.xml for $s in $doc/university/student return $s/name. That will find you each student's name, its file is twice forward. And say we start here, go down, find s down here and this will then be the output on this query. Let us also now see how to do it if you also want the ID of the student as not just a name but a name and the ID of the student. We might think we could write it something like this, as in basically just writing comma and then $s/id and then also get the ID out. However this does not work. The reason is that you're not allowed to write it like this. That's a short version of it. It's similar to say in Java you cannot easily write this kind of double return methods. Our method has only one return and it's similar here in XQuery. You are only supposed to return one thing at one time. Well let's fix it in the simplest way possible. We just put a pair tag surrounded because now we are only returning one thing. Specifically returning a pair of name and ID and that looks good right. And this works perfectly. It does something at least. So this is a correct XQuery expression. We return some list of elements now in our return statement. And this is output we get. That might not be quite what we wanted in that notice that it's returning the pair of $s/name comma $s/id and an end pair. It does not return Anna and her ID. So it's not quite what we wanted. So how do we really do it? We need to put brackets around the things we want to translate into the proper output. And if we do it like this, I haven't put these brackets around, and what it does is it substitutes variables for their values. So what you're going to get on this query is this pair of $name Anna $endofname comma $id 123456 $endofid and $endpair just as we wanted. Let us try to do it in Swarper. So first let's start with the first one which was let doc colon equal to doc mydoc.xml and then for is in doc/university plus student and then just return the student's name. Now as we have seen before, because we have Anna and John in this file, we get both name Anna and name John back. Now we also wanted their ID or its colon number here. So the first attempt we tried was this one. Oops, I forgot to write S. And as I said, it doesn't work like this. So let's put a bracket around it and write pair. And well, now it works but outputs its name and its number twice because we have two students. So to get it really to work, you need to put this brackets around it. And if you do that, we get pair name Anna number and then Anna's number and pair name John and number, well John's number and number and end pair, just as we wanted. So let's try another kind of example here. We're looking at a books database. So we like to return all pairs of title and author in our books database. But of course, our book may have multiple authors, so we would like to return each of them. So here we loop through the doc file. We find we find each book in term and then we return the pair of the book title and book author. Now if you think back, or at least those of you that attended the previous tutorial that covered XSLT, there you saw that if we had a list as output as multiple things, it will just take the first one. It's not the case in XCRABY though. Here we get the full list as output. So when we write title, we get, well there's only one title, so we just get that, but multiple authors, so we get a list containing each of the authors in turn as part of our output. And this is not really what we wanted. We wanted the title together with the first author and title together with the second author in these pairs. So, well, obviously it's because we're not really asking for that. We're doing something for each book, so it's quite obvious that we'll get this problem. But it's mainly here to highlight that if you have a list, you don't just output the first one, you output the full list by just putting them after each element. So the way to really do it is to use multiple for loops. There was at least one way. I guess you can also just directly have done the author part and then go back. But one way at least is to do it using multiple loops, for loops. So here we loop over each book and then afterwards loop over each author and then output the title and author of this book. And this does what we wanted. We get a pair with title and Anna and one pair with title and Ben. Let us try to do it in Sorbet. So first we write let doc colon equal to doc mydoc.xml and then we write for BN doc slash book slash book and then we return pair of B slash title and B slash author. And if we do this, well, as you can see, we get this list of two pairs for the second part of the output. It wasn't quite what we wanted, as I said. So we should include another loop here over the authors. And if we do it like this, well, we get first the first pair, which is title and author Anna and then title and author Ben. This is a bit besides what we saw earlier, but just wanted to highlight that this was case-sensitive, as I mentioned at first. If you don't use case-sensitivity as a write-in-the-book case here, it doesn't work. Let us see a bit more advanced example where we're using this existential semantics of this path expressions. So here I want to return the pairs of titles such that the former is cheaper than the latter. We write two titles and the former title should be cheaper than the latter title in our database of products here. So the way you can write it is like this. Here you first loop over the things that have the pies in the document and a second time you loop over everything to find something that has the pies and then you check if the first pies is smaller than the second pies. And if so, you output the title of the first one together with the second one. Let us try to do it here in SORBA. So we write let doc colon equal to doc my-doc.xml and then we loop over the first in doc slash slash star. So we don't care where it is, but it should have a pies element and then we do it again for the second element and we check if the first pies was smaller than the second pies and if so we return the pair of first title and second title and end pair. Okay, so we get a whole bunch of output. What should we get? Well, if we look at it, we see that the first title has a price of two, the second book art cover has a price of one and four. It has two prices just to make it interesting. It was also on the slide and the film, which is the third thing, has a price of three. So what pair should we have? We should have the first title with the second book because there is one that's more expensive, so we have that one. We should have the first title with the film because the film is more expensive than the first title, so we have that pair and that's it for the first title. Now let's look at the second book art cover. We should have that together with the first title because it's the cheapest element also, both the most expensive and cheapest element depending on how much you want to pay for it. So we have this pair. We also have the pair of second book art cover itself because it's both the cheapest and most expensive. So again, we see this existential semantics here. We also show it with the other parts and we have the pair with the second book art cover with the film because there is one with a price of one, matching the smaller than the price of three. Finally, we are done with the second book art cover. We get to the film and that we're going to output together with the second book art cover because three is smaller than four. Now, if you're careful about it, you'll find that I actually have a book here in in the software. If you multiply all of these numbers with five, which should not really do anything, um, well, we get another result which we should not get. So if we just execute it again, we have multiplied each number here by five, so this one is still both the most expensive and cheapest, and this one is second cheapest, and this one is third cheapest, so we should get the same output. But we do not lose two of the pairs, namely the one with second book art cover being the first and then the first title being the second part. It should be before this. It should be after this pair and before this pair. And similarly, we also lose second book art cover together with the film. It should be just after this pair here and before this pair here. But again, this is a bug in the software. I have told them about it in this feedback thing. I hope they fix it at some point, but let's see what happens. But still, the original version with, um, two, one, four, and three here works properly. It outputs the right thing. But yeah, you probably should be a bit careful using the software for anything really sensitive. So what did we see in this video? Well, we saw the use of this bracket that was used to extract whatever the value was of some expression. For instance, if you wanted to return multiple things at once. We also saw a use from multiple statements and a bit more complex example at the end, including a bug in software. Yeah, but in the exam you should assume that software will do it. Probably you shouldn't try to figure out if there will be a bug in software for this other query.
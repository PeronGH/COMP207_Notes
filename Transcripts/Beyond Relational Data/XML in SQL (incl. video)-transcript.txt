In this video, I will show you how to convert an XML database into an SQL database, if you need that for some reason. Earlier, we have seen by example in this XML schema video how to recreate an SQL database in XML. And in this video, I will mainly go the other way. That said, I will also show the example again, because the video on the XML schema was not required. So, I will start with that. So, the example looked as follows. We wanted to represent some relational database using an XML document, and we will add in a DTD for it. So, that I want one correspondence between an XML document that conforms to this DTD and a relational database with that schema. So, one way of doing that is to write it as follows. We write this question mark XML version born standalone no, this DTD, and then student student name Anna, and number, her number, and program is D412, and then John and his number, and his program of 702. And this DTD over here then consists of students, and students consist of a list of student, and each student has a name and number on a program, exactly like in the schema on the previous slide. And a name and number on a program are just strings in this case, just to keep it easy. So, if you write the black part without the dots, of course, and with standalone yes, that will give you a well-formed XML document. And if you also include the orange part and have standalone no, that will give you a valid XML document that gives you precisely the same thing as this relational database we saw on the previous slide. And of course, you can do this with all kinds of databases. So, here I will mainly concentrate on going the other way as we start with an XML document, and we like to put it into our SQL database. There are three primary ways of doing it. We can store the entire XML document inside an attribute in a table, or we can store it in a schema-independent form, or we can store it shredded or passed over across a number of attributes and relations. And we'll see each of these three ways in this video. It's not that complicated. So, the simplest way is storing things as an attribute. In the past, you would have stored them in one with a data type of CLAP. As in, it's some kind of binary format, you wouldn't really specify it. But more recently, the XML has become a data type, so you just write XML or XML type, depending on your precise system. And it allows you to store more XML in civilized form, and allows you to insert documents into databases and retrieve them in the original form. Now, this has some advantages. It's fairly easy to do it, but it also has some problems. There will not be much optimization going on, as in, you will have to do parsing on the fly, as in, whenever you find an entry with an XML schema in, an XML document inside, you will have to do one of these searches to that schema after having found it in your database. And there will not be any index or something like that, because, well, it's just stored there as a bunch of text, in essence. Also, another annoying thing is that you want to update this XML document you store in your schema. You will need to replace everything, even if you just want to make a small update to it. So, we can define it like this. Here, create a table XML_staff. So, it's a doc number, it's a doc date, and some staff data, which is in XML format. And then we can insert into this XML_staff values something for the stock number, something for the date, and an XML file can be inserted like this. You start with XML, begin parentheses, and then write whatever you are trying to do in XML with marks around it, like when you write a string. It's fairly straightforward, really. So, that we saw storing it as an XML attribute in your database. Another way of doing it is to store it in a schema-independent representation. So, this is, as in the first one, has a drawback of not being that conceptually nice. You cannot really do index, you have to move everything in and out whenever you make a little change and stuff like that. But at least it's fairly straightforward, and it works reasonably elegantly. Here, well, there are some other strengths and other drawbacks. Here, we're going to store the XML file as basically a tree inside our database. And that's going to be ugly in other ways. So, since the XML is a tree structure, that means that we have only one parent for each node, we can just store it like that. And you're storing who you are together with who you parent are. That's basically the idea. And then you store the boot attribute also in a specific format, let's say with number zero. While this will give you something that doesn't depend on the schema of your XML file, the recursive nature of the structure can be hard to access and give problems for performance. So, for instance, if you need to go three levels up, you will in essence need to make three queries, at least if you do it in a naive way. So, we make a second schema that allows you to do it a bit faster, that basically creates a denormalized schema containing combinations of different paths and a link to the node and parent node for that path. We'll see how it looks like. So, an example here could be first we have here on the left that we have just sort of the content of the file. So, each node has who it is, as in the name of the node, as like student or university or whatever. So, it's the label on the edge that says node name. We have the node type. It's either a document, which is a full thing, or it's an element, which is an intermediate node, or it's a text, which has down and leaves. And then we also talked about how you get further up using this parent ID, and root ID will then tell you what is the root of this tree, so you can find it everywhere. Now, as I said, we also need something to be able to make the queries reasonably fast. So, we have a second schema containing the paths and where you end up if you have that path. So, this is in essence how you do schema independent representation. It has some drawbacks. Well, it's quite an ugly way of doing it, but it does allow you to store reasonably directly your XML file in your database. And, yeah, you can make a small change by just making a small change in your database. So, there is some advantages and disadvantages of doing it this way as well. The last way I want to talk about doing this is you can, well, basically do it right as an try to extract all the information from your XML file and put this extracted data into your database by spreading it over a number of attributes in one or more relations. I'm not going to come here with an example of this, but for instance, it would be like storing the student database from earlier by having a student table with a name, number, and so on. So, it's in essence extracting the information out of the XML file and putting the extracted information into your database. So, this allows you also to do things like index of some important elements, provided that these are put into their own attributes. And you can, again, if you want to have something, by doing this directly, you lose all the information about how things are stored precisely, but of course you can, similarly to the schema independent representation, also store some of the written structure inside your system. And that will also allow you, say, to update the XML afterwards and get it out again afterwards. Yeah, and this will do one of the disadvantages here. One of the advantages is that it works quite nicely, reasonably elegant, but it requires you to create an appropriate database structure. It requires you to think a little bit about what to do. The others are, well, you can finally automate the other ones. But here you actually need to think a bit about what your XML document is doing. So, in summary, we saw three ways of storing XML documents in SQL. We could do it as attributes. We could store the full XML tree inside the database and remember how to move around on it and so on. Or we could try to extract information from the XML file and store this extracted information in your SQL database.
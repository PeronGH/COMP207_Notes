This video is about more examples and conditions for XPath. So here we'll see some more examples, some other conditions, and the ones we saw in the one last video as a deeper than just a booleans. And I'm also going to wrap up about XPath. So I'll show you three examples here first. I want to show you an XPath expression that returned the titles of all books. One will return the authors of all books who have an ebook with a format of epoch. And then finally return authors of all epoch books with title databases. Let's see how to find all the titles of all books. What you do is you write this command /products/book/title. So that will find all the titles of all books. How does it look like? Well, we start in a root, go down to products, go down to these two book elements, and then we find the three titles of this book element. So it's this left node, it's the left node of the hardcover, the node on the second book, it's the left node of the ebook under the middle book. And that's it. Let's see it in SOPA again. I have inserted this doc, my doc up here, and a version of the tree under the site, except I have inserted some data in its field so that we can see some output. So we should write /harddocs/book/title, and we then get this output here, the first title of a book, because it was one of the books we found. We found the second book's hardcover version, and we found the second book, which was an ebook with the title of databases. I'm going to use that title because that will come up in the data query. The second example is about returning all the authors of all books who have an ebook with format "epop". So the command looks like this, /products/book, then square bracket ebook/format equal to epop, and square bracket /offer. So what it does is it goes down here in products, then go down to those books, and then it drops the left one because it doesn't have an ebook with format "epop", but this one might have this ebook and format here might be "epop", for instance. In that case, it outputs this author. So let's try it again in Sober. We write /products/book, square bracket ebook/format, and then it should be equal to epop. And square bracket end, and we should get the author. So we write it like that, we press execute, and then we get the author of the second book, which was correct, because the second book had a format of "epop". Let us try one more. Here we want to return the authors of all ebooks with title databases. So the command could look like this in this document, where each book only has one ebook underneath it. So what it does here is we start at the root, products, then we go to book, and then we find that we should discard the left one, because it doesn't have an ebook, but the right one does. So we go to that one, and this format, for instance, could be "epop", and this title could be "databases". And if they were, we're going to output this author. Let us try again in SORBAM. So again I've written the stock stuff up here, the file down here. So we write /products/book, square bracket, ebook/format=epop, and ebook/title=databases. And then end here, and slash, and then we can write author here. And when we press execute, we get the right output of author of the second book. Now, if we look at it a bit more carefully though, we will see that there is an issue with our solution to this example tree. We end up returning an author of a book that has an ebook of a format "epop", and another with its name "databases". So here, every book has only one ebook version at most, but because only the middle one has an ebook version. But in general, you could have that on multiple books that have different ebooks under them, and there could be many ebooks under the same book. And if one was named "databases" and another had a format of "epop", it will return that author even though in some sense it shouldn't, because that's not what we are trying to do with this command. There are, like SQL, many ways to write a correct command. Even if we looked at the last one as being incorrect, one way of writing a correct command for this query would be to write /product/book/ebook, then square bracket format equal to "epop" and title equal to "databases". And if you found that, go level up and then take the author element. Let us try it one more time in Sober with this mocowec command. So we could write /product/book/ebook, and then we could write format equal to "epop" and title equal to "databases". And then square bracket end and go level up and get the author. And if we did all that, we'll get that the second author of the second book is still the correct output. Now, if we had changed the second book, so that was one version had an epop format and another one had a database title, then the same command would not return anything. But if we had written the old command, which was like this, then the old command would still have outputted the second author of the second book. So yeah, we can see that this command, in some sense, the one we wrote earlier, was a bit more correct than the one we write right now. As mentioned, we have some more conditions we can do. So here's one of them. Instead of writing a boolean inside our square brackets, we can write our number, some integer. And it's true if the current node is the "i" child, "i" child of his parent, as in if you write "e" and then square bracket "i". So let's see some examples of this, because it's not quite as obvious. It might sound, I don't actually think it sounds that obvious. So it means "/*" and then "category = cs" or "category = sci-fi", that gives you some elements, it is poverty. And then we write afterwards, we write a new square bracket and then 1, it returns the first item in "cs" or "sci-fi" in the document. Another example, it's basically the same kind of thing. Here I write "last" in "p" again and in parentheses, and that gives you the last item in "cs" or "sci-fi" in the document. Because this last means the biggest number, that will make sense here. Now we can also write a bit more advanced concept, like "///book/category1=cs", that means that it returns the title of each book here, whose first category is "cs". So if it has multiple categories, it only looks at the first category. That's what this command does. Another example, you could write "//book1/following-sibling::*1", and it finds the book of the first book in document order. Because the first one gives you the first book, and the second one gives you the one just after that one. And we can also write the same thing with the preceding one. Here you have to be a bit careful, because now we work backwards, and this axis therefore is called a reverse axis, because even when we write "1", we don't mean "1" from the beginning, we mean "1" as we move backward from here. So this specific one, this axis here, works in backward order, it works in reverse document order, which is a bit complicated to understand. It doesn't mean it's outputting it in reverse order, it's still outputting it in document order, but this specific one here works in reverse order. Similarly, if you write "//*" and then a bracket and then this dot equal to a "mofs" and an "end" and then a "/ancestor::*2", then it finds whatever is your parent's parent, and not sort of, you don't start from the root and move 2 down. Even though your ancestors are everything above you, and if you did it in document order, it should have taken this second one from the root down, but it really just takes the one that's true up. It makes conceptual sense, but if you think of it as about document order, it doesn't make so much sense. So it, again, is one of this reverse document order kind of thing. So, let me be precise about it, these three here work against the normal document order, but still, if you use them, the output is going to be as in document order. It's a bit complicated to understand, I feel. So try to see if you can follow. Let us try to do it in Sorba also. So the first command for "//*" category equal to "cs" equals "or" category equal to "psi, phi", and this finds the first item that is in a category of "cs" or "psi, phi". So the first part here finds each item in category "cs" or "psi, phi", so that's basically a list, and this one afterwards finds the first in this list. So the first thing in category "cs" or "psi, phi" was this one with Title 1, so this one here. If we have written 2, we had found this one because it's the second thing in "psi, phi". Let's just see. It's the second thing in "cs" or "psi, phi", so that's why it will come in down. Similarly, the second one was about writing "last" here. That should give us the same, because the last one does not have category of "cs" or "psi, phi", and it did. How lucky. Now let's see some other commands. We can write "//book" square bracket category 1 equal to "cs/title", and what this does is it finds all books. It has a category where the first category is "cs", and then it finds the title of those books. And we see that the title here is 1, because this one has the first category of "cs", this book. Next one, we want to do "book1/following fitlen" colon, colon, star, square bracket 1. So it will find, you will take the first book with this part of it, you find the first book, and then you will find the next sibling in just after this book. So if you look, that should give us this 2D here. Let's see if we get it. And I was lucky again. I knew what to do. Let's see how it works with this preceding sibling then, that had this in a reverse axis. And here, we wanted to use dot, which was a self-axis. So this is, I think, one of the typical places where you use the self-axis when you use them in a condition where you want to talk about something that you have as a property. So what does this do? Well, it finds anything that has, that's called "moths", and then it finds the preceding sibling, the sibling just behind it. So if you look here, the thing that's called "moths" is this category here, and the preceding sibling, the one before it in document order is this one. So it should spit out "cs". Let's see. And, gosh, I was lucky about it, it still worked. Now we can also say ancestor for... Notice here that it has two preceding siblings, these two here, and it's still going to output this one when you write "1" because it's working in reverse order. So it's, I feel it intuitively makes sense, this is sort of what you mean when you want to talk about preceding siblings, when you want to talk about them in reverse order. But if you think about it as a document order, it doesn't make much sense. But let's see the other one, the grandparent of this one, just to see that this is also in reverse document order. So what is the grandparent of this math element? Well, if you go one up, we get to this book, and if you go one more up, we get to the store. So this should hopefully output everything. And it did. So that's how it works in Sorba. So there are two more kinds of things you can write inside one of these square brackets as a condition. I haven't mentioned yet, and I won't mention, and these are both on this slide. So the first type of thing you can write is xpath expressions, and it's going to return true if the xpath gives a non-empty note set. So for instance, you can write "//books" category/title, and that will give you the titles of all books that has a category. And you can write "//books[@pis]_end", and it will return a book if it has a pis attribute. So this is one of the kinds of conditions you can do, and it's fairly reasonably useful. The other one, well, it can help you if you're looking for things that are empty. So if you write a string inside one of the square brackets, it returns true if the string is not empty. So for instance, "//book@pis/data" begin and end parentheses will in Sorba return the books with a non-empty pis attribute. Let us try to do it in Sorba. So the first was "//book" and then "category" and then "//title", and it should find all the books that has a category of some kind. And here it finds us the title of the first book, because the first book actually has two categories. If we removed the categories, it returns nothing, because there's no books with a category. Let's go to the next one, "//book@pis", and it should return all the books that has a pis attribute. I have moved, as compared to earlier, the pis to be attributes now, just to work on this question. So here we see the first book has a pis attribute. And now we could also see the string version. So we add this here. It still returns the same one, because, well, this is a string that's not empty. So let's see what happens if we empty it, and it returns nothing. So, yeah, you can see how it all booked here in Sorba. These kind of path conditions also allow us to do a more elegant solution to this question we had earlier. So we want to return the authors of all ebook books with title databases. So before we had a lot to go up and down in our tree to do it, but now we can just use our condition in trailer condition instead. So here we say, "go from products", then we go down to books, and then we take the ones that has an ebook inside, that has a property that it has a format and a title of database for the title and ebook for the format. And if we find that, we output the author. While we have seen a bunch of videos now about XPath, we haven't really covered everything. We just covered parts of it here. So there are things like data types, there are text nodes to extract information from the leaves. There are other node tests you can do. There are a bunch of built-in functions, for instance, for arithmetic or do operations on strings or whatever you want. And well, I don't want to cover all of that. So I'll just say you can go and take a look on w3.org's page about it. This is full technical specification of XPath. And well, this standard is typically followed quite well. So if it says that something should have a certain property, it will probably have that property in the implementations. So what is the role of XPath? Well, in and of itself, it is not really a query language. Like SQL is a query language. XPath is just sort of to define paths around in your documents. It's used as an ingredient in our languages. We have already seen XML schema. But next we will see XQuery that again will be query language built with XPath as an ingredient inside. Basically what it is for is selecting items in an XML document. Let me try to illustrate it. So it's basically like attributes in databases and there the attribute selects items in relations. So for instance, we might say s.name or e.moduleCode and a similar expression in XPath could be this students/students/name or enrolled in /modules/code. And that will sort of correspond to these two things here. And again, this is a corresponding between SQL on one side and XML on the other side. But of course, XML version is somewhat more complicated because they have these more complicated data structures. So in summary, we saw a bunch more examples about XPath. A few more conditions like you can write numbers inside conditions. You can write xpaths inside conditions or you can write strings inside conditions. And we have seen each of these things and how they work.
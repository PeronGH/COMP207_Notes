Next, I'm going to talk a bit about something called NoSQL databases. So here we have an introduction to it, and in the next few videos, I'm going to talk a bit about specific kinds of NoSQL databases. So earlier in the course, we have seen a whole bunch of things about SQL and relational databases. And in the next few videos, I will talk a bit about other kinds of databases that are not primarily or not exclusively built on top of SQL. So NoSQL doesn't mean precisely that there are no SQL involved. It just means that it's not exclusively SQL, or it's not relational databases. Typically, they are aimed at web applications, so that you want very fast access to data with millions of users in parallel. We have seen examples of it earlier. You want some fault tolerance. You want some flexibility in how the data is stored, like this semi-structured data. But maybe you can avoid some part of ACID, at least to some extent. Or at least this is the thing that they have decided to cut down on, to be able to get some of these other properties. While it's typically used for web applications, it's not restricted to anything, of course. You can use it for whatever you want. It's also popular in big data analytics projects. And while it's quite important, it doesn't really replace relational databases. They're still heavily used, as has already been mentioned multiple times in this course. So let's see an example of what you could use it for. So say you have one of these web services. It could be, say, an online store, an online video game, or whatever. And you have sort of two kinds of data. Data where you really, really need to keep it compliant in a variety of ways. You need to keep it safe, like credit cards transactions, inventory, especially if you're talking to an online store, and all kinds of very important data, say, about customers or whatever. Otherwise, you will break this GDPR. This kind of data you need to keep very secure and safe. But there are other kinds of data you might be more accepting about getting not quite right always, like user profiles, precisely how the user has set things up, not somewhat about his personal things, but say his backgrounds, he'll be this color or whatever. It's important for the user, perhaps, but if you mess it up, nothing really bad will happen. The shopping cart, if it's not updated perfectly, I'm sure some of you have seen it on Amazon, it can also be fine. Again, messages or orders or things like this, it can be fine as long as it doesn't really mess anything important up. So, the left hand side, this NoSQL, we can do using NoSQL database, and we'll typically write it down like this, as in user one has this user information, he has this stuff in his shopping cart and stuff like that. On the other hand, the credit card transactions, the inventory and stuff like that, we will typically store in a relational database. Now, the NoSQL site is typically often quite simple queries, like just figure out what this user is, and given the value for the user, say the key for the user, figure out all the information we have stored about this user. So, it's just sort of look up one specific key kind of quote. And we can do this kind of thing quite fast by simply having an index on this key. And we can also relax ACID to some degree on this kind of thing, because, well, there isn't all that much interaction between different transactions and stuff like that. Typically, one transaction will just be about looking at one user. So, it will not really influence so many other users in a typical transaction like this. So, NoSQL databases are nearly always distributed over a network, similar to when we discussed distributed databases. So, it's run on community hardware or fischelf hardware, and it's using some kind of standard network of various kinds. And it is designed to ensure a bunch of properties, or at least some number of these properties. There's something called availability, which is that every non-failing note should always be accepting new queries, as in starting, it shouldn't be locking or anything. There's something called consistency, which requires that every read receives the most recent write or error methods. And I want to highlight here very strongly that this is not the same version of consistency as an ACID. This is sort of its own thing here. A consistency ACID is about satisfying constraints and basically, in our case, following serializability. NoSQL databases also grantees scalability. You can increase, get more capacity for use or storage by simply adding new computers into your network. We also want some high performance, which we just do by making things very simple. So, only say, allowing simple lookups based on keys and only allowing insertion of keys with the corresponding values. So, if we do things simple enough, we can do it even faster than what you can do using an SQL database. That supports really quite advanced stuff. Finally, we want something called partition tolerance, where if a bunch of node fails or messages fail, the remaining subnetworks, say the line between A and C in our illustration up here, if that broke down, then we have two subnetworks, one consisting of A and B and one consisting of just C, and they couldn't talk to each other. And we want each of the small part to work on their own, even though they're missing some information. And to do all of this, we typically end up giving up a bunch of ACID properties just to improve performance. So, and this should probably not be super surprising, I suspect. You cannot achieve all three properties or three of these properties at once. This consistency property, where the reads should get the most recent bytes. It doesn't really work that nicely with availability, where you should be able to answer queries all the time without locking and partition tolerance, where you should be able to break down smoothly, where different parts of the network should be able to answer queries as the full network. I mean, you cannot get all three at once. It was conjectured by Brevo in 2000 and shown by Gelbot and Lins in 2002. So you can only select two of those things at once and get those. A single node database management system, as we have seen earlier in the course, would have looked for consistency and availability. However, here we will typically either focus on a consistency and partition tolerance or availability and partition tolerance. So we are dropping, well, typically one of these constraints when we talk about this no SQL databases. And again, please remember that consistency here is not the same thing as an ACID. So when we do not do ACID, what do we do? Well, we do something called a base instead. What it means is basically available. So you should be able to answer queries nearly all the time. As long as your computer is running, we have some things called soft state and eventual consistent. So basically available should be fairly straightforward. Nearly always be able to answer queries. It's reasonably understandable. Soft state and eventual consistency might be a bit harder to follow. But what it means is that a database state might occasionally be inconsistent. The answer you get one place might be different from another place. They might not have all the information available everywhere. But sooner or later, the information and the system is going to be made consistent. So, for instance, this could be that database data item X has been updated, but the update has not yet been propagated to some replicas of this data. As we have seen earlier in distributed databases, I will talk a bit more about it in the next video. So what kind of databases are there in this NoSQL databases? Well, there's a common classification of them. There's something called a key value stores that only does, well, a very simple thing, namely, let you store keys together with values and let you find the keys very, very fast. So you cannot do any other operations and then given a key, given the corresponding value, or insert this key value pair into your database. This is the only two operations you can do in a basic key value store. And we'll spend some time looking at this kind of thing. Next, there's also something called a document store. It's, well, kind of the same thing as a key value store. Here the values will typically be some kind of semi-structured data, and you can involve a bit of lookup into the data that's stored beside your key. This is what is called document stores. Again, we'll see a bit about it. I will also briefly mention column stores. We'll see in the next few videos what it is, and GAF databases. Again, we'll see what it is later. Of course, this is sort of just a broad classification of it. You can mix and match a bit of these things together and get whatever you want. If you need something specific. But of course, to some degree you might end up having to do it on your own, if you want something very unusual. And you don't really have any specific of these that works for all purposes. Some works for some, others works for others. So, this was a brief introduction to NoSQL databases. They're trying to ensure availability, as in every non-failing node can always execute queries consistently, which is not the same as an ACID, where every read will receive the most recent write or an error message. It should be allowing scalability by simply adding new nodes into the system. It should be able to do this fairly fast, and it should allow high performance, typically done by just doing something very simple like this key value stores. We'll see a bit more about it in the next few videos, and some partition tolerance. So, even if nodes fail, the remaining subnetworks should still continue working. Doing just three of this fully cannot be done, and typically we'll mainly focus on availability and partition tolerance. So, we won't really use so much consistency, except that we eventually ensure consistency, using this basically available soft state, eventually consistency, base acronym stuff.
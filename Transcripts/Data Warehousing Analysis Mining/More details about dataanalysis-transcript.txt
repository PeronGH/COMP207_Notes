In this video, I'm going to go into more details about this data analysis I talked about in the previous video as well. So here I will talk about data analysis, specifically this technology I briefly mentioned in the last video, also this data warehousing, and we're also talking about a technique for doing this called slicing and dicing. So the first thing I want to focus on is that there's typically a unique fact table in one of these OLAP applications. This unique fact table stores the board strokes of the data we have on whatever object we are interested in for our analysis or event or whatever. So for instance, we saw in the last video an example of a sales database where the fact table will store the sales, save the product number, the date, the store, and the price. And you can then think of this as being representing a data cube. In general, it's not just three dimensions as we're going to see here, but it might be any number of dimensions. But here, because it's only three dimensions, I can draw it. So we might have one side, say, corresponding to the product or the product number. One side corresponding to the dates and one side corresponding to its store it is in. And then we have a bunch of points inside here corresponding to, well, each of these dimensions and specific locations. So each point here, because it's a sales database, will correspond to the sale of a product. For instance, this could be the price for the product with ID 67 on that date in the store. This might be for another product on another day in another store. And this one, because it's on the same vertical line, might correspond to the same product and at a different date, but at the same store, because this also corresponds to the same depth inside the figure. So yeah, things that are over each other here will have two of the axes equal. And this is also sort of generally true, and you can use this kind of information to make queries into some kind of queries in this geometric view of the problem. So if you later take a course in computational geometry, it might tell you something about that the applications of this or that problem has something to do with databases. What they're talking about is this view of databases as being a cloud inside this hypercube in general, and queries that then correspond to some kind of ranges on each side and ask them about which pointer inside this object. And as I said, you will likely see that if you take a course in computational geometry data. So we earlier saw that we had not just one table in our database when we're doing this data warehouse, and we had multiple. So how come? Well, we have typically something we call a star steamer setup. It's one of the most typical setups you'll find in a data warehouse, and what it consists of is you have a unique fact table. This was what we saw in the previous slide with this point in this data cube. Here let's continue with the sales example. It's the center of the star here from the name. And we then have a bunch of dimensions as well as a dependent attribute. The dimensions are things we have more information about elsewhere, and the dependent attribute are things we do not have more information about elsewhere. So we might have some dimensions table containing this additional information we have about each of the dimensions. For instance, this product number, well, it might let us get more information about the product from our products database of relation that might contain besides the product number, the type, and the model. We might have more information about dates in our days table containing a date, a day, week, month, and year. Here to probably say that this is not going to be a real table typically, it's what they call a virtual table. So what that means is that you have a table, well, that's not real. There's no one that's going to write a big table containing all the dates. In the world it will sort of be tedious and wouldn't really help you much. Instead what you then do is you basically just join into this virtual table and get all the information you need about the days actually present in your sales database or the ones you care about at least. So basically you can also think of it as making some functions on the dates, giving you some additional information, but to do it using virtual tables is one of those common techniques done in data warehousing. Finally we might have more information about the stores. Again, this will be a real table, we say with name CD content phone number. And finally we don't have any more information about the price, it's just basically a number of days. I mean we could perhaps convert it into other currencies or something like that, but again that will be a virtual table if you did something like that, probably. Let me do it a bit more formally. A star schema describes a database where we have a unique fact table. Here a R which has two kinds of attributes. The first ones are called the dimensions, here a 1 to a N, and the last ones are called dependent attributes. There's no real difference between the two, except that for each dimension we have a corresponding real or virtual table that can tell us more information about this dimension. So the only difference is that, yeah, well these things are foreign keys in essence. So yeah, you have these other tables that tell you more about each dimension. In more general sense we can also have that each dimension table can have further dimensions of their own, and that will lead you to something called a snowflake schema, which I'm not really going to go into here. But I figured I would mention what it was. And yeah, so the point here is that this a i is the key to the foreign table, about to mention d i, and this is always going to be the case for this kind of setup. A typical feature of this kind of star schema is that they use denormalized schemas, which is very unlike normal databases. Normally you want to use normalized schemas, where each piece of information is only stored in one relation. But here we're typically storing the same piece of information in multiple places, because we are caring more about making this kind of complex queries fast. So yeah, we have this main fact table also, and we can join in the rest of information fairly easily by just using this main fact table. You just need to join onto that basically. So in general we don't need to do that many joins. So for instance, as we have seen earlier, if we had some kind of university database and we lecture and students and teachers and stuff like that, we might have sort of a chain of five or six joins just to figure out which student was taught by which lecturer. Here if we did this kind of setup with a star schema here, say our main concern might be the students, and then we could get all information about from the student fairly directly from there. So say you might be able to directly from the student ID say get which teachers taught that student, and you might also be able to get which grade the student has in which courses, and again that might also tell you which student, which teachers had taught that student. So that could be one example of this fewer joins, as in here you would get information about the teachers in multiple different ways. This will lead to performance gains, especially when doing queries that require many joins in a normal database. Of course it's more expensive to update it though, but it's handled well typically when no one is looking at the database overnight or something, as was mentioned earlier. Again it also allows us to do easier aggregation of data. You don't need to write that complex queries to do that. Let me try to show you how this kind of technique is done, on a simple example here it will show this base technique called slice and dice I mentioned earlier. So say we have a product say of type X that doesn't sell too well. Just try to find out what's going on with that. So say we figure out, maybe it has something to do with some of these models of this product. So we figure out what is the price or what is the sum of the sold items of a given model. So we take the sales table, natural join-in fitted products, that's typically how you do it in this kind of settings, and where the type of product is X, and you group it by the model. Okay, that will give you this kind of information you are after. So it will tell you, give you this thin slice here, along the X axis we have cut out a specific type. Say that this is sorted by this type here, it will make it easier to show at least, so I'm assuming it here. And then inside this thin slice we have, we have cut it into smaller pieces, each small piece telling you something about a specific model. So the cutting big parts out and not looking at it entirely is called a slicing part, and cutting this part you're looking at into smaller pieces and then do aggregation on that is called a dicing part of the technique. So basically this is how it looks like. And then after having done this initial query, we might find out, hmm, maybe we need to figure out, maybe this doesn't tell us too much, maybe we want to say, or to have some information about a month. Again, we might just join in a bit more information. Again, here we need to join in days, even though it's not formally a part of our relations, because it's a virtual schema, it will work just fine in a data warehouse anyway. And we then go by the model and the month, and maybe see that this specific model doesn't sell too well in February or whatever. So we can use it for this kind of information. And again, if you look at it in our data cube, we have now diced it also in the other direction along with the dates, based on the month specifically. So again, let's continue. We figured out that this product didn't sell too well recently, so maybe we're also interested in where it doesn't sell too well. It might again give us more information. So we might be looking at the last two months, December and November, and again we might then group it by the model and the store, and figure out what's going on. So this basically will just give you this little part up here, and then we have diced it along with this model and the store number, giving us this set up here, and then for each of the small pieces, we have summed up the prices. And as I said, this is the slicing and dicing technique. The slicing part, as I've already been saying, is what is done by the work laws. It's what cuts out everything else, and the dicing is what is done by the group by-laws, and cutting this small part we have left out into even finer pieces. In this video, we saw a little bit more about this data analysis. I'm not really put so much about this, because I think it's also reasonably well covered by the basic part of the course. I'd rather focus this part of the course on the more interesting part called data mining, where we are basically just asking the system to do everything else, but that will be covered in the next few videos. [BLANK_AUDIO]
So, as mentioned in an announcement, I wanted to cover union as well, partly because it's necessary for the assignment and partly because it's nice to know. However, I could not put it into this misc video, where it otherwise would have fit fairly well, so I'm going to just do it here. So, in this video, I will just cover this union function and there will not be anything else here, really. So, what is this union all about? Well, if you know what it is in math, which says, then you probably already have an idea what it is here. If not, well, it's not really that complicated, so it's not a big deal. So, in essence, what you're going to do with union is you're going to take one list and put another one afterwards, so it's not really complicated. So, let's give it a try. So, let's say we have this employees table from earlier and we want a list of names that is both the first name and the last name or family name in one long list. So, what we write using union is as follows. Select first name as name from employees union, select family name from employees. And we then get this list of, well, first all the first names and then all the family names, basically as you would expect. So, I want to highlight here that there are some requirements to do this union here. If you want to do union, you must have similar data types and you must have that there is the same number of columns in everything, your union together. So, here we had one column, but we can also identify two and two columns. However, if you have two columns in the first part, you must have two columns in the last part. What does similar data types mean? It's not that precise here on this slide and it depends on which system you're using what it means. I will show you a bit about that in a few slides. So, one thing I want to highlight also though, you don't necessarily need to just do union of two things like I do here, but you can just continue running union downward if you want to put more and more things at the end of your list. Also, another thing, the name of the columns comes from the first select statement. So, here we select first name as name. That's why the column is called name, even though we unionated it to a family name afterwards. So, let's start with another example and then extend it a little bit and then afterwards see a few examples where things doesn't work. So, here we're just going to do the same thing as before. I just wanted to show you that you can do more in one column. So, here for instance, I have both first name and employee ID in both parts and we just get what we'll expect. We can still do other things as well, like we can still do things like order by by just checking on at the end. So, here for instance, we have the same query as before, except we had order by name. So, what it gives you is the list of names and employee IDs ordered by name. So, here N, which is a first name, is first and William, which is also first name, is last. So, we see that it's not just order even in the first names of the family names, but to the entire list. So, let me try to show you a bit more. So, well, some queries doesn't work. As I mentioned, you necessarily need that we have the same number of columns in all the SELECT statements. So, here I have an example where you have just first name in the first one, but family name and employee ID in the last one. And this doesn't work. Let's try some other version of it, though. Let's say we have the employee ID first name as name from employees union family name, employee ID from employees. Now, I mentioned that this should have similar data types, and I don't personally feel that that integer is that similar to a string. However, in many systems, it's actually going to produce this output here, which might not be what you would expect. You might expect an error. However, specifically in this w3 school app in Lincoln 2 and in MySQL, it works nicely. Well, it works like this. I don't know if that's nice. But other systems such as SQL Server, it doesn't work at all, because they have different definitions of what data types are similar. So, my impression is that MySQL simply says that all data types is some kind of string, and therefore they're similar.
So in this video, I will start talking about SQL queries. Specifically, I will talk about the required part of the SQL queries. I want to highlight though that when I say required part and in the next video optional part, it doesn't mean that this video is required and the next video is not. Both videos for the purposes of this course are required, but it's just not required to write the optional part in a query. You can still write a skip or everything there and still have a valid query. So yeah, here we'll just run through the part you must include in the SQL query to have a valid SQL query. So in general, the form for the SQL queries, we have this closest, we have select from, where, group by, having, and order by. The first two are required and I'll talk about them in this video. You must have them in any SQL query. You must have select and from. The last of them, where, group by, having, and order by are optional. That is, even if you skip it, you have a valid command or even if you skip any number of them, you have a valid command. The only exception is that if you are having the having command, then you must have a group by command. But again, I'm going to discuss it in the next video on the optional part of SQL. So as such, I would like to discuss the select part and the from part separately, but because both are required, I need to sort of, no matter which one I talk about, I need to start talking about the other ones. So I will talk a bit about the most simple query, econometric first, and then go into details with select and then into details with form. So if you have this employees table, which has a birthday, first name, and family name, and we make this query here, which says select star from employees, you're just going to get everything out again, precisely as the input. So let me try to explain how to read this command. Select basically is output. The star means everything, and from works exactly like in delete here, and it sets the input table. In general, it can do more in the queries than it can do in delete. But right now, in the most simple version, we just have a single table, and therefore it's basically the same as in delete. So this command is taking everything from the employees table and outputting it, which is why we don't do anything. Now I can talk about select on its own using this kind of simple query stuff, like we saw on the last slide. So what select does, like on the last slide, is define what we are going to output, and we can do four kinds of modification using this select command. We can do something called protections, and we have a pi here. Distinct, we're naming, and we have a phi here, and we can create new columns. These weird symbols afterwards will be explained in the MISC radio. I will get to at the end of this SQL query part. So let's start by talking about protections. So protections allows you to select attributes you want to keep, and you're just throwing the rest away. So you just use it by writing a list of the attributes you'd like to keep. So for instance, if you have this table here, employees table, and you write select family name comma birthday from employees, well, you get a table with only the family name and the birthday columns. And I want to highlight here that the attribute order matter if you had written in the other orders in first birthday and then family name, then we'll have first a birthday column and then the family name column. So it's fairly straightforward to use this kind of thing. So let me talk about this distinct command, and this distinct command is for removing duplicate rows. So let's say we have this employees table from before, except I have added in a new employee named Ann Williams with some other birthday than the first employees, and then we select first name from employees, then we'll get Anna, David, William, Ann again. And well, now we have N twice, which we might not want, and we might want to remove one of them, and the way we do it is we write this distinct just after select. So we write select distinct and then the list of attributes, and that will then give you only one N in the output. Again, this is not really that complicated. So the next one is renaming, and as the name suggests, it's for renaming attributes. So the way you use it is write a column name and then write S, and then whatever new name you like it to have. So let's see, we have this employees table, and say we want to rename the family name column to surname, what we'll write is select birthday, comma, first name, comma, family name as surname from employees, and what we get is this as output. Again, we name, we get it in the same order as input, and we have seen that the family name column is renamed surname. So the last thing you can do in select is create new columns. You can do it using, for instance, mar for the current column, so you can do some constants and a number of other things. I will show some of the other things also in the slides. So you will typically also give the new columns a new name, and I'll be renaming. So for instance, say we have this items table, because I want to use math, therefore we need some numbers, and what we can do is we can select name, comma, pies, comma, number, comma, pies times number as total cost from items. That will give you a new column named total cost, which contains the pies times number. So concretely for this two-liter Coca-Cola, which has a pie of three and a number of 30, the total cost will be 90, which is three times 30. And that's basically it. It's not really that complicated to do, but you might want to do some of the other ones when you get to your assessment. The first one specifically you can also do, instead of multiplication, you can do addition, subtraction, division, and you can also use percentage sign, which gives you the modal operator, that is reminder after division. So yeah, it's fairly straightforward to use, just try to do it a few times and you will get the hang of it, I'm sure. You can also do it another way, you can do some kind of aggregate, like say sum or counts or things like that over the output tables. We'll talk a bit more about this kind of thing when we get to the optional part of the SQL query, specifically to the group by command, because there you will be able to do it over subparts of the output table instead of the full output table, just like we'll be able to do here. So say you want to figure out how many items you have in the store in total, that's the sum of the numbers of all the items, what you will write is the sum number from items, and then you'll get this as output. Notice that you have the, it repeated three times because, well, you have it for one straight row. Instead of doing sum, you can also do count if you just want to count how many rows are. You can do average if you want to find the average of the numbers, minimum or maximum, that gives you the smallest or the largest one respectively. Min, maximum can also do it on other things, then numbers, you can do it on strings or dates and so on, and then it will give you the smallest, let's say, graphic string, say, or the smallest date. Now, and this might already be clear, but I wanted to be explicit about it, you can also do any combination of these four things. So for instance, say we have this items table from before, we could make this command which says select name comma pies as pies for eats comma pies times number as pies for all from employees, and we'll get this output table. We have deleted the number column, we have renamed the pies to pies for eats, we have made a new column named pies for all which is pies times number, and we just kept the name column. So here we can see we can do any number of these things together, and it will give you, well, in some sense what you would expect. The next one I want to talk about is from, and it's also the final one in this video. From defines the input, and it will be very easy to get your head around if you only allowed one input table. However, queries are a bit complicated, and we allow multiple input tables. So we need to write and form how we combine them together. So we're not going to discuss all the possibilities of what you can write and form here, I'm just discussing a few specifically the ones we'll be using in this course. But like I said, some others, again, I will not really go into it, because you can define them from the ones we discussed anyway. So the primarily used ones are things like course product, we have this X here, we have something called natural join, and then this other symbol. We'll also use something called left-semi-joints, but syntactically they're not done in form, they're done in where, and we'll get back to the end, the optional part of SQL queries. Let me start with course product. In mathematical terms, this is the simplest kind of join you can have. That said, students often end up stopping with it, therefore I will go right in quite many details and quite slowly, so hopefully you'll have an idea of what's going on. So we have, say, two input tables, we have items, and we have employees, both are from before, you've seen them before. I will make this query here with the select first name comma name from employees comma items. So this comma is how you use this course product in the form part I mean. I didn't have space for using the star in the select here, because, well, it would take too much space, so I'm just choosing first name comma name. It should still be fairly clear what's going on, I feel. So the output from this query is this table here, and it might be a bit hard to see what's going on, but in essence, it's, you can think of it as being some kind of two for loops in each other. The other one is our employees, the other one is our items, because of the order of the two tables in the form statement. So let me go right in a bit in details. You match the first row, N, Nsmit, together with the first row of the items table, in this case, two of color, and that gives you then the first row of the output table. Next, you move down. Next, you go to the second row of the items table, but stay with the first row of the input table, because the items was the inner for loop, and therefore the second row is N with banana, and of course, if you had also a family name, it had been Nsmit. If you had also a Piles, it had been Nbananaso.1. Next, you go to the second row of the employees table, because we are done with the, with N, there's no more items for N to be joined with, and you join this David with first two digits of color, and then afterwards, the next row is going to be David joined with the second row of the item table with the one with banana. Finally, we call William with both items as a William first with two digits of color, and then William with banana. So again, you loop over the first table in the outer loop, and the second table in the inner loop, and that's why you get this kind of thing. I want to highlight here that the size of the output table is six as in three times two. The three comes from the employees table, and the two comes from the items table, and this is basically always similar. So the size of the output table is going to be the size of the input tables multiplied together. This is, to me, at least an easy way of remembering why it's called cross product. The product is from this size part in essence, or you can at least think of it like that. So the next kind of join is much simpler for students to understand, but mathematically much more complex. So it's a bit strange. As an infantist, it feels like the most natural way of joining things together. So what you must have is you must have two tables, and they should have some kind of overlap in the attributes. Typically, you have some overlap OR IDs. So say you have a student or employee ID and design multiple tables, and this is overlap in attributes. So let me come and examine here. We have an employees table here, extended with an employee ID column, and we have some transactions. The transaction has an ID on their own, like a custom ID and an employee ID. And when we then take the select everything from the employees that will join transactions, well, in essence, we are putting the employees together with their corresponding transactions. So let's see what kind of output we get. Well, we get this as output table. So in essence, as I said, we have matched things up based on all the corresponding two. So the first row of employees match the first row of transactions because they have the same employee ID. So we get the birthday is Anne's birthday. The name is Anne. The family name is Mitt. Employee ID one. transaction ID is also one because the first transaction has section ID one and the customer ID for the first transaction with three. Therefore, we have a customer ID of three in output. Similarly, the second row is again Anne because she was also taking care of the second customer, no, the sixth customer, but the second transaction. And finally, William had the third row because he had an employee ID of three matching the employee ID of the last transaction. So it's sort of basically you match things together based on corresponding to each other. And as I said, if you tried a few examples, this will feel fairly natural. Let me be a bit more precise about what NaturalJoin is doing. So formally speaking, you take a cross product. You remove all the rows for the common attributes to not match each other. And then you only keep one column for each common attribute. So for instance, let's take the two tables from the last slide. They had schema employees, birthday, first name, family name, employee ID, and transactions, transaction ID, the customer ID, and employee ID respectively. And these two queries I'm going to show next, I equal this NaturalJoin we saw on the last slide and this complex looking cross product. We have kept birthday, first name, family name, employees, employee ID, as employee ID, transaction ID, and customer ID. For my employees, comma, transactions where the employee's employee ID meets the transaction's employee ID. This is how, by the way, you reference a specific version of a common attribute. So the transactions.e_id is the e_id from the transactions table, and the employees.e_id is the e_id from the employees table. And we can also write it a bit in the shorthand here. We can, after the table names, we can write a letter or a string, and then we can make it shorthand like that. So we can write employees space e, transaction space t in the form part, and then instead of writing the employees and transactions, we can just use e and t instead. So as I said, NaturalJoin is generally understood by students fairly easily. However, when you stop having this course, when you get out in real life after having been in the university, people will be a bit upset of you if you keep on using NaturalJoin because they have some problems, and I want to show them to you now so you have an idea about it. As I said though, it's fine to get an understanding of NaturalJoin or join in general by using NaturalJoin, but be careful about using it after the university. So let's say we have select staff from employees, NaturalJoin transactions, this was what we did before, and let's see how we can get into troubles with it. Say we have a customer also. Again, a customer is a person, so they have a first name and they have a family name exactly like employees, and they also have a customer ID. So now we would like to NaturalJoin everything together. So we NaturalJoin employees with transactions, and get the table from before, and then we NaturalJoin the customers on also. This works just fine, but the output is not what you want. Specifically, the output is the empty output. The reason is that instead of just having one common attribute, we have the first name, the family name, and the customer ID is a common attribute with this customer table and the table from before. And Victor Williams is not a name in the employees, so we don't have that role in the output. We don't have Benjamin Jones either for same reason, or Kate Sanders for the same reason. So again, you have to be a bit careful here. This happens basically because, for instance, the first name in customers gets matched to the first name in employees, as I tried to highlight. So you can fix this kind of issues by, say, having instead of writing first name, you have written C_FIRSTNAME and C_FAMILYNAME for the customer's first name and family name. But again, you will sometimes miss that, or you might have changed the column name, or you might have joined things together you wouldn't have thought of in the first place, or things like that. So you'll probably run into this kind of problem at some point. And well, it's better to avoid them, so try not to use it. Instead, just use this complicated looking cross products, as we saw on the last slide.
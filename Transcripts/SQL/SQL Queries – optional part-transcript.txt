This video will be on SQL queries, the optional part. So when I say optional part here in the title, I don't mean from the point of view of the course, as I also mentioned in the SQL queries required part. Both that and this video are both required for the exam. You're expected to know this kind of thing. What the name comes from is that I'm talking about the part of queries you do not need to have a valid query. So if you've already watched the SQL queries required part, and if you haven't, you should go back and watch it, you would already know how to make a valid query. However, you can work more in-depth queries using this part here, where we focus on what else you can do with the queries. So in this video, I will go through each of the optional parts of SQL queries and show you how it's done. Let me be more precise of what I mean. So we have this form for SQL queries, as we saw in required part, we have select from where, group by having an order by, and the first two, select and from, are required, and I discussed in the previous video on the required part of SQL. But the last four, as in where, group by having an order by, are all optional, except that having, and this will be clear why this case will get to it, having requires you to have a group by before you can do it. So you can have any subset of this where group by having order by, except that if you are having, then you should have a group by. And all of this is going to be discussed in this video. Of these, group by is by far the most complicated one. But let's get into the details of it. So the first clause in the optional part here is the where clause, and we have already mostly covered this one in the video on SQL DML except queries, because it's used by both the update and delete commands. So the one exception to that, and I also mentioned that earlier video, is that you can do something involving subqueries in the where clause. I couldn't really talk about subqueries without having talked about queries first, so that's why I'm coming to come back to that part of it next. So you can also do this kind of thing, we'll go to see here, using subqueries in the where clauses of both delete and update if you want to, but as I said, I need to talk about, need to have talked a bit about queries before talking about subqueries. Since we'll be using it quite a bit later, I will cover this topic next. The first place where I want to mention that you can use a subquery in where is that you can do it in in. We previously talked quite a bit about in, and I discussed the video on SQL DML except queries, and there we saw this example. We could delete from students a name in John, Sebastian. What it did was delete each student with a first name of John or Sebastian. Or you can of course also do a similar query where you select all, everything from students with a name in John, Sebastian. That will find all students named John or Sebastian. Now, sometimes you don't just want to have an explicit list of names like here. Sometimes you want to use a subquery to find these things you are searching for. So you can also do this in SQL, and the way you do it is looking like this. So we can delete from students where name in selected name from lectures, and what it does, I feel is reasonably self-explanatory. You select, as in the inner query, is finding the names of lectures, and then like in the first part of the slide, we just check in if a name of a student matches the name in this list or in this case of lectures, and then deleting those. On the other hand, because when the delete version doesn't really make more sense, why would you delete people for having the same name as lecture? You might also be able to find them by select star from a student's by name in select name from lectures. You might want to do this query, for instance, if you find out that students with the same first name as lecture are likely to receive mail that was meant for this lecture, and maybe you want to do something about that. So, yeah, this is how the syntax for in works when you want to have a subquery instead of the list. Next, I'm going to discuss a more complicated version of it. So next kind of a place where subquills can be used is in something called exists. In essence, or at least I like to think of it, and so I view the in as a special case of exists. So let's continue on with the example from before. On the last slide, we saw how we could use in to find students with the same first name as a lecture, we could sort of do similarly in a weird way to find students with the same first name and last name as lecture, but it's really not an elegant way of doing it. So let's try to use exists to do it, which will do it much nicer. In essence, what exists allows you to do is write a subquery, and if this subquery will turn something, the current row will be kept, otherwise the current row will be thrown out. And this is the key for it, you can use attributes from the current row in a subquery. So, well, how do we do it then? We write a command like this. This will find to the students that has the same first name and last name as some lecture. So the command is select * from a student where exists, select one from lecturers where students.name equal lecturers.name, and students.lastname equal lecturers.lastname. So, yeah, in essence, as I said, exists checks if there is something, if the subquery you returned something, if it does, you keep the student, otherwise they get thrown out. So the first thing I want to highlight here is that this one here is the typical convention used in exists. So if you look it up online and see other people do it, they'll typically also use select one when you talk about exists, because if you don't care about it, you might as well just output a constant, and one of the easiest constants to write is the constant one, so that's why we do it like this. This is just a convention, you can write whatever you want, you could also have written star, you would have done precisely the same thing, you could have written students.name, again, they would have done the same thing. So, yeah, you just need to output something if you have helmets. And I want to point out here that the students.name is not actually a part of the input in the subquery, it comes from the outside of the subquery, it comes from the outside query, and it's then borrowed inside the subquery, where we check if the student we're currently looking at has the same first name, and has the same last name as the lecture we're currently looking at. If that's the case, this subquery is outputting one, and therefore we're keeping the student, if that's not the case, the subquery is outputting, well, nothing, and therefore we are not getting the student with us, because, yeah, if the subquery doesn't output anything, we remove the student. So, what are we using those exist and in for? Well, one of the things we're using them for is something called a semijoint. So, most type of joints we've already handled for the purpose of this course. It was in the required part of SQL, we talked about course product, we talked about natural join, and there's also a bunch of other joints, and all those kinds of joints, I didn't talk about others and course product and natural join, all these kinds of joints, though, are done from the form clause in SQL. The only exception to that is this semijoint, and they're done in the where clauses. And since we're going to need them when we talk about optimization for natural joins, I'm going to talk about it now. Specifically, we'll be able to use semijoints to optimize natural joins to be faster if we have a distributed database, so it will come up a bit later in the course. So, a left semijoint between two tables, A and B, finds a subset of the rows in A that will be used to form some row of the natural join between A and B. And a right semijoint is the same thing, but we're talking about a subset of B instead of a subset of A. So, how do we do this? Well, we can do them using exists, or we can also do them within, if there's only one shared attribute, but I'm going to show it for exists because that's the general one. I have actually already done one example. What we just saw as an example of exists was really a left semijoints of students with nectures, because we only kept the students that had a matching first name and last name as some lecture. And if then assumed that these two things were the common attributes, that would be a left semijoint of students on lectures. So, we have already seen sort of one example of it. Still, that was a bit cheesy example because, well, typically you are using natural join when we are talking about the same person, our same entity, and not here like where we are taking one student which is one entity and matching it with a lecture which is another type of entity. So, this was a cheesy example. Therefore, I will give you a more real example on the next slide. So, the real example I will use of semijoints, I'm just going to take the natural join example and then replacing natural join with one of the semijoints. So, say we want to have the left semijoint of employees to transactions. What we write is select staff from employees and then space E where exists select one from a transaction T where employee ID is equal to the transaction's employee ID. Again, this ENT business, I have already shown it earlier in the required part of SQL query, so I will not mention it again, but it's just to make a shorthand for instead of having to write employees and transactions out in full. Then you can just write this ENT afterwards and use it as a shorthand. Now, what this does is gives you this output, it gives you the first row, the one containing N from the employees table and it gives you the last row, the one containing William. This is because N matches up with some of the rows of the transactions and specifically the first and the second row of transactions, and William matches up with the third row of transactions. Now, I want you to notice carefully here that N is only one sent output of this left semijoint, even though there were two transactions done by William. I feel the query sort of makes it clear why it happens. It's because things you do and where is only going to remove some rows, you can never add in rows. So you're always just, so you cannot end up having two Ns because, well, then you added in a row and that's just how it goes. So it's not just sort of an artifact of how we're doing it. It is a part of how semijoint is defined. You're only supposed to have one N in the output here. So the next clause we get to is a group by clause. It's by far the most complicated of the clauses, at least from my point of view. And if I try to show you what it did initially, I think many of you would not really get much out of it. So instead of trying to start with what it did or how it's used, I'm going to show you what it's used for first and then come back to discussing what it does afterwards. So let's say we have two tables, employees and transactions, like on earlier slides, and we want to know how many transactions N, who has employee ID 1, how many transactions was the part of. Well, we have basically already seen how to do this. We select the employee ID and the number of transactions from the transactions where the employee ID is 1. And, well, because N was part of two transactions, we get 1 and 2 as output columns, and we get it twice because, well, C was part of 2. And this is answering this question very nicely, I believe. Here, of course, if you just want one of them, you could have just written distinct after select and it will just give you 1, as in this 1 and 2. So that's basically how you do that. So now we know how to do it for one employee. We have seen how to do this query for N. And we could also easily do it for each of the other two employees, David and William, by just replacing the 1 by 2 or 3, respectively. So this is fairly straightforward, but it starts to be a problem if instead of having just three employees, you had a thousand employees, because you don't want to go in and replace this command a thousand times. It would be far too tedious to work with. And, well, how do we solve that problem? Well, there's a reason why it's here in the GroupBy slides, we use GroupBy. So what you do is you take the WHERE clause from the previous slide, erase it by GroupBy instead, and you remove the equal to 1 part because, well, you don't want to just do it for N anymore. You want to do it for each of the employees. So that gives you this query here. Select employee ID and current transactions ID from transactions GroupBy employee ID. And it gives us what we want. We have employee ID 1 has done two transactions, and that's true. And employee ID 3 has done one transaction. And again, this is true. And this is basically it for this kind of command. I want to highlight here, though, that this count now is not just over the full table as it was in the beginning, but now it has something to do with GroupBy. And this is slightly complicated, and you'll see precisely how it works in a bit. I'll first show a complication, though, and after that, I'll give you an intuition. That said, of course, we can also use this GroupBy for other similar things where we have a set of entities we want to iterate over and then do some query for each of them. And this is basically what GroupBy is for. Instead of doing it for one specific one like N here, we can do it for each. So now before moving on to discussing how GroupBy works, intuitively speaking, I want to highlight a specific issue I think many of you will run into when you try to do GroupBy. And a hint, you will probably be doing GroupBy because it will likely be how you will do the first assessment. So the complication is that in GroupBy, you can only include in a SELECT statement things that you either GroupBy or aggregates of those. Aggregates are things like error rates or count or sum or mean, or max, and stuff like that. That's why you have a set of things and you select some answer from those. So, for instance, say we wanted to include the first name of the employee as well as the employee ID and the transactions. And we notice that the first name is unique for the employee's table. And besides that, the employee ID will be GroupBy is the key for the table. So there's only one of them and it should be fine to do things that is stable. So what we think we will be able to do with something like this is a SELECT first name, employee ID, counter transactions ID from employees, network join transactions, GroupBy employee ID. However, if you write this command into a database management system, you will get an error message. It will tell you that this does not work because the first name is not in GroupBy and it's not an aggregate. So this is the issue and we'll next, over the next few slides, see two ways of handling this issue. I personally prefer the first one, but there is two ways to do it, so I will show you both. So this was the wrong query. It doesn't work. You get this error message I mentioned earlier. But how do we do it right then? Well, as I said, there were two ways of doing it and I've basically already suggested how to do it. If you remember, I said in the SELECT statement, you can only include things that are either aggregates or included in GroupBy. So there are two natural ways of correcting this problem. Include first name in GroupBy or make some aggregate of first name. The first solution, I would suggest you try that first, is to include it in a GroupBy part. It's fairly straightforward. So you just select first name, employee ID, account, transactions ID from employees, natural joint transactions, GroupBy, first name, employee ID. And it works just fine. It gives you first name of N, it gives you an employee ID of 1, and that C has been involved in two transactions. William has employee ID 3 and has been involved in one transaction. And this is pretty much what we wanted, so this is great. So the other way of doing it I want to show you is this one. We are basically just taking the same wrong command as before, but we have wrapped the first name in mean, and therefore it's taking the first name with this employee ID. And because the employee ID was the primary key for the employees, or at least I haven't formally specified it before, I guess, but it will typically be the primary key. Because of that, the first, alphabetically speaking, first name will be the only first name for the employee, and therefore it will be the same thing as putting the first name in the GroupBy, and therefore you get the same kind of table as before. Except it's a bit more ugly with mean, first name as a colon name in the output, but still that's the cost of doing it this way. So again, there are multiple ways of doing it, and this was two ways of doing it. So now you have seen what GroupBy is used for, you have seen a slight complication with it, and now I want to talk about how it works, because now you have an idea of what it's used for, it will sort of not look too frightening, I hope, even though it still looks quite frightening. Intuitively speaking, GroupBy works like this. You take this SQL command, the scrooby command you have written, and do the parts before GroupBy. You ignore the select part because that's about output, but you do everything else before the GroupBy. And then when you get to GroupBy, what you do is you split the table into sub-tables. I will show in the next slide what I mean here. And for each value of the variables in GroupBy, you have one sub-table. So say we had the example from last slide with first name and employee ID as the things in the GroupBy, then you have a sub-table for each pair of first name and employee ID. So for instance, if you had two employees named N, you would have two sub-tables, one for each N, and with their associated employee ID. Let me try to illustrate this intuition on an example. I'll go to take the one from earlier where we have an employees table, we have a transactions table, and then taking the natural join of those two tables and GroupBy first name, employee ID. So intuitively speaking, what we get is, or at least this is how I wrote, what we get is this answer. After having done that. So we have a first name of N, we have an employee ID of 1, and then associated that's this sub-table telling you about the two rows that has employee ID 1 and first name of N. And that's those two rows in this employees natural join transactions output table. Similarly, William with employee ID 3 is part of one row, and that's the lower row. Now notice that we don't get David with employee ID 2 because he's not actually in the employees natural join transactions because he hasn't done any transactions. So I feel this intuition shows you a lot about what GroupBy is doing and answers a lot of questions you may have, like this complication from earlier I mentioned, the reason why we can only have attributes that are in GroupBy or aggregates of attributes is that we have the sub-table then and it wouldn't be clear, say, what the family name was, except in this case, the family name for N will always be Smith and then for William it would always be Taylor, but in general you might have different family names in different rows and that's why it wouldn't be clear and therefore we'll get that error message I mentioned earlier. Also it makes it clear what the aggregates are over. It's over those sub-tables you get here. So the count, for instance, of transactions ID we have seen before counts those two transactions IDs we have in this sub-table for N and the one in the sub-table for William. And that's in essence how GroupBy works, at least from my point of view. So that was it for GroupBy. Let me talk about the next one, which is having, and having is very, very easy to understand. It's just a version of where, which we do after we had done this GroupBy. That means that nothing you write in having is going to affect the GroupBy, but you have to use this aggregation similar to what you did in select statements or the attributes with the GroupBy in the having exactly like in select because otherwise you will get the same kind of error message as we saw in the complications on GroupBy earlier. So let me come with a simple example of it. We have these two tables from before. We have the employees table and we have the transactions table exactly like before. And we are basically doing the same query as the first solution to the complication, as in the one element. Select first name, employee ID, count transaction IDs from employees natural joint transactions, GroupBy first name, employee ID, having mean CID smaller than five. So only the having line is new compared to earlier. What it does is it removes all rows that we don't have. The smallest customer ID being smaller than five. So if you look at transactions table, we see that only one customer smaller than five is customer number three and that's put together with N. So you only have the row with N in the output. So what we get as output is this first name N, employee ID one and count transaction ID two. Here I want you to notice that even though we have sort of checked that only having mean customer ID smaller than five, this doesn't mean that we only keeping the row where the customer ID is smaller than five. We're keeping all the rows, but we're only outputting the rows where there is some customer ID smaller than five. If on the other hand, we had written where customer ID is smaller than five, instead of having customer ID smaller than five, we'll have eliminated the row with six and therefore the output would have been N one one in that case. So that is a slight difference and you probably should notice it. Yeah, having as I said, it's not really all that complicated. The final one of this clauses you can use in a select query is order by. Order by defines how the output is sorted. It's quite straightforward, really. So let's say we have this table here, employees table again, and we want it to be sorted by family name. So we can first and select first name from employees, order by family name. What it's going to do is going to output David and William in that order, because Jones come before Smith, come before Taylor in alphabetical order. And therefore we get this one. I want to highlight here that the family name is actually not in the output. So you don't need to include whatever you sort by in the output. Yeah, it's just something I wanted to highlight. You can also do more than one thing in the order by. For instance, you could do say family name comma first name. Then among people with the same family name, you will put those with the first name before everybody else. Then, of course, William. So formally speaking, if you have multiple attributes, you are sorting them geographically as in first you are sorting by the first one. Then everybody that had the equal so far, you sort by the second one. Everybody that had the equal so far, you will sort by the third one and so on. So finally, this defaults, as you saw in the example, to the ascending order as we increase. As John is before, Smith is before Taylor in alphabetical order. This is one usual string. And you can do it in reverse order, in descending order by writing DESG after the part you want to sort in descending order. So say you wanted to do family name ascending, but first name descending. You write order by family name comma first name descending or DESG. You shouldn't by descending. Also, if you wanted the other way around as family name descending, but first name ascending, you would write order by family name DESG comma first name. So as you see, you just move the DESG after family name and you don't write it after first name anymore. I feel it should be reasonably clear what's going on. And that was it for the optional part of S-Google.
Hi, so this is the last video on SQL. More precisely, it's about SQL queries, some mislearned stuff, together with relational algebra. So in the previous videos on SQL queries, I have been talking about what you can do with the SELECT statement on its own, what you can do with, say, the FROM statement on its own, and how you can join things together, and I've talked about this GROUP BY statement, but again, each time on its own, and I also want to talk a bit about how they work when they're together, well, and a bit of stuff that are not really related to any alone video in particular, like I will talk about something called VIEWS, that will let you save queries, and again, that's sort of in this video. Another thing I'm talking about in this video is this relational algebra, and again, that's going to focus on parts again. However, I feel that they make it very clear how you can compose the different parts together. It will turn out you can do pretty much however you want, but we'll get to see that towards the end of this video. So SQL queries has this form here, as we've seen in the earlier videos, the first two lines of SELECT and FROM are required, and then we have WHERE, GROUP BY having an ORDER BY, which is optional, and so far when talking about them each on their own, in this video, I'll talk about all of them together. The first thing I want to highlight is about how we execute a query, specifically how we process the different statements we have in our queries. So things basically happen in ORDER, then except that the absolute first thing should happen last. That means SELECT should happen last. So first, we do whatever JOIN we see in FROM, then we remove some rows based on WHERE, we do this weird GROUP BY operation, then we remove some more rows based on HAVING, then we sort our table based on the ORDER BY command, and finally we use SELECT to show us the output. So again, the first statements could come last, but otherwise things are in ORDER. I believe the reason why SQL queries are written like this as in having to LIT first, even though it should happen last, is because in programming, say in Java, you would write the method signature before you write the implementation, as in you write what you output before writing how you're doing it. So I believe this is why SELECT is first, but it's just an explanation. Next, I want to talk about something called VIEWS. VIEWS are one of the things you can store in your database, but which are not tables, or more precisely, they're not real tables. I like to think of them as being two things at once. It's basically a saved query, or that's how you create one, and it's a virtual table when you want to use one. So I'm starting by showing you how it's a saved query, and then afterwards how you can use one as a virtual table. So I'm going to use one of the example queries we had from earlier. Specifically, we had this employees table and this transactions table, and we had this example of how to avoid a specific complication in GROUP BY, where we have SELECT the first name, the employee ID, and the current transactions from the employees, natural join transactions, and GROUP BY first name and employee ID. What it was doing was finding the first name and employee ID, and how many transactions that employee had done so far using this GROUP BY command. So what it was giving was this output here, so we could see that Anna had made two transactions, and William had made one transaction. And, well, so far it's probably the most complicated query we had done, so maybe it makes sense to save this query. So how do we do that? Well, so the way to create this view is fairly straightforward. You just write CREATE VIEW, then some name, and then you write your query. So basically you just put a line before your query, in this case CREATE VIEW, employee transaction count, and then the query. And then that creates a view with whatever name you had specified. This allows us to reference this view later on. Now we know how to create a view, we just write this CREATE VIEW in front of them, and that will give you a view. So it's not really complicated to make. How do we use some? Well, that's extremely easy, I feel. You just use some, at least in queries, exactly like you use a normal table. So say I only want to keep the first name and the count of transactions ID in the output. Well, I will just try to select first name comma account transactions ID from employee_transactions_count semicolon, exactly like if this has been a real table. And this will give you precisely what you will expect. And they're quite easy to use, really, these views. So I'd want to talk a bit more about views before moving on. So far I've told you about how you can basically construct views by basically just writing a line before the query. I've shown you how you can in essence just use views as a replacement for tables, at least in queries. But there is some things you can not do with views. You cannot update the views, you cannot delete from the views, and you cannot insert into the views, as in you cannot change the data in the views. I feel it makes perfect sense, and I will try to explain why that is so by using our example from before. So there we had selected the first name, the employee ID, and the count of transactions ID. And if you want to insert into it, say we inserted "olivar employee_id 4" count on transactions ID should be 12. Well, I can see how we can do the first name of "olivar" and employee ID of 4. We just insert those in employees. But how do we ensure that we have 12 transactions for this first name and employee ID combination? We'll need to make 12 transactions into the transactions table, and we don't have any information about any of the things we need, like what should the transactions ID be, or anything like that. So we basically cannot do it, and because we cannot easily do it by hand, of course our data management system doesn't really have any chance of doing it either. And this to me at least explains why you cannot easily update or delete from or insert into views, because they can have quite complicated consequences if you do. That said, it's not quite true. You can do it using something called triggers, but they're not covered in this module. If you use a trigger, then you can sort of specify that when I do this insertion of first name of "olivar" and employee ID 4 and count of transactions should be 12, then I'm going to insert these transactions in the transactions table and so on. But again, I'm not going to cover it in more details. It will be covered in another module, and more precisely in COM 283, where there you can see a bit more about this stuff, but here we're not going to do it. Now, while we cannot change the data, we can change the view themselves though. So right now we just have this one view. If we decide that, hey, we want to change what this view does, what we can write is create or replace view, and then the name of the view, and then whatever new query we wanted to change to. So here I have just written the same query as before, except that I have removed the employee ID part from the statement, and therefore we get the same view as before, basically, except we don't have the employee ID anymore in the output. So it's fairly straightforward, really. We can also remove views again, so this should hopefully be obvious to people who saw the earlier videos on SQL DDL, where I discussed how to remove all kinds of things like databases or tables, and the way you do it is you write drop, and then whatever you like to drop. So in this case, we like to drop a view, so we write drop view, and it should be employed on text and comment view, so that's what you write, and then semicolon, and that removes our view again after having written this command. So the rest of this video is about relational algebra, so let me try to first explain what that means, what does the phrase relational algebra mean. So we're already halfway done in knowing what relational algebra means as a phrase. We already know the relation part with this kind of tables, so what is the algebra part? Well, algebra is a powerful math. So basically, the easiest example, if you don't know what it is, is algebra with numbers, because you've heard about that at least. So it's basically saying that we have some set of objects here, numbers, and we have operations on this set that gives us a new member of the set, and then we can sort of compose these operations. So for instance, we have an operation called addition, where we can take two numbers out, and we produce a new number. We have the logarithm function, which takes a number out, and returns another number, and it also has a subscript, which is called a base, and we have a whole bunch of other functions like this in math, and I'm sure you know all about it. And we can compose this kind of operations. For instance, we could write log base 2 of 3 plus 8 plus 4, and it would be totally straightforward to see that this is a new number. Now we know what relational is, and we know what algebra is, or at least we know what algebra with numbers is. So what is relational algebra? Well, it's algebra, but where you have replaced the number part with tables instead. So basically, think of them as being SQL select queries. The only exception, and this is, well, more convincing thing with a real exception, is that we're typically using set semantics, that is, we don't have an order on the output of the queries, and we don't allow duplicates, duplicated rows. But in, you can also define it using the proper tables. It just makes it more complicated and explains why I'm not doing it here. So why do we have relational algebra? Well, it's because it's crucial when we talk about optimization, because it allows you to see that there are multiple different queries that will give you the same output, and some of them might be faster than others, and in the optimization part, we'll focus on trying to find the fastest one, and then use that instead of whatever one we got as input. Now, we have already seen what tables are, which is the thing that corresponds to the numbers in the relational algebra, so we just need to see some of these functions we have in relational algebra. Specifically, I will talk about five relational algebra functions in this video as the thing that corresponds to plus or logarithm from algebra with numbers. So the five functions from relational algebra I'll go into are things we've already seen in either the required part of SQL or the optional part of SQL, maybe not explicitly, but basically all the ingredients were there. So the first function I want to talk about is the protection function. I mentioned it quite explicitly in the video on the required part of SQL. I talked about it as part of what you can do with the select statement. So what kind of function is it? Well, it's pi, and then you have an attribute list as a subscript, and then you take and table as an input, and what it produces is the table, but you have removed all the attributes which are not in the attribute list. So let's see an example of it. So we have this employees table with birthday, first and family name, and we had this protections as an pi subscript family name comma birthday on employees, and it will produce this output. It's actually the same as I've used as an example for select production queries. So notice again that the order of the attributes matter. If you have written in the opposite order, the columns have been swapped. Of course, this corresponds to this SQL query here. It's basically the same thing as we saw before, except that I inserted distinct, and of course it produces the same output. Now I want to highlight here, I only have distinct here, because we're using set semantics for the relation algebar part, and we're going to see it on all other slides also, but there is no real deep requirement for it. It doesn't really change anything. The second relational algebar function I want to talk about is the renaming function. Again, we saw that in the next statement of the required part of SQL video. So you have a phi, and you have a subscript of a column name, then an arrow, then another column name, then a comma, then a column name, an arrow, and another column name, and so on. And what you do is you rename the first column name to be the second name, the second, you know, the third mentioned column name to be the fourth name, and so on. So let's see an example. Say we have this employees table again, and then we rename the birthday column to bday in this employees table, and well, it just gives us this table here as the output, and the only difference is that instead of being called birthday, the first column is called bday. Of course, we could also do that in SQL queries. So the way you do it is next distinct birthday as bday, first name comma family name from employees. So here we start to see one of the differences between relational algebar and SQL. We don't have to mention all that we're keeping all the columns in this renaming syntax. It's enough just to say that we are renaming some of them, but it's mainly syntactic difference. It's just that you automatically get protections in the SQL syntax. So there's no real difference, and of course it gives the same thing as before. So next one I want to talk about is selection. It's a sigma. It has a condition, and it returns all the tuples in the table to take as input that satisfy the condition. So say we take the condition of name equal to n in employees. Well, we just end up with this one, which is the unique employee with the name of n, and the corresponding SQL query is this one. As you see, the two first ones, the two first functions I showed was done in this next statement. This one is done in the where statement, but again, it's pretty much what we've been seeing so far. So one thing I want to mention just because it can be a bit hard to remember is that even though it's called selection, it has something to do with where, but not the select operator in SQL. It's a bit hard to remember initially at least. So, so far, all the functions I've been showing you have basically looked similar to this log algorithm from LGBAP with numbers. So there we had a log, a subscript which was the base, and taken on some input. The previous ones we've seen has been a symbol and some subscript modifying how the function works, taken on some input. So I also wanted to show you something that took two inputs instead of one, so I'm going to show first this Cartesian product one. So in Cartesian product, we have two inputs, and we have this course denoting the Cartesian product operation written between the two tables. So we pair each table from the first table with each table in the second table, and again, we have seen this in the video on SQL required part because it's done from in SQL. So we write modules times lectures, and what you get is this. I will go over in details here because, well, as I mentioned in the earlier video, some number of students seems to struggle with understanding Cartesian products, so Philip Bellaton spent a bit more time on it. So you have basically two loops inside each other. The outer loop is our modules, the inner loop is our lectures, and then you sort of just output them row by row. So first we output the first row of modules, comp 105, year 1, semester 1, with the first row of lectures, John, and comp 105, giving us the first row of output. Afterwards, we output the first row of modules, comp 105, year 1, semester 1, with the second row of lectures, Sebastian, comp 201. So notice that in this Cartesian product, there's no connection between the code and the module. There wouldn't be a natural join either because they're named different things, but, yeah, it's important here in Cartesian product that you don't do anything smart. It's just doing something basically kind of stupid. After having done the two first rows of the output, the next one comes from the second row of the modules table, comp 201, year 2, semester 1, and then you pair it with the first row of lectures table, John, comp 105, and again, notice that the module and the code doesn't match, which is fine. This is Cartesian product, and it's a bit stupid. And then finally, we have the second row of the modules, comp 201, year 2, semester 1, paired with Sebastian, comp 201. And that's how you do it, and the reason why it was called Cartesian product, at least one way of thinking of it, is because of the size of the output table is 4, which is the two input table sizes multiplied together, and that's always the case. So of course, we've already seen how to do it, and I mentioned it. You do it in SQL like this. You just write a distinct star from modules, comma, lectures, semicolon, and that will give you this as the output table. So yeah, it's fairly straightforward to do in both relational algebra and SQL queries. But as I said, some members should not struggle with it, so do try to make a few examples with it. So a second example of a relational algebra function where we have two inputs would be the natural join function. Here we have two tables, say R1 and R2, and we have this double triangle symbol for the natural join, and you match each tuple in the first one with each tuple in the second one in the ones where you have common attributes, and you only keep one of each common attribute. So this is how it looks like on the example. If you have employees and transactions, they want to naturally join them by the employees, this double triangle symbol, and transactions, and it outputs this table here like we've seen before, where n is matched to our two transactions, as in she has first and the second transaction because they have the same employee ID, and William has the last transaction because he is the one with employee ID 3. Of course, we can also write this in SQL. It looks like this, like distinct from employees, natural join, transactions, and again, giving you the same output table. I have mentioned five different relational algebra functions, and I will mention two more on this slide, and then otherwise leave it at that. The first one I want to mention now is the left or right symmet joints. So we saw it before in the SQL queries optional part, and basically you took a natural join, and you found the rows on our left and right that would be matched with some row on the other side, and those you outputted. You outputted on the left if it was left symmet join, and those on the right if it was right symmet join. And the symbol is just like the natural join symbol, except missing the line closest to the site that's missing in the output. So the other one I want to mention because, as I have said before, it will be used in the assignment, so I imagine many of you might be interested in later also. We have the code by operation, however, that's very complex for relational algebra, and the two books define how they define this function. They have different syntax, different symbols, and so on, and I didn't really feel like defining it here, therefore, so instead I'm just going to point out that you can define it, and you can just basically write down what the code by statement is saying, and what the values of aggregations you'll be using afterwards, and then just leave it at that. So why am I showing you all of this relational algebra now, instead of doing it next to this optimization where I said it would be useful? Well, the key thing here is that it allows you to easily see how we can combine different parts easily, and this was the one thing I wanted to do in this video. I want to show you how you can combine different parts of an SQL into a whole. So the key thing here is you can do this combination however you want, basically. Let's, let me show you sort of a reasonably small example, but still I feel it sort of shows you how you can combine things. We had this math example from before, where we can take log base 2 of 3 plus 8, and add 4, and we could write in some sense a similar relational algebra example, where we have r times s, and then of that we rename a to z, and then take the natural join with g, and just sort of keep on adding this kind of operations on top of each other all the way. And anything you can write like this will give you a corresponding SQL query. You can do it very mechanically, it's not miss-cough, I'll show you what I mean by mechanically. So say this came up for r was r a comma b, and for s was c d, and for t was t e z. Well, how would this query then look in SQL? Well, it would look like this. So here, I'm showing this example also partly to show you that you can nest things basically however you want in SQL. You don't need to write tables in the from statement, you can write queries instead of tables. So basically, whenever you need to access a table in the from statement of queries, you can replace it with a new query. So here, first in our relational algebra example, we multiplied r by s, and therefore we have this corresponding select everything from r comma s. Next, in our relational algebra example, we had taken the renaming a to set, so that's written like this if you do it naively, as I showed it before. And then we have the full thing where we just have inserted all of this stuff. And this is sort of a fairly mechanical way that allows you to translate from relational algebra into a corresponding SQL query, and this corresponding SQL query is then valid. So here, you can sort of see that basically any kind of weird expression you want to write in a relational algebra has a corresponding one in SQL, basically looking something like this. And these are fairly easy to generate, and also shows that you can do any kind of weird things with SQL, as you can do with relational algebra.
I will talk about SQL DDL in this video. That is standard query language, data definition language. So what it is all about is how to create tables, how to create databases, how to modify tables and how to delete both tables and databases. So the most reasonable place to start I think is to how to create a database. The way you do it is you want to create database, then some name and then semicolon say create database database name. In this case that will give you a database called database name. We can then of course use a more reasonable name like create database cs_store semicolon giving us our database for running example of cs_store. So here database is conceptually the same thing as a folder as in it's something we put all things into like the tables like something called views we'll see later and also triggers which we will not see. And it's initially empty and then it's used for storing all this other stuff. Now I want to point out that the words in SQL are not case sensitive so you can write it however you want and it'll be fine. So you could have written it the same thing like this as in where every second letter is capital and every second letter is lowercase. And it will be the same command that said typically people write it out as on the left side this is sort of the convention and it's a convention I will follow in this course so I will write the commands in other case that are like on the left hand side. Now we know how to make a database let's look at how to make tables. The way we do it is we write create table then some name then a begin parenthesis and then the name of the first column then this data type then a comma name of the second column then a data type then a comma name of the third column data type and comma again and so on so on. On the last line you don't include the comma and then you end it with a end parenthesis and a semicolon. So this creates in this case I had three columns or in this case we create a table named table name with three columns in this case I will named column one column two and column three and the data types for data type. On the next slide go through the data types but right now I just wanted to show the form. After I'm shown data type I'll come at a more explicit example showing you more about how it looks precisely for real example. So I wanted to also point out that this schema for this would be table name column one column two column three and I also wanted to point out because this is not just here it's everywhere in this world the white space you can you can use it pretty much however you want but again the left hand side here is the typical convention of how to do it and the one I will follow at least most of the time unless there's not enough space in the screen in that case I will try to make it look reasonable anyway. So another example you could have written it like this where we have changed some spaces to enter instead and other spaces change the spaces and it looks kind of ugly I feel but again you can write it like this and it would be the same command except it looks ugly. So yeah as I said I will be using the convention on the left hand side just because I think it looks nicer and because it's a convention so when you stop being in this course people will typically expect you to follow the the left hand side kind of setup. Let me talk about the data types in SQL. The first data type I want to mention is int for integers. You can also use float for decimal numbers or more precisely it's for floating point numbers. You can, there are two data types for strings. The first one I want to mention is the one called char, char x so this x here is an integer and it gives you a fixed length string so if you wrote char begin parenthesis five in parenthesis it will give you a string that I have linked precisely five. So for instance house would be a thing that fit in char five because well there are five letters in house but formally speaking things like char would not because well that's too short. In practice most database implementations will pep to short words so that they have length whatever you are specified so char would have been padded up to being char space space. There's also a variable version of strings as I said there were two kinds of strings is kind of the same thing except you write var in front so you write var char and then begin parenthesis and then the length and then end parenthesis. So for instance var char five would give you a string that had length at most five that means that both house and char would fit nicely into them. Other types could be things like dates, that's just date. The format is year first then death and then two for months and then death and two for days. So for instance 1990-11-10 would be the 10th of November 1990. You can also do a date time version by basically appending time onto the date from above so you have the date from above as in year before and not tickets there's month for two tickets there's days with two tickets followed by space and hours colon minutes colon seconds. So for instance 1990-11-10 17 colon 15 colon 00 would be a quarter past five the 10th of November 1990. We have also something called XML for XML files if you do not know what an XML file is that's perfectly fine we'll talk quite a bit about XML later in the course. And there's something called a blob for binary files as in like if you want to store programs into a new database you can do it using this binary file formula. There's also a bunch of other things for other positions and by specialized data types I'm not going to these I've shown on this slide are things I will mention without explicitly making sure that you know what data type I'm talking about if I mentioned on one of the slides they should be fairly self-explanatory except maybe the strings so please spend a few minutes looking at the strings. So let me come and explicit example of how to make one of these tables say we have this employees table from before the one with schema employees birthday first name family name and the birthday is a date the first name is some string and the family name is also some string. So one way we could do it was write create table employees birthday date comma first name vaja 100 that means that the first name should be at most 100 long. If you later see how to change that if you find out that it should be bigger say than 100 and then family name again 100 and again you can see later how to change that if necessary. Yeah and then end parenthesis and then semicolon. So over the next few slides I will talk about some constraints you can put into your tables as well. So for instance the first I will talk about is what is called unique so you can specify that some attributes or set of attributes should be unique. So let's see how to do it well you take the same kind of create command as before like create table employees birthday first name and family name and then say you pick some of it out and say this should be unique say and this is maybe not the most realistic example but it could be an example one is example I'm going to use here we might say that birthday together with first name should be unique. So the way we specify that is we write add constraint then a name let's say you see underscore employees unique birthday comma first name and that will then ensure that you can only have one employee with a given first name and birthday. So this you see employees is just a name it's just so we can refer to this constraint. It'll file it lets us for instance delete the constraint again I will not show you how to delete constraints so because I cannot really imagine that that it's going to come up for many of you so I'll just say you can do it and if you need to do it for some reason just look it up on your own it should be fairly easy to find online. Let me be a bit clear about what this unique means it means that for each value there's at most one row in a table where this set of attributes take that value for instance if you have this constraint here that means that I can be only one employee that had a birthday say the first of January 1990 and a first name of Anne. We could have two employees named Anne and we could have two employees with a birthday of the first of January 1990 but because of this constraint here we cannot have an employee or two employees with a name of Anne and a birthday of the first of January 1990. So that's sort of in essence how this unique works. So here I want to talk about the primary key. Primary keys are well another kind of constraints but they are quite dissimilar to the other constraints we see in this slide here. What they do is allow you to specify how the data should be sorted physically in storage. So let's come an example you have this create table employees from before with birthday first name and family name and again we want to have a primary key on birthday comma first name. So what we write is add constraint a PK_employees primary key birthday comma first name. What this primary key then does is that physically on the hard disk the employees are going to be sorted by first their birthdays and then everybody with the same birthday are going to be sorted by first name. So this is how that's used. Again this PK_employees is just a name so we can refer to it and in principle at least delete them. Again we find out that we don't want to have this primary key. Still it's extremely rare that you want to delete a primary key from a table and I would suggest you just look up how to do it in that case because well different systems implementations of this database management systems use different formats for doing it so it's better that you just do it up in case you need it because I imagine it's not going to be in the time soon. So primary keys must be unique precisely like how it was in last letter. You can only have one person with a given birthday and first name if there are two then it violates its primary key constraints exactly as if you had written unique instead of a primary key here. And furthermore there can only be one primary key per table so for unique you can write any number of sets should be unique like you could have said that birthday and first name should be unique and birthday and family name should be unique. This you cannot do with primary keys you can only have one. This also makes sense because it would be very unusual that you can sort things in multiple different ways at the same time like I mean you wouldn't expect say if you had this primary key of birthday and first name then you wouldn't expect you to be able to have the same sorting for the first name and family name. It would be very unusual property of the data and it's not allowed in SQL to make that kind of constraint. So primary keys are often or typically ID numbers in some some sense so this is not really a typical case which makes sense because it also looks very weird with that to have a primary key of a birthday and a first name. Typically you're just using one attribute like an ID number like a student ID or employee ID or whatever ID depending on the table and that's the primary key and that's typically how we use it. The next and final kind of constraint I want to talk about today is the foreign key constraints. So a foreign key is used to link two different tables together explicitly. So what it does is you have some attributes in one table what we call a child table and you would like them to point to the primary key of another table what we call the parent table. So what it does this foreign key if you do for this subset of attributes in the child table is ensures that the values of the attributes and foreign key of the child table must also be present in the parent table and this is probably very hard to understand without an example so that's why I'm going to give you one right now. So say we want to have an employee ID as a primary key for employees table and we have a table that contains transactions and that table has an associated employee ID as in for the employee that sold whatever items was included in this transaction to whatever customer that transaction was sold to. The transactions will probably also have a custom ID but doesn't really matter for this example here. We can then specify that the employee ID in a transaction should also be an employee ID of the employee table and the way we do it is to make the employee ID of the transaction table a foreign key to the employee ID of the employee table. What it does then is if we write a wrong kind of employee ID as in we mistyped say letter or something then we'll get an error method that we mistyped the employee ID. Of course this is only the case if it doesn't arbitrarily match some other employee I mean it's not smarter than that. We can also use these foreign keys and this is one of the key things what I'm showing you in this video to create what is called a custom data types by basically just having a table containing a list of everything we like you to be able to do. So say for instance we have a table containing all the postcodes in the UK and this postcode is a unique primary key for that table. And then in another table we want to allow users to specify postcode but we'll also like to ensure that they only specify valid postcodes. So that's why we have a foreign key from this other table pointing to the postcode table so that will ensure that you can only specify valid postcodes in the table you point from. So let me show you how to actually make one of these foreign key constraints. So far I've just been talking about what they can do. So I'm going to show it for this first example with the employees and the transactions. So we have an employees table, we have this employee ID which of course going to call it EID just to make it a bit shorter and it's going to be some number and an employee also have a first name and family name say and we have this constraint add constraint PK employees which is a primary key with this is EID. So the primary key for this table is the employee ID or this E_ID. And then the transaction table could look something like this we have a points of attributes say and then suddenly we have an EMP_ID which is an int and we have a foreign key constraint with written by constraint FK_TRANSACTIONS foreign key EMP_ID references employees EID. So of course let me go over the format here a bit. So we have the first part is constraint is what we've been seeing so far with many of the other ones so it's not really new and FK_TRANSACTIONS is just some name for this constraint so again this is not really that new. Then we have foreign key and then we have whatever attribute is in this go-on table. So here in this child table, in this transaction table, the EMP_ID was the one we would like to link from so that's why it says EMP_ID in the first parenthesis here. And references the employees table that's why we write employees here because we want to reference that table and we write primary key, the attribute name of the primary key, as inside this parenthesis. And that's how you create a foreign key constraint. And as I said then this is ensures that the employee ID you write into the transaction table must match up with some employee of the employees table. Otherwise you will get an error message if this is not longer valid either because you try to lead some employees that has a transaction or because you try to have a transaction that doesn't have a corresponding employee. In either case you will get an error message. Now having done all this stuff about constraints let me go to something which is a bit simpler. Let me go to the how to remove things in SQL. So in SQL delete or remove is typically called drop. So let me come with some examples. If you want to drop a database you write drop data person one ever name of the database is then semicolon. And for instance drop database cs_store in semicolon will drop our cs_store example database as in remove it. Also you can drop table the same way you can drop table employees to remove the employees table. Of course the first command also removes all the tables and so on because it removes everything to do with the database. So drop database will remove everything to do with the database. You will often not use it that often. One can also remove all this unique primary key and foreign keys as in all these constraints we have been seeing in similar ways but it's done so very rarely I believe that I will just suggest that if you need it for some odd reason just look it up on your own because well partly because it's done well and partly because different system is having different format for how to do it I will just let you look at it up on your own. So we have already seen a ton of things in this movie. We have seen how to create a database, how to create a table, a bunch of things about the data types of the table and how to use all these constraints we saw and how to remove both the tables and the database afterwards. The final thing in this video in this on DDL data definition language is how to alter a table to change attributes say. You can write say alter table then the name of a table let's talk about the employees table add and then the name of an attributes and then the data type so for instance we could write alter table employees at email varchar 100 and that will give us a new attribute in our employees table called email and it's a varchar of length 100 as a string of length at most 100 because say we wanted our employees also to have an email address. Now of course at some data point you might find out okay some employees have really really long emails we should probably increase length for this email attribute so we can also do that in SQL what we do is write alter table employees modify email varchar 200. Again I feel that the format is fairly self-explanatory and employees can be replaced with other table names email and the data type can be replaced with other data types and attribute names and that will just change whatever attribute you're talking about but in this case we change the email to be at most 200 characters long. So that said this is one of those cases where we have a difference in different implementations so this modify version is what is used by MySQL and Oracle but other implementations of SQL are using different words here. For instance using the alter column or similar. It depends on the exact comment depends on the exact implementation and you should probably look it up if you're not using MySQL or Oracle. That said I think Oracle is actually changing it now so you should probably just look it up if you're not using MySQL. The final thing you can do you can also remove columns again say you find out hey I don't actually care about the email anymore so you can write alter table employees prop column email and I will remove the email column from your employees table. Again if you be clear how the format works you replace employees with another table name if you want to do something from another table and you replace email with whatever attribute you like to move.
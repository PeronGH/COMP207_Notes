In this video I will discuss index. So there's different kinds of index and I will talk a little bit about different kinds and in the next few videos will be about a specific kind of index called B+ trees. In earlier videos I've been discussing how to compute these relational algebra operators like for instance here selection. As in you have a relation R, you go through it tuple by tuple and if a tuple satisfies the condition you can add it to the output. Now this naive algorithm for it needs to read the entire relation to do this operation and we can do it faster sometimes and let's see how to do it. In the last video we have seen this before but I figured I will repeat because the last video was not required. So let me show you an example here. Say we have the student database and we want to find the students with a program of G401. So we can do selection faster if we can figure out where the rows for G401 are. And in general there are two ways of doing this. You can either sort the file or you can have an index. I've already covered how to do sorting if the input is very big and here I'm going to talk about indices. What is one of this index? Well an index has one or more attributes and corresponds to some table. Here we are talking about the students table and say we have an index on the attribute of program in that student table. Then given the value for each of these attributes, in this case just program, you get quick access to the table with these values. So say we are interested in finding this program of G421 from the last slide. Then there is a corresponding row in our index that tells you that G401 corresponds to these rows of the student table. And to provide faster access to this index, the values in the index are sorted. Now there are two types of index. There are secondary index where they mainly point to the location of the records on disk and a primary index with signed addition also require that the table is sorted according to that index. So the primary index are typically exactly what you define with the primary keys and this is something you might know. The secondary index is what is called dense as you need to specify each of the values on disk based on this secondary index. You don't need to do it in the primary index because you know that the values will just increase as you go along into your primary index because it's sorted based on new value. Let's go back and look at what we can do with one of these index. For instance if you make this search for the period of a program of G401 in the students table and we have an index on program, the way we can do it is when we need to find the index and we need to find the entry for G401 index and then we set each of the students mentioned in that row afterwards. So what is the running time? Well for the first line we need to find the this G401 in the index and you can use that using binary search because it's sorted so that we'll see say log k where k is the size of the table and then we need to go through each student with this program and that will require size as output to do that. As you need to go through each student that will require how many students there are. We can also do it smarter if we have multiple index and we make sort of composed queries like here I'm looking at finding the students with program of G401 in year two among the students and say I have an index on program and one on year then what I can do is I can find entries for G401 in the program index and the ones for year two in year index and then I can visit all the students that are in both as I take the intersection of these two lists and whatever I set in that list is then a student with idea of equal to two and program of G401. We can also have more advanced indices for instance over multiple attributes and for instance here have an index and program and year and then to find the students which has program equal to G401 and year equal to two I can just find it in the index directly first by searching for G401 and then among those find the ones that have an year equal to two and then they can visit all the students mentioned in that row. This table alone can also help you find things which has a program of G401 you just want to find G401 and then want to all the mentioned rows afterwards so that's also an option but here you can see that at the order matters we cannot use this index to find students with a year equal to two alone it will not really help us we'll have to run through all the different values to find all the students so it wouldn't help us much to use this index if you want to find all the students with year equal to two. I will mainly focus on one kind of index in this course the ones that are called p+ trees and these are good if the selection we are after specifies a range so for instance if we have the program equal to G401 and year strictly greater than one and it's one of the most widely used type of index well because it's good if you have range search like this and the way you do it is you write create index on students using p3 program comma year and that will give you an p+ tree index on program comma year so it's actually the default so you can omit using p3 it will figure out that it should be p+3 because it's the most common one. There's also a bunch of other things like hash tables where you use the hash key of whatever you are searching for and these are only good if you have a precise expression you're searching for as in if you're searching for equalities so the p+ tree can handle ranges which are more general than equalities you can do that by writing create index on students using hash for instance program here or you can also use more advanced index like you can have an index and students lowercase name as it doesn't need to be a direct attribute in the table it can be some derived attribute using one of these functions here we're using lowercase for instance but it could be other things as well and of course there's a bunch more indices I will not really go through them all but yeah mainly in the next few liked videos sorry I'm talking about p+ trees so as we have seen now you can have indices on multiple columns at once for instance you can have an index on program comma yeah intuitively certain index means that you have a virtual column containing the concatenation of these attributes for instance in this case you would have a virtual column containing the program concatenated with the year in that order and any chains in the first component is more important than any chains in the second component for such an index and such a column so for instance g 401 comma 2 would be smaller than g 401 comma 3 and that's again smaller than g 402 comma 2 as in any chains in here is less important than any chains in program so we can think of ranges on such concatenations of columns and the corresponds to some queries in the general case for instance if you have an index on program comma year then inequality of both program and year would be a special kind of range on such an index similarly an equality of program but a range on here would have been all that kind of rains on this kind of index because all the thing with the same programs come after each other and then even if they have different years that's why this kind of range would be faster similarly an equality of program alone would also be faster it comes directly from two that three is faster and finally it's also faster if you do a range on program because well all the program all the programs comes first everything about one program then everything about the next program and so on in the index and therefore this kind of thing will be faster if you think of it as a range now you might think does that mean that all kinds of ranges are faster the answer is no there's some kind of ranges or qualities that will not be faster for instance inequality on here alone would not be faster because you would have to go through all the different programs for this year to find it and in general that will not be faster than just going to all the different things in the database similarly our brains and gear will not be faster because well again you will have to go to each of the different programs to find all these years I mean it might be slightly faster but it will not be most faster as a summary there's a bunch of different kind of indices in particular in this course I have mentioned has index I'm not really going to go more into it but they are good if you want to do equalities and we have seen and we'll see B+ trees with a good if you have a range or equality as a special case
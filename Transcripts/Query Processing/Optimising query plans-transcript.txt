In this video, I'm going to show you some ideas of how to optimize these query plans. Over this video, as I said earlier, in this part of the course, we are focusing on how to pass and query an ISQL query, and how to optimize it, and how to select a physical query plan, and so on. We have especially talked a bit about how to do all of these operations in our physical query plan so far. In this video, I'm going to talk a bit about how to optimize the logical query plan first. We needed a bit of these operations before seeing this, because we have a number of choices, and the choices depend quite a bit on the underlying techniques you can use for the different parts. So, how do we optimize one of these initial query plans? Let me try to illustrate why we might want to optimize our queries. So, let's say we have this "file is tried forward" query here, which selects everything about the stores and employees, where the employees are working in Liverpool and in that store. So, if you just translate this "tried forwardly" into ISQL and into relational algebra, you get this query plan for it. But we can do that much smarter. Let's try to see a few ways we can do this smarter in. It's fairly inefficient to compute this cost product if, for instance, we have few troubles with the city of Liverpool. That will typically be the case. We might have a hundred stores all over the country, but we might only have a few stores here in Liverpool. So, it would be smarter only to make the cost product over the ones in Liverpool. So, that will give us this query instead. Here we have moved the check of movies in Liverpool down on the stores instead of up after we had done the cost product. This then means that we're only going to compute the cost product for the troubles with the city of Liverpool. And that's, of course, much faster than doing it for all the troubles, because, well, as we have seen earlier, cost product is a bit slow. Here, now we can exploit an index in the stores on Liverpool on cities. And again, this will be quite a bit faster than just doing it naively. We could not do that earlier, because we had done the cost product first. So again, here we see another reason why we might not do this optimization here. Finally, we could also combine this select operator together with cost product into an equijoin, as we saw earlier. And then we could use sort join to join even faster. So again, we have seen quite a few different techniques here. How to make this initial, fairly straightforward, simple, not that deep query, quite a bit more efficient, even in a fairly generic way. So what principles are we using to do this optimization? Well, as we have seen earlier, we are evaluating query plans bottom up. And the time we spend on each of these things depends on the size of our intermediate result. More specifically, it depends on the size of the maximum intermediate result. So we're going to rewrite the query plan, so that the maximum intermediate result gets as small as possible. And to do that, we're going to use equivalence laws, relational algebra. And I'm not really going to go too all of them, because there's extremely many. But you can look it up. The references are quite some references on Canvas attached to this video. Some examples, though, just to give you an idea what's going on. If you have two selections, on join with an and, on relation R, then you can split them up and move them around. This might make it smarter, specifically because you can do then some of these remaining steps afterwards. It ultimately means that you can move sort of one inside the other, or the other way around. And again, this can help you. Or finally, it can help you also to move it the other way, if you have an index on both of them. And then you can do both of them very fast together. So it depends very much on what to do here. It depends on what kind of situation you are in. Then that's just the first rule. The second rule is, if you have a selection on a cross product, then you can move the selection into the part this selection is about. So if you have a selection of a equal to a, of a cross product with s, and a is in R, then you can move the selection into the part on R. This was the principle we saw on the last slide. And again, this can be quite a bit more efficient than what you otherwise would have. And finally, if you have something like a equal to b, where a is an attribute from a, R, and b is an attribute from s, and you're doing the product of R times s, then you can change that into a equijoin, because that was the definition of equijoin. And as we saw earlier, equijoins can be done quite a bit faster using the sort join algorithm. At least if we are not unlucky, and everything has the same value and is an a and b column. But again, as you can see, there's a few rules here, and they might not look that advanced, but sometimes they can really help you quite a bit to make much more efficient queries. Let me try to show you some specific ideas that typically works great for optimizing query plans. The first one is to push selections as far down the tree as possible, because then you don't have as much in each of the intermediate results. So say we have this query here, and then we could translate it into this query over here to the right, where we have moved the stuff about CD equal to Liverpool down on the stores. This was what we did in the earlier slide on this stuff. And the intuition is that we get rid of as many irrelevant tuples very early in early in execution as possible. We cannot really get rid of them before this. And as I also mentioned earlier, this also allows us to do indices, which we might not be able to do otherwise if we haven't pushed them down like this. Another thing you should push down is projections, or you can also even insert new projections where appropriate. So say we have this query again, and then we might insert these projections here. So see at the end we just want department and name, and we also use work set. So we're just keeping work set on the left side and the department and name on the right side, and we don't need anything else, because above they're going to disappear anyway. So why have them around? And if we don't have it around again, we can do this cross product faster, because there's less to do the cross product on. Also the last holistic that's typically good is, if possible, uses equijoin for a cross product followed by a selection. So here we have this query plant from last slide, and we can then change this cross product followed by selection into an equijoin, where we have work set from left and depart on the right. And again, as we saw earlier, this is much faster than otherwise. So this is sort of three simple heuristics you can follow and get quite a bit more efficient queries out of it, if it fits what you're doing. And it will in many cases fit what you're doing, because these are the typical patterns people are using when they write. And I haven't shown you all the heuristics. There are many more heuristics. I didn't want to spend so much time on this, because again, I feel it's better to look up the heuristics you need, instead of me trying to make you memorize 10 different ones or 100 different ones or whatever. So as a summary, optimization of query plans at the logical level. So we started with initial query plan, and then we applied a number of these equivalence laws for relational algebra, and this allows you to get a more optimized query plan, especially if you follow these heuristics. It will typically allow you to get much more efficient queries out of it. And well, that's good, because we don't want to spend more time than you need to to do our database operations.
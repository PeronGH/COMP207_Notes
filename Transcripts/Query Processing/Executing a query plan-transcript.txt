This video will cover how to naively execute a query. In this video, I will show you how to execute one of these query plans in a fairly naive way, and I will show you some more advanced techniques for it in the next video. Each query plan will tell you precisely what we need to compute in each step, and we then just need to select algorithms for each of them. So, we give a query plan here, and we then proceed from the bottom to the top, and for each node, we compute an intermediate result. For the leaf, the intermediate result is just a relation. For an inner node, it's a relation they're doing on the intermediate result of its chilcon. And then the result of the query is just the intermediate result of the root. Let me show you some examples of it. Let me try to show you how it works using some examples. So, let's say we have this as our query plan, and these are our input tables. So, stores has code and city, and employees has name, depart, and phone. And then we sort of just move up and calculate intermediate results from it. So, the intermediate result from the renaming code to depart is we'll just take the stores table, rename code to depart. On the other hand, we're only keeping the name and the depart columns. Therefore, we're removing the phone column, and that's then the intermediate result on the right-hand side. Now, next, we're taking the national join, leaving us this subtable. And finally, we are removing the row corresponding to Liverpool and only leaving the one for Manchester. And this will then repeat the intermediate result for the root. It will look like this table here. And because it's a root, this is the final result of our query. So, this is sort of the principle of how we execute a query on a pair of input relations. Using this query plan. Let me show you a bit more abstract example here of how to execute one of these query plans. So, we have these two relations as input, and then we move upward to the tree. So, on the next level, the intermediate results are like these. On the left-hand side, we're just keeping the A and B column. Notice here that I'm still talking about sets when I talk about relational algebra. So, that's why we end up with two rows on the left-hand side, even though they're original one-hat tree. We are deleting one of these one, two rows, because we use sets for relational algebra. On the right-hand side, we'll be naming B to C and C to D and giving us that table on the right-hand side. Then we are taking the lateral join, giving us this table here. And finally, we are selecting the two rows where B is equal to C. As you see, we're just removing the top row where B is not equal to C. And this is then the final result for the root, and therefore it's the final result for the expression. Now, you can go back and see how to do what each of these operations means, but we still need to talk about how to actually execute them on your computer. So, how do we apply one of these operators? Well, let's start with the easy one, the condition operator on our relation R. So, we have basically the file here, and what we do, we just run through it from one end to the other. And for each tuple, we check does it satisfy the condition, and if so, we put it into the output. Here, we have to read the entire file, and we can think of, can we do this smarter in some way? And as we will see later in this part, yes, sometimes we can do smarter. For instance, if it's sorted or we have an index on it, and the condition somehow satisfied the sorting or this index. I don't really expect you to follow it right now, but we'll come back and talk about both of these options later, both the sorting and the index. Other question could be how to do one of these protection with an attribute list on the relation. And again, we just read it once, and we do this kind of operation. So, for each tuple in the relation, we output the tuple restricted to only having the attributes in the attribute list. Again, this is fairly straightforward, and we can do it easily. So, we can again ask, can we do this smarter? And again, the answer is yes, but we cannot do smarter if you actually do it, but you can do it in a lazy way. And we'll see towards the end of this part what I mean by that. Basically, it's something really called pipelining here. Now, finally, how do we compute, say, the natural join of two relations? Well, it's a bit more complicated. Let's see how to do it. And I want to highlight here there are many different ways. I'm showing you first a naive way in this video. In the next video, I will show you a more advanced way to compute a natural join between R and S. So, let's look at a naive algorithm for computing joins. The most naive one is nested loop join algorithm for, say, computing R natural join S, but it can be used for other kind of joins as well. And as the name suggests, it consists of nested loops as in you have multiple loops inside each other. Here, we're using four loops, so we have the outer one, one in our R. Then we have an inner one, one in our S inside of the first four loop. And then, because we're doing a natural join right now, we see if the common attributes match. And if so, we output the tuple you obtained by combining these two tuples. For instance, let me show an example here. Say we have the stores table and we have this employees table. What kind of output do we get? So, we start by selecting one tuple to be R. We start by selecting one tuple to be S. And this, because they have a matching common attribute as in the depart column, they match in these two cases. We're going to output it, so we're getting the depart, live for the city, and Oscar for the name. And then we go to the next line for the S, because S is the inner loop. Now we have these two rows, we see that they don't match on the common attributes. So, we skip it. We go to the next row again. We see here that these two rows does not match on their common attributes. Therefore, we skip again. And now we go to the second row of the first table and the first row of the second table. And see, do these two match the common attribute? And then there is no here. Now we go to the second row of the first table and the second row of the second table. Do these two match the common attributes? In this case, yes. So, yes, they matched, and therefore we output it. And finally, we go to the second row in the first table and the last row in the second table. These two rows, and see, well, again, that the part matches in the two rows. And therefore, we put it as part of the output. And this is how we do this naive computation of joins. So, this is a fairly slow algorithm for it. For each table in R, we need to read through each table in S. And then we need to do this if statement and see if they match. So, the running time is this amount, where this R surrounded by the bars is the size, or the number of tables in R, and S surrounded by bars means the number of tables in S. This is also the general principle. So, if I write another relation in R and S and put brackets around it, I mean the number of tables in it. Here, we see that the time is quadratic of the input size, as in, if there is N tables in R, N tables in S, the running time is N squared. So, here in this video, we saw how to evaluate one of these query plans. As in, you start from the leaf, you move upward, and we can then execute each of these operations in different ways. We can, for instance, for selection, we can do linear scan by reading through the relation once. The projection is also linear scan, at least from new ways. And in this video, I have also talked about the nested loop join algorithm for joins. And I will do some more advanced algorithms for it in the next video. [ Silence ]
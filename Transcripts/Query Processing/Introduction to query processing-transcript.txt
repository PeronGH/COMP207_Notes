In this video we are going to start looking at how to process queries. This video is meant to serve as an introduction to query processing. And we will also look at what a query plan is, which is basically just a relational algebra expression for whatever query you had as input. We have in the last many videos looked at the right hand side of this diagram on the transaction manager, the recovery manager, and the concurrency controller. And then in the next few videos we are going to look at the query compiler and the execution engine. They are responsible for taking a SQL query in as input and then in some way executing these operations, making up the query. Hopefully by now you all know a lot about SQL queries. It is things like select statements, it is deletes, it is insert or update statements in SQL. So if you have an employee database, it can be things like select ID as employee ID from employee where the department is Liverpool. Or it can be if you also have a salary database, it can be searching for select name, sum of the amount from the employees, salary where the ID matches the employee ID and the department is Liverpool and then group it by name. So we only have one row for each person's name. So here I am mainly focused on select statements, however the principle works totally equally for all the other ones. It is just both SQL statements, I believe, select statements, so I will mainly talk about that when I give examples. So one thing you should notice here is we do not actually tell the database management system how to go about this task. As we don't say, say, walk through this employee table, find all the places where the department is Liverpool and output those. We just say we want this thing as output, you figure out how we do it. As such, we could also maybe have done something similar in programming languages, but because they are more general, these techniques doesn't work as well there. So this is why we can do it here and not in general programming languages. Or more precisely, we can do it there also, but not nearly as well as here. So given one of these declarations of what we want, the database management system's job is then to figure out what would be a good sequence of operations to do this job and then to execute that query after it figured out what to do. And this is the part we're going to talk about in this part of the course. So let me try first to give you an overview of how this query processing works. We start with a SQL query, then we throw it into what is called a parser, which parses the SQL query and it spits out a logical query plan for it, which is basically just with the relational algebra expression for the query plan. Then we take and optimize this, both based on the initial query and some heuristics we have for it, as well as looking at the database, like say this table is small while this table is big. Maybe we can use that to make the query more efficient, things like that. And then from there we select how to do each of the steps in this final relational algebra expression that's optimized. And after having done this optimization, we execute whatever query plan we ended up with. And after having done so, we get an answer out of it and we feed it all the way back to the user and that's our output. So that's in essence how we process a query. I'm going to focus on the two last steps here, the optimization part and the physical query plan part later. And today I'm mainly talking about the top part. I won't really be talking about how to execute things. It follows from how and what you select in this physical query plan. So yeah, we'll mainly talk about the top part here. So I should talk a little bit about relational algebra. However, most of it has been in previous videos. So basically what it is about is you have a set of operations that can be applied to relations and it gives you a new relation as an output. Basically, we have seen things like selection, projection, partition product, union, renaming, natural join, symmet joints and a bunch of other things. And the principle is something like this. You take some number of relations here, I've shown you an example with two, you plug it into an operation and out comes a new relation out of it. So for instance, if you take the union, you take one of these relations and put it after the other one and that's your output. So if you're unsure what any of this means, please go back and watch the video SQL query misc video. Because I already explained a lot about relational algebra and don't think it makes much sense to do it again when I have a perfectly good video to do it. The only exception is that the union operator was not in that video. You will find it in your second tutorial. And you can go back and watch the videos if you were not in a group, but there was a recording of the video, you can watch the tutorial in one of the other groups videos. You can find a link to all those tutorials online on the front page for Canvas for the course. There is a link to tutorials and there you can find the links to each of these groups and some of them will have videos, including for the second week. What is one of these query plans then? Well, as I said, it's just the relational algebra expression corresponding to your SQL query. And these are called a logical query plan. So you take your SQL query, you spit out a query plan for it like this one and to be clearly representing these query plans as trees. So here we have sort of a formula version of the relational algebra expression, but typically we represent them as trees because it makes lots of understanding of them easier to follow. I will show you next what I mean. Let me show you by example how to construct one of these query plans as a tree. We are given a query plan as a relational algebra expression like this as input and we want to construct a tree out of it. So the idea is that we have the input relations here, it's the stores and the employees, and these are the leaves of our tree. And the inner nodes are then the operations, connecting the ones making up the expression. And we are evaluating these trees from the leaves upward to the root. So let me try to go through this example and hopefully it becomes easier to see what's going on. So you start with the leaves. The leaves here was the input relations, it's stores and it's employees here, because that's the input relations in our expression. Now how are these composed? Well, they are, there's a Cartesian product between them, so we insert the Cartesian product and it has an arrow to each of the two leaves making up this operation. Now that is an inside selection operator, where the selection for the department should be equal to workset and the city should be equal to Liverpool. And then finally we have a projection operator on top, which protects it down to the department and the name. And this should sort of give you a fairly good idea of what's going on and how to get a tree out of one of the squirrel plants. Hopefully at least. Let me give you another example of how to get from one of the squirrel plants to a tree. So in this case we're using this squirrel plant. And again like before, you start with the leaves, so you find each relation involved in it and place it down on the bottom. Here we have stores and we have employees, so we place those down at the bottom of the tree. And then we move upward towards the tree. So we see that department is taken on the store, so we have a department pointing to stores. And on the other hand, we have a projection of workset, comma, name pointing to employees. And then sort of these two things are then, we're taking the Cartesian product of them, and that's the next step. And then on top of that, we are taking this selection operator with department equal to workset. And this is how you generate the tree from this query plan. So as you can see, it's fairly straightforward. Briefly before moving on, let me give you a taste of what will go on in this part. So for a given SQL query, we will typically have many different equivalent query plans, and they will each do the same thing. They will each produce the same output, they might not do the same thing. And it's the job of the database management system to select the best one of these query plans. Here, best will mean either faster to execute or uses the least amount of hardware operations or whatever. It depends on your application for it. And relational algebra is much better for this kind of thing than just a plain SQL query. This is part of why we saw relational algebra earlier. The other part, as mentioned back then, was that using relational algebra, you can then easily see how to compose queries, because, well, you can do it in however way you want. Now, the way we generate different equivalent query plans is typically using something called equivalence laws for relational algebra. So these equivalence laws will give us different query plans for the same input, and we can then select from among these and select the one which will be fastest on our input. It might depend on our relations, it might depend on a lot of things which will be best, and the database management system's job is to figure out which one that will be. So, for instance, we have this equivalence law, just to give you a taste of it. Here we have a condition on a natural join. Well, if you think about it, you can also just take the condition first on each part of the natural join, and then this will join them afterwards, and it will give you the same output. So the left-hand side looks like this for query plan, and the right-hand side looks like this for the query plan, and these are clearly different trees and clearly different relational algebra expressions. But if you think about it, they give you precisely the same output, and therefore we have that they are equivalent. And therefore, if one of them perhaps is faster than the other one, well, then we might want to select that one. I will not really go too much into details right now. It will come later in this part, all these details in the later videos in this part. So a brief summary. In this video, we have seen that given a SQL query, we can transfer it into an equivalent relational algebra expression, but we already saw how to do that. But we can then have this tree view on them, and we can have different version of the same tree. And this is called a logical query plan. In later videos in this part, we will then see how to optimize this query plan, and how to select appropriate algorithms for doing each of the parts of the query plan. I will first give you some examples of these suitable algorithms, then I will show you this part about optimization, and then try to explain how to select between these different algorithms afterwards. code. [BLANK_AUDIO]